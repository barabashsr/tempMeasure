
================================================================================
File: Alarm.h
Size: 4.32 kB
================================================================================

#pragma once

#include <Arduino.h>
#include <vector>
#include "MeasurementPoint.h"

// Forward declaration
class MeasurementPoint;

enum class AlarmType {
    HIGH_TEMPERATURE,    // This should be OK since it's not just "HIGH"
    LOW_TEMPERATURE,     // This should be OK since it's not just "LOW"
    SENSOR_ERROR,
    SENSOR_DISCONNECTED
};


enum class AlarmStage {
    NEW,                    // Just triggered
    ACTIVE,                 // Confirmed and active
    ACKNOWLEDGED,           // Operator acknowledged
    CLEARED,                // Condition cleared but still in delay
    RESOLVED                // Fully resolved
};

enum class AlarmPriority {
    PRIORITY_LOW,
    PRIORITY_MEDIUM,
    PRIORITY_HIGH,
    PRIORITY_CRITICAL
};


class Alarm {
public:
    // Constructor
    Alarm(AlarmType type, MeasurementPoint* source, AlarmPriority priority = AlarmPriority::PRIORITY_MEDIUM);
    
    // Destructor
    ~Alarm();
    
    // Getters
    AlarmType getType() const { return _type; }
    AlarmStage getStage() const { return _stage; }
    AlarmPriority getPriority() const { return _priority; }
    MeasurementPoint* getSource() const { return _source; }
    unsigned long getTimestamp() const { return _timestamp; }
    unsigned long getAcknowledgedTime() const { return _acknowledgedTime; }
    unsigned long getClearedTime() const { return _clearedTime; }
    String getMessage() const { return _message; }
    bool isActive() const { return _stage == AlarmStage::ACTIVE || _stage == AlarmStage::ACKNOWLEDGED; }
    bool isAcknowledged() const { return _stage == AlarmStage::ACKNOWLEDGED || _stage == AlarmStage::CLEARED; }
    bool isResolved() const { return _stage == AlarmStage::RESOLVED; }
    
    // State management
    void acknowledge();
    void clear();
    void resolve();
    void reactivate();
    
    // Update alarm condition
    bool updateCondition();
    
    // Display methods
    String getDisplayText() const;
    String getStatusText() const;
    
    // Alarm behavior configuration
    void setDelayTime(unsigned long delayMs) { _delayTime = delayMs; }
    unsigned long getDelayTime() const { return _delayTime; }
    
    // Check if delay has elapsed
    bool isDelayElapsed() const;
    
    // Comparison operators for sorting
    bool operator<(const Alarm& other) const;
    bool operator==(const Alarm& other) const;

    String getTypeString() const;
    String getStageString() const;

    // Configuration support
    String getConfigKey() const;
    void setConfigKey(const String& key);
    bool isEnabled() const { return _enabled; }
    void setEnabled(bool enabled) { _enabled = enabled; }
    uint8_t getPointAddress() const { return _source ? _source->getAddress() : 255; }

    void setPriority(AlarmPriority priority);
    void setStage(AlarmStage stage);
    
    void setHysteresis(int16_t hysteresis) { _hysteresis = hysteresis; }
    int16_t getHysteresis() const { return _hysteresis; }

    void setAcknowledgedDelay(unsigned long delay);
    unsigned long getAcknowledgedDelay() const;
    bool isAcknowledgedDelayElapsed() const;


    

private:
    AlarmType _type;
    AlarmStage _stage;
    AlarmPriority _priority;
    MeasurementPoint* _source;
    
    // Timestamps
    unsigned long _timestamp;        // When alarm was created
    unsigned long _acknowledgedTime; // When alarm was acknowledged
    unsigned long _clearedTime;      // When condition cleared

    int16_t _hysteresis;  // Configurable hysteresis value
    
    // Configuration
    unsigned long _delayTime;        // Delay before auto-resolve
    
    // Display message
    String _message;
    
    // Internal methods
    void _updateMessage();
    bool _checkCondition();

    String _getPriorityString() const;

    String _configKey;  // Format: "alarm_<point>_<type>"
    bool _enabled;      // Whether this alarm is active in configuration
    unsigned long _acknowledgedDelay; 
};

// Alarm comparison function for sorting by priority and timestamp
struct AlarmComparator {
    bool operator()(const Alarm* a, const Alarm* b) const {
        if (a->getPriority() != b->getPriority()) {
            return static_cast<int>(a->getPriority()) > static_cast<int>(b->getPriority());
        }
        return a->getTimestamp() < b->getTimestamp();
    }
};


================================================================================
File: CSVConfigManager.h
Size: 1.64 kB
================================================================================

#pragma once

#include <Arduino.h>
#include <CSV_Parser.h>
#include "TemperatureController.h"

class CSVConfigManager {
public:
    CSVConfigManager(TemperatureController& controller);
    
    // CSV export/import for combined points and alarms
    String exportPointsWithAlarmsToCSV();
    bool importPointsWithAlarmsFromCSV(const String& csvData);
    
    // Individual exports (if needed)
    String exportSensorsToCSV();
    bool importSensorsFromCSV(const String& csvData);
    
    // File operations
    bool saveCSVToFile(const String& filename, const String& csvData);
    String loadCSVFromFile(const String& filename);
    
    // Validation
    bool validatePointsCSV(const String& csvData);
    String getLastError() const { return _lastError; }

private:
    TemperatureController& _controller;
    String _lastError;
    
    // Helper methods
    String _escapeCSVField(const String& field);
    String _unescapeCSVField(const String& field);
    bool _parseAlarmFromCSV(int pointAddress, const String& alarmType, 
                           const String& priority, const String& enabled, 
                           const String& hysteresis);
    
    // Additional helper methods needed
    String _getAlarmTypeString(AlarmType type);
    AlarmType _parseAlarmType(const String& typeStr);
    String _getPriorityString(AlarmPriority priority);
    AlarmPriority _parsePriority(const String& priorityStr);
    void _exportPointToCSV(String& csv, MeasurementPoint* point, const String& pointType);
    bool _parseCSVLine(const String& line);
    String _getAlarmPriorityForPoint(int pointAddress, AlarmType alarmType);
};


================================================================================
File: ConfigManager.h
Size: 4.01 kB
================================================================================

#ifndef CONFIG_MANAGER_H
#define CONFIG_MANAGER_H

#include <Arduino.h>
#include <ConfigAssist.h>
#include <ConfigAssistHelper.h>
#include <WebServer.h>
#include <LittleFS.h>
#include "TemperatureController.h"
#include "CSVConfigManager.h"
#include "SettingsCSVManager.h"

// YAML configuration definition
extern const char* VARIABLES_DEF_YAML;

class ConfigManager {
private:
    SettingsCSVManager settingsCSVManager;
    CSVConfigManager csvManager;
    ConfigAssist conf;
    ConfigAssistHelper* confHelper;
    TemperatureController& controller;
    WebServer* server;
    bool portalActive;
    
    // Callback function for ConfigAssist
    static void onConfigChanged(String key);
    
    // Pointer to instance for callback functions
    static ConfigManager* instance;
    void _applySettingsWithoutRestart();
    
    // Save sensor configuration to file
    //void saveSensorConfig();
    
    // Load sensor configuration from file
    //void loadSensorConfig();

public:
    ConfigManager(TemperatureController& tempController);
    ~ConfigManager();
    
    // Initialize configuration
    bool begin();
    
    // Update configuration (call in loop)
    void update();
    
    // Connect to WiFi
    bool connectWiFi(int timeoutMs = 15000);
    
    // Add sensor to configuration
    // bool addSensorToConfig(SensorType type, uint8_t address, const String& name, 
    //                       const uint8_t* romAddress = nullptr);
    
    // Remove sensor from configuration
    //bool removeSensorFromConfig(uint8_t address);
    
    // Update sensor in configuration
    // bool updateSensorInConfig(uint8_t address, const String& name, 
    //                          int16_t lowAlarm, int16_t highAlarm);
    
    // Get web server instance
    WebServer* getWebServer() { return server; }
    
    // Check if portal is active
    bool isPortalActive() { return portalActive; }
    
    // Get configuration values
    String getWifiSSID() { return conf("st_ssid"); }
    String getWifiPassword() { return conf("st_pass"); }
    String getHostname() { return conf("host_name"); }
    uint16_t getDeviceId() { return conf("device_id").toInt(); }
    uint16_t getMeasurementPeriod() { return conf("measurement_period").toInt(); }
    bool isModbusEnabled() { return conf("modbus_enabled").toInt() == 1; }
    uint8_t getModbusAddress() { return conf("modbus_address").toInt(); }
    uint32_t getModbusBaudRate() { return conf("modbus_baud_rate").toInt(); }
    uint8_t getRxPin() { return conf("rs485_rx_pin").toInt(); }
    uint8_t getTxPin() { return conf("rs485_tx_pin").toInt(); }
    //uint8_t getDePin() { return conf("rs485_de_pin").toInt(); }
    //uint8_t getOneWirePin() { return conf("onewire_pin").toInt(); }
    bool getAutoDiscover() { return conf("auto_discover").toInt() == 1; }
    
    // Reset min/max values
    void resetMinMaxValues();
    //void updateSensorInConfig(Sensor* sensor);
    // Remove:
// void saveSensorConfig();
// void loadSensorConfig();
// bool addSensorToConfig(...);
// bool removeSensorFromConfig(...);
// bool updateSensorInConfig(...);
// void updateSensorInConfig(Sensor* sensor);

    // Add:
    void savePointsConfig();
    void loadPointsConfig();
    bool updatePointInConfig(uint8_t address, const String& name, int16_t lowAlarm, int16_t highAlarm,
                            const String& ds18b20RomString = "", int pt1000ChipSelect = -1);
    
    void saveAlarmsConfig();
    void loadAlarmsConfig();

    CSVConfigManager& getCSVManager() { return csvManager; }

    uint16_t getAcknowledgedDelayCritical() { return conf("ack_delay_critical").toInt(); }
    uint16_t getAcknowledgedDelayHigh() { return conf("ack_delay_high").toInt(); }
    uint16_t getAcknowledgedDelayMedium() { return conf("ack_delay_medium").toInt(); }
    uint16_t getAcknowledgedDelayLow() { return conf("ack_delay_low").toInt(); }
    };

// Initialize static member
//ConfigManager* ConfigManager::instance = nullptr;

#endif // CONFIG_MANAGER_H


================================================================================
File: IndicatorInterface.h
Size: 5.5 kB
================================================================================

#ifndef INDICATOR_INTERFACE_H
#define INDICATOR_INTERFACE_H

#include <Arduino.h>
#include <Wire.h>
#include <map>
#include <string>
#include "PCF8575.h"
#include <U8g2lib.h>

class IndicatorInterface {
public:
    // Constructor
    IndicatorInterface(TwoWire& i2cBus, uint8_t pcf_i2cAddress, int intPin = -1);
    
    // Destructor
    ~IndicatorInterface();
    
    // Initialization
    bool begin();
    
    // Configuration setters
    void setDirection(uint16_t directionMask);          // 0 = input, 1 = output
    void setMode(uint16_t modeMask);                    // 0 = normal, 1 = inverted
    void setPortNames(const std::map<std::string, uint8_t>& portNames);
    void setPortName(const std::string& name, uint8_t portNumber);
    
    // Port control methods
    bool writePort(const std::string& portName, bool state);
    bool writePort(uint8_t portNumber, bool state);
    void writePorts(uint16_t portMask);                 // Write only to outputs
    void setAllOutputs(bool state);
    void setAllOutputsHigh();
    void setAllOutputsLow();
    
    void setPortInverted(const std::string& portName, bool inverted);
    void setPortInverted(uint8_t portNumber, bool inverted);

    
    // Port reading methods
    uint16_t getCurrentState();
    bool readPort(const std::string& portName);
    bool readPort(uint8_t portNumber);
    
    // Utility methods
    bool isOutput(uint8_t portNumber);
    bool isInput(uint8_t portNumber);
    bool isInverted(uint8_t portNumber);
    uint8_t getPortNumber(const std::string& portName);
    std::string getPortName(uint8_t portNumber);
    
    // Interrupt handling
    void handleInterrupt();
    void setInterruptCallback(void (*callback)(uint16_t currentState, uint16_t changedPins));
    
    // Debug methods
    void printPortStates();
    void printConfiguration();

    // OLED control methods
    void setOledSleepDelay(long sleepDelay);        // -1 = never sleep
    void setOledMode(int lines);                    // 1-5 lines
    void printText(String buffer[], int bufferSize);
    void setOLEDblink(int timeOn, int timeOff, bool blinkOn = true);
    void setOLEDOff();
    void setOLEDOn();
    void updateOLED();                              // Call this in loop for scrolling/blinking

    // Add these to the public section:
    void pushLine(String newLine);                      // Push new line, shift others down
    void displayOK();                                   // Display huge "OK"
    void displayCross();                                // Display huge cross in circle
    void blinkOK(int blinkDelay);                       // Blink between OK and previous text
    void blinkCross(int blinkDelay);                    // Blink between cross and previous text
    void stopBlinking();                                // Stop any blinking and restore text


private:
    // Hardware configuration
    TwoWire* _i2cBus;
    uint8_t _pcf_i2cAddress;
    uint8_t oled_i2cAddress;
    int _intPin;
    PCF8575 _pcf8575;
    
    // Port configuration
    uint16_t _directionMask;    // 0 = input, 1 = output
    uint16_t _modeMask;         // 0 = normal, 1 = inverted
    std::map<std::string, uint8_t> _portNames;
    std::map<uint8_t, std::string> _portNumbers;
    
    // State tracking
    uint16_t _currentState;
    uint16_t _lastState;
    unsigned long _lastReadTime;
    unsigned long _pollInterval;
    
    // Interrupt handling
    volatile bool _interruptFlag;
    bool _useInterrupts;
    void (*_interruptCallback)(uint16_t currentState, uint16_t changedPins);
    
    // Internal methods
    void _updateState();
    void _clearInterrupt();
    uint16_t _readPCF();
    void _writePCF(uint16_t state);
    bool _applyModeLogic(uint8_t portNumber, bool state);
    bool _reverseModeLogic(uint8_t portNumber, bool state);
    void _configureInterruptPin();
    
    // Static interrupt handler
    static IndicatorInterface* _instance;
    static void IRAM_ATTR _staticInterruptHandler();
    static U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2;

    // OLED configuration
    long _oledSleepDelay;
    int _oledLines;
    String _textBuffer[5];                          // Max 5 lines
    int _textBufferSize;
    bool _oledOn;
    bool _oledBlink;
    int _blinkTimeOn;
    int _blinkTimeOff;
    unsigned long _lastBlinkTime;
    bool _blinkState;
    unsigned long _lastActivityTime;
    bool _oledSleeping;
    
    // Scrolling variables
    int _scrollOffset[5];                           // Scroll offset for each line
    unsigned long _lastScrollTime;
    int _scrollDelay;
    int _charWidth;
    int _lineHeight;
    int _maxCharsPerLine;
    
    // Internal OLED methods
    void _initOLED();
    void _updateOLEDDisplay();
    void _handleOLEDSleep();
    void _handleOLEDBlink();
    void _handleScrolling();
    void _drawTextLine(int lineIndex, int yPos);
    void _calculateDisplayParams();
    void _wakeOLED();
    //void _fixSH1106Offset();
    // Add these to the private section:
    String _savedTextBuffer[5];                         // Backup of text before OK/Cross
    int _savedTextBufferSize;
    int _savedOledLines;
    bool _isBlinkingOK;
    bool _isBlinkingCross;
    int _blinkDelayTime;
    unsigned long _lastBlinkToggle;
    bool _blinkShowSpecial;                             // true = show OK/Cross, false = show text

    // Internal methods
    void _saveCurrentText();
    void _restoreCurrentText();
    void _handleSpecialBlink();

};

#endif


================================================================================
File: MeasurementPoint.h
Size: 1.95 kB
================================================================================

#ifndef MEASUREMENT_POINT_H
#define MEASUREMENT_POINT_H

#include <Arduino.h>
#include "Sensor.h"



class MeasurementPoint {
public:
    // Constructor
    MeasurementPoint() : address(0), name(""), currentTemp(0), minTemp(32767), maxTemp(-32768),
    lowAlarmThreshold(-10), highAlarmThreshold(50), alarmStatus(0), errorStatus(0), boundSensor(nullptr) {}
    MeasurementPoint(uint8_t address, const String& name);

    // Destructor
    ~MeasurementPoint();

    // Getters
    uint8_t getAddress() const;
    String getName() const;
    int16_t getCurrentTemp() const;
    int16_t getMinTemp() const;
    int16_t getMaxTemp() const;
    int16_t getLowAlarmThreshold() const;
    int16_t getHighAlarmThreshold() const;
    uint8_t getAlarmStatus() const;
    uint8_t getErrorStatus() const;

    // Setters
    void setName(const String& newName);
    void setLowAlarmThreshold(int16_t threshold);
    void setHighAlarmThreshold(int16_t threshold);

    // Sensor binding (optional)
    void bindSensor(Sensor* sensor);
    void unbindSensor();
    Sensor* getBoundSensor() const;

    // Operations
    void update();              // Should be called to refresh temperature and status
    void resetMinMaxTemp();     // Resets min/max to current
    // void setOneWireBus(uint8_t bus);
    // uint8_t getOneWireBus();

private:
    uint8_t address;
    String name;
    // uint8_t oneWireBus;

    int16_t currentTemp;        // Latest temperature (Â°C x1)
    int16_t minTemp;            // Minimum recorded temperature
    int16_t maxTemp;            // Maximum recorded temperature
    int16_t lowAlarmThreshold;  // Alarm threshold low
    int16_t highAlarmThreshold; // Alarm threshold high
    uint8_t alarmStatus;        // Alarm status bits
    uint8_t errorStatus;        // Error status bits

    Sensor* boundSensor;        // Pointer to bound sensor, or nullptr

    void updateAlarmStatus();
};


#endif // TEMPERATURE_CONTROLLER_H


================================================================================
File: RegisterMap.h
Size: 4.01 kB
================================================================================

#ifndef REGISTER_MAP_H
#define REGISTER_MAP_H

#include <stdint.h>
#include "MeasurementPoint.h"

class RegisterMap {
private:
    // Device Information Registers (0-99)
    uint16_t deviceId;
    uint16_t firmwareVersion;
    uint16_t numActiveDS18B20;
    uint16_t numActivePT1000;
    uint16_t deviceStatus[7]; // Registers 4-10

    // Temperature Data Registers (100-599)
    int16_t currentTemps[60];    // 100-159
    int16_t minTemps[60];        // 200-259
    int16_t maxTemps[60];        // 300-359
    uint16_t alarmStatus[60];    // 400-459
    uint16_t errorStatus[60];    // 500-559

    // Configuration Registers (600-799)
    int16_t lowAlarmThresholds[60];  // 600-659
    int16_t highAlarmThresholds[60]; // 700-759

    // Helpers
    bool isValidAddress(uint16_t address);
    bool isReadOnlyRegister(uint16_t address);

public:
    RegisterMap();

    // Register read/write
    uint16_t readHoldingRegister(uint16_t address);
    bool writeHoldingRegister(uint16_t address, uint16_t value);

    // Update register map from measurement point data
    void updateFromMeasurementPoint(const MeasurementPoint& point);

    // Apply config (thresholds) to and from measurement points
    void applyConfigToMeasurementPoint(MeasurementPoint& point);
    void applyConfigFromMeasurementPoint(const MeasurementPoint& point);

    // Utility methods for device info
    void incrementActiveDS18B20() { numActiveDS18B20++; }
    void decrementActiveDS18B20() { if (numActiveDS18B20 > 0) numActiveDS18B20--; }
    void incrementActivePT1000() { numActivePT1000++; }
    void decrementActivePT1000() { if (numActivePT1000 > 0) numActivePT1000--; }

    uint16_t getDeviceId() const { return deviceId; }
    uint16_t getFirmwareVersion() const { return firmwareVersion; }
    uint16_t getNumActiveDS18B20() const { return numActiveDS18B20; }
    uint16_t getNumActivePT1000() const { return numActivePT1000; }

    // Register address constants (as in your original code)
    static const uint16_t DEVICE_ID_REG = 0;
    static const uint16_t FIRMWARE_VERSION_REG = 1;
    static const uint16_t NUM_DS18B20_REG = 2;
    static const uint16_t NUM_PT1000_REG = 3;
    static const uint16_t DEVICE_STATUS_START_REG = 4;
    static const uint16_t DEVICE_STATUS_END_REG = 10;
    static const uint16_t CURRENT_TEMP_DS18B20_START_REG = 100;
    static const uint16_t CURRENT_TEMP_DS18B20_END_REG = 149;
    static const uint16_t CURRENT_TEMP_PT1000_START_REG = 150;
    static const uint16_t CURRENT_TEMP_PT1000_END_REG = 159;
    static const uint16_t MIN_TEMP_DS18B20_START_REG = 200;
    static const uint16_t MIN_TEMP_DS18B20_END_REG = 249;
    static const uint16_t MIN_TEMP_PT1000_START_REG = 250;
    static const uint16_t MIN_TEMP_PT1000_END_REG = 259;
    static const uint16_t MAX_TEMP_DS18B20_START_REG = 300;
    static const uint16_t MAX_TEMP_DS18B20_END_REG = 349;
    static const uint16_t MAX_TEMP_PT1000_START_REG = 350;
    static const uint16_t MAX_TEMP_PT1000_END_REG = 359;
    static const uint16_t ALARM_STATUS_DS18B20_START_REG = 400;
    static const uint16_t ALARM_STATUS_DS18B20_END_REG = 449;
    static const uint16_t ALARM_STATUS_PT1000_START_REG = 450;
    static const uint16_t ALARM_STATUS_PT1000_END_REG = 459;
    static const uint16_t ERROR_STATUS_DS18B20_START_REG = 500;
    static const uint16_t ERROR_STATUS_DS18B20_END_REG = 549;
    static const uint16_t ERROR_STATUS_PT1000_START_REG = 550;
    static const uint16_t ERROR_STATUS_PT1000_END_REG = 559;
    static const uint16_t LOW_ALARM_DS18B20_START_REG = 600;
    static const uint16_t LOW_ALARM_DS18B20_END_REG = 649;
    static const uint16_t LOW_ALARM_PT1000_START_REG = 650;
    static const uint16_t LOW_ALARM_PT1000_END_REG = 659;
    static const uint16_t HIGH_ALARM_DS18B20_START_REG = 700;
    static const uint16_t HIGH_ALARM_DS18B20_END_REG = 749;
    static const uint16_t HIGH_ALARM_PT1000_START_REG = 750;
    static const uint16_t HIGH_ALARM_PT1000_END_REG = 759;
};

#endif // REGISTER_MAP_H


================================================================================
File: Sensor.h
Size: 2.61 kB
================================================================================

#ifndef SENSOR_H
#define SENSOR_H

#include <Arduino.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <Adafruit_MAX31865.h>

// Define your sensor types
enum class SensorType {
    DS18B20,
    PT1000
};

// Error and alarm bitmasks
constexpr uint8_t ERROR_COMMUNICATION = 0x01;
constexpr uint8_t ERROR_OUT_OF_RANGE  = 0x02;
constexpr uint8_t ERROR_DISCONNECTED  = 0x04;

constexpr uint8_t ALARM_LOW_TEMP  = 0x01;
constexpr uint8_t ALARM_HIGH_TEMP = 0x02;

class Sensor {
public:
    Sensor(SensorType type, uint8_t address, const String& name);
    ~Sensor();

    // Setup methods for each sensor type
    void setupDS18B20(uint8_t pin, const uint8_t* deviceAddress);
    void setupPT1000(uint8_t csPin, uint8_t maxAddress);

    // Initialize hardware
    bool initialize();

    // Read temperature from the sensor, update internal state
    bool readTemperature();

    // Accessors
    SensorType getType() const;
    uint8_t getAddress() const;
    String getName() const;
    void setName(const String& newName);

    int16_t getCurrentTemp() const;
    int16_t getMinTemp() const;
    int16_t getMaxTemp() const;
    int16_t getLowAlarmThreshold() const;
    int16_t getHighAlarmThreshold() const;
    uint8_t getAlarmStatus() const;
    uint8_t getErrorStatus() const;
    uint8_t getPT1000ChipSelectPin() const;
    

    void setAddress(uint8_t newAddress);
    void setLowAlarmThreshold(int16_t threshold);
    void setHighAlarmThreshold(int16_t threshold);

    // DS18B20 ROM address accessor
    const uint8_t* getDS18B20Address() const;

    // Reset min/max values
    void resetMinMaxTemp();

    // Update alarm status (call after reading temperature or changing thresholds)
    void updateAlarmStatus();
    String getDS18B20RomString() const;        // ROM as hex string
    void getDS18B20RomArray(uint8_t out[8]) const; // ROM as array
    uint8_t getOneWirePin() {return connection.ds18b20.oneWirePin;}

private:
    uint8_t address;
    String name;
    SensorType type;

    int16_t currentTemp;
    int16_t minTemp;
    int16_t maxTemp;
    int16_t lowAlarmThreshold;
    int16_t highAlarmThreshold;
    uint8_t alarmStatus;
    uint8_t errorStatus;

    // Hardware-specific members
    OneWire* oneWire;
    DallasTemperature* dallasTemperature;
    Adafruit_MAX31865* max31865;

    // Connection details
    union {
        struct {
            uint8_t oneWirePin;
            uint8_t oneWireAddress[8];
        } ds18b20;
        struct {
            uint8_t csPin;
            uint8_t maxAddress;
        } pt1000;
    } connection;
};

#endif // SENSOR_H


================================================================================
File: SettingsCSVManager.h
Size: 826 B
================================================================================

#pragma once

#include <Arduino.h>
#include "ConfigAssist.h"

class SettingsCSVManager {
public:
    SettingsCSVManager(ConfigAssist& config);
    
    // CSV export/import for settings
    String exportSettingsToCSV();
    bool importSettingsFromCSV(const String& csvData);
    
    // Validation
    bool validateSettingsCSV(const String& csvData);
    String getLastError() const { return _lastError; }

private:
    ConfigAssist& _config;
    String _lastError;
    
    // Helper methods
    String _escapeCSVField(const String& field);
    String _unescapeCSVField(const String& field);
    bool _parseCSVLine(const String& line);
    
    // Add these helper methods for acknowledged delays
    void _exportAcknowledgedDelays(String& csv);
    bool _importAcknowledgedDelays(const String& key, const String& value);
};


================================================================================
File: TempModbusServer.h
Size: 1.01 kB
================================================================================

#ifndef TEMP_MODBUS_SERVER_H
#define TEMP_MODBUS_SERVER_H

#include <Arduino.h>
#include "ModbusServerRTU.h"
#include "RegisterMap.h"

class TempModbusServer {
private:
    ModbusServerRTU* mbServer;
    RegisterMap& registerMap;
    uint8_t serverID;
    HardwareSerial& serial;
    int rxPin;
    int txPin;
    int dePin;
    int baudRate;
    
    // Worker functions for different Modbus function codes
    static ModbusMessage readHoldingRegistersWorker(ModbusMessage request);
    static ModbusMessage writeHoldingRegisterWorker(ModbusMessage request);
    static ModbusMessage writeMultipleRegistersWorker(ModbusMessage request);
    
    // Pointer to the RegisterMap instance for static worker functions
    static RegisterMap* registerMapPtr;

public:
    TempModbusServer(RegisterMap& regMap, uint8_t id, HardwareSerial& serialPort, 
                 int rx, int tx, int de, int baud = 9600);
    ~TempModbusServer();
    
    bool begin();
    void stop();
};



#endif // TEMP_MODBUS_SERVER_H


================================================================================
File: TemperatureController.h
Size: 6.01 kB
================================================================================

#pragma once

#include <Arduino.h>
#include <vector>
#include "Sensor.h"
#include "MeasurementPoint.h"
#include "RegisterMap.h"
#include "IndicatorInterface.h"
#include "Alarm.h"
#include <OneWire.h>
#include <DallasTemperature.h>
#include <ArduinoJson.h>
#include <algorithm>

class TemperatureController {
public:
    TemperatureController(uint8_t oneWirePin[4], uint8_t csPin[4], IndicatorInterface& indicator);
    ~TemperatureController();
    
    bool begin();
    
    // Measurement point management
    MeasurementPoint* getMeasurementPoint(uint8_t address);
    MeasurementPoint* getDS18B20Point(uint8_t idx);
    MeasurementPoint* getPT1000Point(uint8_t idx);
    
    // Sensor management
    bool addSensor(Sensor* sensor);
    bool removeSensorByRom(const String& romString);
    Sensor* findSensorByRom(const String& romString);
    Sensor* findSensorByChipSelect(uint8_t csPin);
    int getSensorCount() const { return sensors.size(); }
    Sensor* getSensorByIndex(int idx);
    
    // Sensor binding
    bool bindSensorToPointByRom(const String& romString, uint8_t pointAddress);
    bool bindSensorToPointByChipSelect(uint8_t csPin, uint8_t pointAddress);
    bool unbindSensorFromPoint(uint8_t pointAddress);
    Sensor* getBoundSensor(uint8_t pointAddress);
    bool unbindSensorFromPointBySensor(Sensor* sensor);
    
    // Main update and measurement
    void update();
    void readAllPoints();
    void updateRegisterMap();
    void applyConfigFromRegisterMap();
    void applyConfigToRegisterMap();
    
    // Sensor discovery
    bool discoverDS18B20Sensors();
    bool discoverPTSensors();
    
    // JSON output
    String getSensorsJson();
    String getPointsJson();
    String getSystemStatusJson();
    
    // Utility functions
    void resetMinMaxValues();
    RegisterMap& getRegisterMap() { return registerMap; }
    
    // Configuration
    void setDeviceId(uint16_t id);
    uint16_t getDeviceId() const;
    void setFirmwareVersion(uint16_t version);
    uint16_t getFirmwareVersion() const;
    void setMeasurementPeriod(uint16_t seconds);
    uint16_t getMeasurementPeriod() const;
    void setOneWireBusPin(uint8_t pin, size_t idx);
    uint8_t getOneWirePin(size_t bus);
    
    // Statistics
    int getDS18B20Count() const;
    int getPT1000Count() const;
    void updateAllSensors();
    int getSensorBus(Sensor* sensor);
    
    // New Alarm Management
    void updateAlarms();
    String getAlarmsJson();
    void handleAlarmDisplay();
    void handleAlarmOutputs();

    std::vector<Alarm*> getActiveAlarms() const;
    void createAlarm(AlarmType type, MeasurementPoint* source, AlarmPriority priority);
    Alarm* getHighestPriorityAlarm() const;
    void acknowledgeHighestPriorityAlarm();
    void acknowledgeAllAlarms();
    void clearResolvedAlarms();
    void clearConfiguredAlarms();

    // Alarm management (similar to sensor management)
    bool addAlarm(AlarmType type, uint8_t pointAddress, AlarmPriority priority);
    bool removeAlarm(const String& configKey);
    bool updateAlarm(const String& configKey, AlarmPriority priority, bool enabled);
    Alarm* findAlarm(const String& configKey);
    Alarm* getAlarmByIndex(int idx);
    int getAlarmCount() const { return _configuredAlarms.size(); }
    std::vector<Alarm*> getConfiguredAlarms() const { return _configuredAlarms; }

    // JSON output (similar to getSensorsJson, getPointsJson)
    //String getAlarmsJson();

    // Alarm handling scenarios (placeholders)
    void handleCriticalAlarms();
    void handleHighPriorityAlarms();
    void handleMediumPriorityAlarms();
    void handleLowPriorityAlarms();

    bool bindSensorToPointByBusNumber(uint8_t busNumber, uint8_t pointAddress);


    // Setters for acknowledged delays
    void setAcknowledgedDelayCritical(unsigned long delay);
    void setAcknowledgedDelayHigh(unsigned long delay);
    void setAcknowledgedDelayMedium(unsigned long delay);
    void setAcknowledgedDelayLow(unsigned long delay);
    
    // Getters for acknowledged delays
    unsigned long getAcknowledgedDelayCritical() const;
    unsigned long getAcknowledgedDelayHigh() const;
    unsigned long getAcknowledgedDelayMedium() const;
    unsigned long getAcknowledgedDelayLow() const;
    
    // Method to apply delays to existing alarms
    void applyAcknowledgedDelaysToAlarms();



private:
    // Hardware components
    IndicatorInterface& indicator;
    OneWire* oneWireBuses[4];
    DallasTemperature* dallasSensors[4];
    
    // Measurement points and sensors
    MeasurementPoint dsPoints[50];
    MeasurementPoint ptPoints[10];
    std::vector<Sensor*> sensors;
    
    // System configuration
    RegisterMap registerMap;
    uint16_t measurementPeriodSeconds;
    uint16_t deviceId;
    uint16_t firmwareVersion;
    unsigned long lastMeasurementTime;
    bool systemInitialized;
    uint8_t oneWireBusPin[4];
    uint8_t chipSelectPin[4];
    
    // Alarm system
    //std::vector<Alarm*> _alarms;
    std::vector<Alarm*> _configuredAlarms; 
    unsigned long _lastAlarmCheck;
    const unsigned long _alarmCheckInterval = 1000; // Check every second
    bool _lastButtonState;
    unsigned long _lastButtonPressTime;
    const unsigned long _buttonDebounceDelay = 200;
    
    // Display management
    Alarm* _currentDisplayedAlarm;
    unsigned long _okDisplayStartTime;
    bool _showingOK;
    
    // Internal methods
    bool isDS18B20Address(uint8_t address) const { return address < 50; }
    bool isPT1000Address(uint8_t address) const { return address >= 50 && address < 60; }
    
    // Alarm helper methods
    void _checkPointForAlarms(MeasurementPoint* point);
    bool _hasAlarmForPoint(MeasurementPoint* point, AlarmType type);
    void _checkButtonPress();
    void _updateNormalDisplay();
    void _showOKAndTurnOffOLED();

    unsigned long _acknowledgedDelayCritical;
    unsigned long _acknowledgedDelayHigh;
    unsigned long _acknowledgedDelayMedium;
    unsigned long _acknowledgedDelayLow;

    
};


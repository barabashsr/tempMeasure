
================================================================================
File: Alarm.h
Size: 4.41 kB
================================================================================

#pragma once

#include <Arduino.h>
#include <vector>
#include "MeasurementPoint.h"
#include "LoggerManager.h"

// Forward declaration
class MeasurementPoint;

enum class AlarmType {
    HIGH_TEMPERATURE,    // This should be OK since it's not just "HIGH"
    LOW_TEMPERATURE,     // This should be OK since it's not just "LOW"
    SENSOR_ERROR,
    SENSOR_DISCONNECTED
};


enum class AlarmStage {
    NEW,                    // Just triggered
    CLEARED,                // Condition cleared but still in delay
    RESOLVED,                // Fully resolved
    ACKNOWLEDGED,           // Operator acknowledged
    ACTIVE                 // Confirmed and active


};

enum class AlarmPriority {
    PRIORITY_LOW,
    PRIORITY_MEDIUM,
    PRIORITY_HIGH,
    PRIORITY_CRITICAL
};


class Alarm {
public:
    // Constructor
    Alarm(AlarmType type, MeasurementPoint* source, AlarmPriority priority = AlarmPriority::PRIORITY_MEDIUM);
    
    // Destructor
    ~Alarm();
    
    // Getters
    AlarmType getType() const { return _type; }
    AlarmStage getStage() const { return _stage; }
    AlarmPriority getPriority() const { return _priority; }
    MeasurementPoint* getSource() const { return _source; }
    unsigned long getTimestamp() const { return _timestamp; }
    unsigned long getAcknowledgedTime() const { return _acknowledgedTime; }
    unsigned long getClearedTime() const { return _clearedTime; }
    String getMessage() const { return _message; }
    bool isActive() const { return _stage == AlarmStage::ACTIVE || _stage == AlarmStage::ACKNOWLEDGED; }
    bool isAcknowledged() const { return _stage == AlarmStage::ACKNOWLEDGED || _stage == AlarmStage::CLEARED; }
    bool isResolved() const { return _stage == AlarmStage::RESOLVED; }
    
    // State management
    void acknowledge();
    void clear();
    void resolve();
    void reactivate();
    
    // Update alarm condition
    bool updateCondition();
    
    // Display methods
    String getDisplayText() const;
    String getStatusText() const;
    
    // Alarm behavior configuration
    void setDelayTime(unsigned long delayMs) { _delayTime = delayMs; }
    unsigned long getDelayTime() const { return _delayTime; }
    
    // Check if delay has elapsed
    bool isDelayElapsed() const;
    
    // Comparison operators for sorting
    bool operator<(const Alarm& other) const;
    bool operator==(const Alarm& other) const;

    String getTypeString() const;
    String getStageString() const;

    // Configuration support
    String getConfigKey() const;
    void setConfigKey(const String& key);
    bool isEnabled() const { return _enabled; }
    void setEnabled(bool enabled);
    uint8_t getPointAddress() const { return _source ? _source->getAddress() : 255; }

    void setPriority(AlarmPriority priority);
    void setStage(AlarmStage stage);
    
    void setHysteresis(int16_t hysteresis);
    int16_t getHysteresis() const { return _hysteresis; }

    void setAcknowledgedDelay(unsigned long delay);
    unsigned long getAcknowledgedDelay() const;
    bool isAcknowledgedDelayElapsed() const;
    unsigned long getAcknowledgedTimeLeft() const;


    

private:
    AlarmType _type;
    AlarmStage _stage;
    AlarmPriority _priority;
    MeasurementPoint* _source;
    
    // Timestamps
    unsigned long _timestamp;        // When alarm was created
    unsigned long _acknowledgedTime; // When alarm was acknowledged
    unsigned long _clearedTime;      // When condition cleared

    int16_t _hysteresis;  // Configurable hysteresis value
    
    // Configuration
    unsigned long _delayTime;        // Delay before auto-resolve
    
    // Display message
    String _message;
    
    // Internal methods
    void _updateMessage();
    bool _checkCondition();

    String _getPriorityString() const;

    String _configKey;  // Format: "alarm_<point>_<type>"
    bool _enabled;      // Whether this alarm is active in configuration
    unsigned long _acknowledgedDelay; 
    String _getPriorityString(AlarmPriority priority) const;
};

// Alarm comparison function for sorting by priority and timestamp
struct AlarmComparator {
    bool operator()(const Alarm* a, const Alarm* b) const {
        if (a->getPriority() != b->getPriority()) {
            return static_cast<int>(a->getPriority()) > static_cast<int>(b->getPriority());
        }
        return a->getTimestamp() < b->getTimestamp();
    }
};


================================================================================
File: CSVConfigManager.h
Size: 1.64 kB
================================================================================

#pragma once

#include <Arduino.h>
#include <CSV_Parser.h>
#include "TemperatureController.h"

class CSVConfigManager {
public:
    CSVConfigManager(TemperatureController& controller);
    
    // CSV export/import for combined points and alarms
    String exportPointsWithAlarmsToCSV();
    bool importPointsWithAlarmsFromCSV(const String& csvData);
    
    // Individual exports (if needed)
    String exportSensorsToCSV();
    bool importSensorsFromCSV(const String& csvData);
    
    // File operations
    bool saveCSVToFile(const String& filename, const String& csvData);
    String loadCSVFromFile(const String& filename);
    
    // Validation
    bool validatePointsCSV(const String& csvData);
    String getLastError() const { return _lastError; }

private:
    TemperatureController& _controller;
    String _lastError;
    
    // Helper methods
    String _escapeCSVField(const String& field);
    String _unescapeCSVField(const String& field);
    bool _parseAlarmFromCSV(int pointAddress, const String& alarmType, 
                           const String& priority, const String& enabled, 
                           const String& hysteresis);
    
    // Additional helper methods needed
    String _getAlarmTypeString(AlarmType type);
    AlarmType _parseAlarmType(const String& typeStr);
    String _getPriorityString(AlarmPriority priority);
    AlarmPriority _parsePriority(const String& priorityStr);
    void _exportPointToCSV(String& csv, MeasurementPoint* point, const String& pointType);
    bool _parseCSVLine(const String& line);
    String _getAlarmPriorityForPoint(int pointAddress, AlarmType alarmType);
};


================================================================================
File: ConfigManager.h
Size: 4.18 kB
================================================================================

#ifndef CONFIG_MANAGER_H
#define CONFIG_MANAGER_H

#include <Arduino.h>
#include <ConfigAssist.h>
#include <ConfigAssistHelper.h>
#include <WebServer.h>
#include <LittleFS.h>
#include "TemperatureController.h"
#include "CSVConfigManager.h"
#include "SettingsCSVManager.h"
#include "LoggerManager.h" 

// YAML configuration definition
extern const char* VARIABLES_DEF_YAML;

class ConfigManager {
private:
    SettingsCSVManager settingsCSVManager;
    CSVConfigManager csvManager;
    ConfigAssist conf;
    ConfigAssistHelper* confHelper;
    TemperatureController& controller;
    WebServer* server;
    bool portalActive;
    
    // Callback function for ConfigAssist
    static void onConfigChanged(String key);
    
    // Pointer to instance for callback functions
    static ConfigManager* instance;
    void _applySettingsWithoutRestart();

    void basicAPI();
    void sensorAPI();
    void csvImportExportAPI();
    void pointsAPI();
    void alarmsAPI();
    void logsAPI();

    
    // Save sensor configuration to file
    //void saveSensorConfig();
    
    // Load sensor configuration from file
    //void loadSensorConfig();

public:
    ConfigManager(TemperatureController& tempController);
    ~ConfigManager();
    
    // Initialize configuration
    bool begin();
    
    // Update configuration (call in loop)
    void update();
    
    // Connect to WiFi
    bool connectWiFi(int timeoutMs = 15000);
    
    // Add sensor to configuration
    // bool addSensorToConfig(SensorType type, uint8_t address, const String& name, 
    //                       const uint8_t* romAddress = nullptr);
    
    // Remove sensor from configuration
    //bool removeSensorFromConfig(uint8_t address);
    
    // Update sensor in configuration
    // bool updateSensorInConfig(uint8_t address, const String& name, 
    //                          int16_t lowAlarm, int16_t highAlarm);
    
    // Get web server instance
    WebServer* getWebServer() { return server; }
    
    // Check if portal is active
    bool isPortalActive() { return portalActive; }
    
    // Get configuration values
    String getWifiSSID() { return conf("st_ssid"); }
    String getWifiPassword() { return conf("st_pass"); }
    String getHostname() { return conf("host_name"); }
    uint16_t getDeviceId() { return conf("device_id").toInt(); }
    uint16_t getMeasurementPeriod() { return conf("measurement_period").toInt(); }
    bool isModbusEnabled() { return conf("modbus_enabled").toInt() == 1; }
    uint8_t getModbusAddress() { return conf("modbus_address").toInt(); }
    uint32_t getModbusBaudRate() { return conf("modbus_baud_rate").toInt(); }
    uint8_t getRxPin() { return conf("rs485_rx_pin").toInt(); }
    uint8_t getTxPin() { return conf("rs485_tx_pin").toInt(); }
    //uint8_t getDePin() { return conf("rs485_de_pin").toInt(); }
    //uint8_t getOneWirePin() { return conf("onewire_pin").toInt(); }
    bool getAutoDiscover() { return conf("auto_discover").toInt() == 1; }
    
    // Reset min/max values
    void resetMinMaxValues();
    //void updateSensorInConfig(Sensor* sensor);
    // Remove:
// void saveSensorConfig();
// void loadSensorConfig();
// bool addSensorToConfig(...);
// bool removeSensorFromConfig(...);
// bool updateSensorInConfig(...);
// void updateSensorInConfig(Sensor* sensor);

    // Add:
    void savePointsConfig();
    void loadPointsConfig();
    bool updatePointInConfig(uint8_t address, const String& name, int16_t lowAlarm, int16_t highAlarm,
                            const String& ds18b20RomString = "", int pt1000ChipSelect = -1);
    
    void saveAlarmsConfig();
    void loadAlarmsConfig();

    CSVConfigManager& getCSVManager() { return csvManager; }

    uint16_t getAcknowledgedDelayCritical() { return conf("ack_delay_critical").toInt(); }
    uint16_t getAcknowledgedDelayHigh() { return conf("ack_delay_high").toInt(); }
    uint16_t getAcknowledgedDelayMedium() { return conf("ack_delay_medium").toInt(); }
    uint16_t getAcknowledgedDelayLow() { return conf("ack_delay_low").toInt(); }
    };

// Initialize static member
//ConfigManager* ConfigManager::instance = nullptr;

#endif // CONFIG_MANAGER_H


================================================================================
File: IndicatorInterface.h
Size: 6.05 kB
================================================================================

#ifndef INDICATOR_INTERFACE_H
#define INDICATOR_INTERFACE_H

#include <Arduino.h>
#include <Wire.h>
#include <map>
#include <string>
#include "PCF8575.h"
#include <U8g2lib.h>
#include <vector>
#include "LoggerManager.h"

class IndicatorInterface {
public:
    struct BlinkingPort {
        std::string portName;
        unsigned long onTime;
        unsigned long offTime;
        unsigned long lastToggleTime;
        bool currentState;
        bool isActive;
    };
    // Constructor
    IndicatorInterface(TwoWire& i2cBus, uint8_t pcf_i2cAddress, int intPin = -1);
    
    // Destructor
    ~IndicatorInterface();
    
    // Initialization
    bool begin();
    void update();
    
    // Configuration setters
    void setDirection(uint16_t directionMask);          // 0 = input, 1 = output
    void setMode(uint16_t modeMask);                    // 0 = normal, 1 = inverted
    void setPortNames(const std::map<std::string, uint8_t>& portNames);
    void setPortName(const std::string& name, uint8_t portNumber);
    
    // Port control methods
    bool writePort(const std::string& portName, bool state);
    bool writePort(uint8_t portNumber, bool state);
    void writePorts(uint16_t portMask);                 // Write only to outputs
    void setAllOutputs(bool state);
    void setAllOutputsHigh();
    void setAllOutputsLow();
    
    void setPortInverted(const std::string& portName, bool inverted);
    void setPortInverted(uint8_t portNumber, bool inverted);

    
    // Port reading methods
    uint16_t getCurrentState();
    bool readPort(const std::string& portName);
    bool readPort(uint8_t portNumber);
    
    // Utility methods
    bool isOutput(uint8_t portNumber);
    bool isInput(uint8_t portNumber);
    bool isInverted(uint8_t portNumber);
    uint8_t getPortNumber(const std::string& portName);
    std::string getPortName(uint8_t portNumber);
    
    // Interrupt handling
    void handleInterrupt();
    void setInterruptCallback(void (*callback)(uint16_t currentState, uint16_t changedPins));
    
    // Debug methods
    void printPortStates();
    void printConfiguration();

    // OLED control methods
    void setOledSleepDelay(long sleepDelay);        // -1 = never sleep
    void setOledMode(int lines);                    // 1-5 lines
    void printText(String buffer[], int bufferSize);
    void setOLEDblink(int timeOn, int timeOff, bool blinkOn = true);
    void setOLEDOff();
    void setOLEDOn();
    void updateOLED();                              // Call this in loop for scrolling/blinking

    // Add these to the public section:
    void pushLine(String newLine);                      // Push new line, shift others down
    void displayOK();                                   // Display huge "OK"
    void displayCross();                                // Display huge cross in circle
    void blinkOK(int blinkDelay);                       // Blink between OK and previous text
    void blinkCross(int blinkDelay);                    // Blink between cross and previous text
    void stopBlinking();                                // Stop any blinking and restore text

    void startBlinking(const std::string& portName, unsigned long onTime, unsigned long offTime);
    void stopBlinking(const std::string& portName);
    void updateBlinking();
    bool isBlinking(const std::string& portName);


private:



    std::vector<BlinkingPort> _blinkingPorts;

    // Hardware configuration
    TwoWire* _i2cBus;
    uint8_t _pcf_i2cAddress;
    uint8_t oled_i2cAddress;
    int _intPin;
    PCF8575 _pcf8575;
    
    // Port configuration
    uint16_t _directionMask;    // 0 = input, 1 = output
    uint16_t _modeMask;         // 0 = normal, 1 = inverted
    std::map<std::string, uint8_t> _portNames;
    std::map<uint8_t, std::string> _portNumbers;
    
    // State tracking
    uint16_t _currentState;
    uint16_t _lastState;
    unsigned long _lastReadTime;
    unsigned long _pollInterval;
    
    // Interrupt handling
    volatile bool _interruptFlag;
    bool _useInterrupts;
    void (*_interruptCallback)(uint16_t currentState, uint16_t changedPins);
    
    // Internal methods
    void _updateState();
    void _clearInterrupt();
    uint16_t _readPCF();
    void _writePCF(uint16_t state);
    bool _applyModeLogic(uint8_t portNumber, bool state);
    bool _reverseModeLogic(uint8_t portNumber, bool state);
    void _configureInterruptPin();
    
    // Static interrupt handler
    static IndicatorInterface* _instance;
    static void IRAM_ATTR _staticInterruptHandler();
    static U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2;

    // OLED configuration
    long _oledSleepDelay;
    int _oledLines;
    String _textBuffer[5];                          // Max 5 lines
    int _textBufferSize;
    bool _oledOn;
    bool _oledBlink;
    int _blinkTimeOn;
    int _blinkTimeOff;
    unsigned long _lastBlinkTime;
    bool _blinkState;
    unsigned long _lastActivityTime;
    bool _oledSleeping;
    
    // Scrolling variables
    int _scrollOffset[5];                           // Scroll offset for each line
    unsigned long _lastScrollTime;
    int _scrollDelay;
    int _charWidth;
    int _lineHeight;
    int _maxCharsPerLine;
    
    // Internal OLED methods
    void _initOLED();
    void _updateOLEDDisplay();
    void _handleOLEDSleep();
    void _handleOLEDBlink();
    void _handleScrolling();
    void _drawTextLine(int lineIndex, int yPos);
    void _calculateDisplayParams();
    void _wakeOLED();
    //void _fixSH1106Offset();
    // Add these to the private section:
    String _savedTextBuffer[5];                         // Backup of text before OK/Cross
    int _savedTextBufferSize;
    int _savedOledLines;
    bool _isBlinkingOK;
    bool _isBlinkingCross;
    int _blinkDelayTime;
    unsigned long _lastBlinkToggle;
    bool _blinkShowSpecial;                             // true = show OK/Cross, false = show text

    // Internal methods
    void _saveCurrentText();
    void _restoreCurrentText();
    void _handleSpecialBlink();

};

#endif


================================================================================
File: LoggerManager.h
Size: 7 kB
================================================================================

#ifndef LOGGERMANAGER_H
#define LOGGERMANAGER_H

#include <Arduino.h>
#include "FS.h"
#include "SD.h"
//#include "TemperatureController.h"
#include "TimeManager.h"
#include <vector>
#include "LoggerManager.h"

// Add forward declaration instead
class TemperatureController;  // Forward declaration
class MeasurementPoint;

class LoggerManager {
private:
    static LoggerManager* _instance;
    TemperatureController* _controller;
    TimeManager* _timeManager;
    fs::FS* _fs;
    
    unsigned long _logFrequency;     // Logging frequency in milliseconds
    unsigned long _lastLogTime;     // Last time data was logged
    String _currentLogFile;         // Current log file name
    bool _headerWritten;            // Flag to track if header is written
    
    // Configuration
    bool _enabled;
    String _logDirectory;
    bool _dailyFiles;               // Create new file each day
    String _lastLogDate;            // Track date for daily file creation
    
    // Private methods
    String _generateLogFileName();
    String _generateCSVHeader();
    bool _writeHeader();
    bool _writeDataRow();
    String _escapeCSVField(const String& field);
    bool _ensureDirectoryExists();
    String _getCurrentDateString();
    String _getCurrentTimeString();
    

    bool _recoverFromExistingFiles();
    String _findLatestFileForDate(const String& dateStr);
    int _extractSequenceNumber(const String& filename);
    String _readHeaderFromFile(const String& filename);
    std::vector<String> _getFilesForDate(const String& dateStr);
    int _findHighestSequenceForDate(const String& dateStr);

    // Header change detection
    String _lastGeneratedHeader;
    bool _headerChanged;
    int _fileSequenceNumber;
    
    // New private methods
    bool _hasHeaderChanged();
    String _generateLogFileNameWithSequence();
    void _incrementSequenceNumber();

    // Event logging
    bool _eventLoggingEnabled;
    String _eventLogDirectory;
    String _currentEventLogFile;
    String _lastEventLogDate;
    
    // Event logging methods
    String _generateEventLogFileName();
    bool _writeEventHeader();
    bool _writeEventRow(const String& timestamp, const String& source, 
                       const String& description, const String& priority);
    bool _ensureEventLogExists();

    // Alarm state logging
    bool _alarmStateLoggingEnabled;
    String _alarmStateLogDirectory;
    String _currentAlarmStateLogFile;
    String _lastAlarmStateLogDate;
    
    // Alarm state logging methods
    String _generateAlarmStateLogFileName();
    bool _writeAlarmStateHeader();
    bool _ensureAlarmStateLogExists();
    bool _writeAlarmStateRow(const String& timestamp, int pointNumber, const String& pointName,
        const String& alarmType, const String& alarmPriority,
        const String& previousState, const String& newState,
        int16_t currentTemp, int16_t threshold);

    
    bool _isSDCardAvailable();

    
public:
    LoggerManager(TemperatureController& controller, TimeManager& timeManager, fs::FS& filesystem);
    ~LoggerManager();

    static LoggerManager* getInstance() { return _instance; }
    
    // Add these static convenience methods
    static bool info(const String& source, const String& description) {
        return _instance ? _instance->logInfo(source, description) : false;
    }
    
    static bool warning(const String& source, const String& description) {
        return _instance ? _instance->logWarning(source, description) : false;
    }
    
    static bool error(const String& source, const String& description) {
        return _instance ? _instance->logError(source, description) : false;
    }
    
    static bool critical(const String& source, const String& description) {
        return _instance ? _instance->logCritical(source, description) : false;
    }
    
    // Initialization
    bool init(); 
    bool begin();
    
    // Configuration methods
    void setLogFrequency(unsigned long frequencyMs);
    unsigned long getLogFrequency() const;
    void setEnabled(bool enabled);
    bool isEnabled() const;
    void setDailyFiles(bool enabled);
    bool isDailyFiles() const;
    void setLogDirectory(const String& directory);
    String getLogDirectory() const;
    
    // Logging methods
    void update();                  // Call this in main loop
    bool logDataNow();             // Force immediate logging
    bool createNewLogFile();       // Create new log file
    
    // File management
    String getCurrentLogFile() const;
    bool closeCurrentFile();
    std::vector<String> getLogFiles();
    bool deleteLogFile(const String& filename);
    
    // Statistics
    unsigned long getLastLogTime() const;
    size_t getLogFileSize() const;
    
    // Error handling
    String getLastError() const;

    void forceNewFile();
    int getCurrentSequenceNumber() const;
    void resetSequenceNumber();

        // Event logging configuration
        void setEventLoggingEnabled(bool enabled);
        bool isEventLoggingEnabled() const;
        void setEventLogDirectory(const String& directory);
        String getEventLogDirectory() const;
        
        // Event logging methods
        bool logEvent(const String& source, const String& description, const String& priority = "INFO");
        bool logInfo(const String& source, const String& description);
        bool logWarning(const String& source, const String& description);
        bool logError(const String& source, const String& description);
        bool logCritical(const String& source, const String& description);
        
        // Event log management
        String getCurrentEventLogFile() const;
        std::vector<String> getEventLogFiles();
        bool deleteEventLogFile(const String& filename);


    // Alarm state logging configuration
    void setAlarmStateLoggingEnabled(bool enabled);
    bool isAlarmStateLoggingEnabled() const;
    void setAlarmStateLogDirectory(const String& directory);
    String getAlarmStateLogDirectory() const;
    
    // Static method for alarm state logging
    static bool logAlarmStateChange(int pointNumber, const String& pointName, 
                                   const String& alarmType, const String& alarmPriority,
                                   const String& previousState, const String& newState,
                                   int16_t currentTemp, int16_t threshold);
    
    // Instance method for alarm state logging
    bool logAlarmState(int pointNumber, const String& pointName, 
                      const String& alarmType, const String& alarmPriority,
                      const String& previousState, const String& newState,
                      int16_t currentTemp, int16_t threshold);
    
    // Alarm state log management
    String getCurrentAlarmStateLogFile() const;
    std::vector<String> getAlarmStateLogFiles();
    bool deleteAlarmStateLogFile(const String& filename);
    
private:
    String _lastError;
};

#endif // LOGGERMANAGER_H


================================================================================
File: MeasurementPoint.h
Size: 1.98 kB
================================================================================

#ifndef MEASUREMENT_POINT_H
#define MEASUREMENT_POINT_H

#include <Arduino.h>
#include "Sensor.h"
#include "LoggerManager.h"



class MeasurementPoint {
public:
    // Constructor
    MeasurementPoint() : address(0), name(""), currentTemp(0), minTemp(32767), maxTemp(-32768),
    lowAlarmThreshold(-10), highAlarmThreshold(50), alarmStatus(0), errorStatus(0), boundSensor(nullptr) {}
    MeasurementPoint(uint8_t address, const String& name);

    // Destructor
    ~MeasurementPoint();

    // Getters
    uint8_t getAddress() const;
    String getName() const;
    int16_t getCurrentTemp() const;
    int16_t getMinTemp() const;
    int16_t getMaxTemp() const;
    int16_t getLowAlarmThreshold() const;
    int16_t getHighAlarmThreshold() const;
    uint8_t getAlarmStatus() const;
    uint8_t getErrorStatus() const;

    // Setters
    void setName(const String& newName);
    void setLowAlarmThreshold(int16_t threshold);
    void setHighAlarmThreshold(int16_t threshold);

    // Sensor binding (optional)
    void bindSensor(Sensor* sensor);
    void unbindSensor();
    Sensor* getBoundSensor() const;

    // Operations
    void update();              // Should be called to refresh temperature and status
    void resetMinMaxTemp();     // Resets min/max to current
    // void setOneWireBus(uint8_t bus);
    // uint8_t getOneWireBus();

private:
    uint8_t address;
    String name;
    // uint8_t oneWireBus;

    int16_t currentTemp;        // Latest temperature (Â°C x1)
    int16_t minTemp;            // Minimum recorded temperature
    int16_t maxTemp;            // Maximum recorded temperature
    int16_t lowAlarmThreshold;  // Alarm threshold low
    int16_t highAlarmThreshold; // Alarm threshold high
    uint8_t alarmStatus;        // Alarm status bits
    uint8_t errorStatus;        // Error status bits

    Sensor* boundSensor;        // Pointer to bound sensor, or nullptr

    void updateAlarmStatus();
};


#endif // TEMPERATURE_CONTROLLER_H


================================================================================
File: RegisterMap.h
Size: 4.01 kB
================================================================================

#ifndef REGISTER_MAP_H
#define REGISTER_MAP_H

#include <stdint.h>
#include "MeasurementPoint.h"

class RegisterMap {
private:
    // Device Information Registers (0-99)
    uint16_t deviceId;
    uint16_t firmwareVersion;
    uint16_t numActiveDS18B20;
    uint16_t numActivePT1000;
    uint16_t deviceStatus[7]; // Registers 4-10

    // Temperature Data Registers (100-599)
    int16_t currentTemps[60];    // 100-159
    int16_t minTemps[60];        // 200-259
    int16_t maxTemps[60];        // 300-359
    uint16_t alarmStatus[60];    // 400-459
    uint16_t errorStatus[60];    // 500-559

    // Configuration Registers (600-799)
    int16_t lowAlarmThresholds[60];  // 600-659
    int16_t highAlarmThresholds[60]; // 700-759

    // Helpers
    bool isValidAddress(uint16_t address);
    bool isReadOnlyRegister(uint16_t address);

public:
    RegisterMap();

    // Register read/write
    uint16_t readHoldingRegister(uint16_t address);
    bool writeHoldingRegister(uint16_t address, uint16_t value);

    // Update register map from measurement point data
    void updateFromMeasurementPoint(const MeasurementPoint& point);

    // Apply config (thresholds) to and from measurement points
    void applyConfigToMeasurementPoint(MeasurementPoint& point);
    void applyConfigFromMeasurementPoint(const MeasurementPoint& point);

    // Utility methods for device info
    void incrementActiveDS18B20() { numActiveDS18B20++; }
    void decrementActiveDS18B20() { if (numActiveDS18B20 > 0) numActiveDS18B20--; }
    void incrementActivePT1000() { numActivePT1000++; }
    void decrementActivePT1000() { if (numActivePT1000 > 0) numActivePT1000--; }

    uint16_t getDeviceId() const { return deviceId; }
    uint16_t getFirmwareVersion() const { return firmwareVersion; }
    uint16_t getNumActiveDS18B20() const { return numActiveDS18B20; }
    uint16_t getNumActivePT1000() const { return numActivePT1000; }

    // Register address constants (as in your original code)
    static const uint16_t DEVICE_ID_REG = 0;
    static const uint16_t FIRMWARE_VERSION_REG = 1;
    static const uint16_t NUM_DS18B20_REG = 2;
    static const uint16_t NUM_PT1000_REG = 3;
    static const uint16_t DEVICE_STATUS_START_REG = 4;
    static const uint16_t DEVICE_STATUS_END_REG = 10;
    static const uint16_t CURRENT_TEMP_DS18B20_START_REG = 100;
    static const uint16_t CURRENT_TEMP_DS18B20_END_REG = 149;
    static const uint16_t CURRENT_TEMP_PT1000_START_REG = 150;
    static const uint16_t CURRENT_TEMP_PT1000_END_REG = 159;
    static const uint16_t MIN_TEMP_DS18B20_START_REG = 200;
    static const uint16_t MIN_TEMP_DS18B20_END_REG = 249;
    static const uint16_t MIN_TEMP_PT1000_START_REG = 250;
    static const uint16_t MIN_TEMP_PT1000_END_REG = 259;
    static const uint16_t MAX_TEMP_DS18B20_START_REG = 300;
    static const uint16_t MAX_TEMP_DS18B20_END_REG = 349;
    static const uint16_t MAX_TEMP_PT1000_START_REG = 350;
    static const uint16_t MAX_TEMP_PT1000_END_REG = 359;
    static const uint16_t ALARM_STATUS_DS18B20_START_REG = 400;
    static const uint16_t ALARM_STATUS_DS18B20_END_REG = 449;
    static const uint16_t ALARM_STATUS_PT1000_START_REG = 450;
    static const uint16_t ALARM_STATUS_PT1000_END_REG = 459;
    static const uint16_t ERROR_STATUS_DS18B20_START_REG = 500;
    static const uint16_t ERROR_STATUS_DS18B20_END_REG = 549;
    static const uint16_t ERROR_STATUS_PT1000_START_REG = 550;
    static const uint16_t ERROR_STATUS_PT1000_END_REG = 559;
    static const uint16_t LOW_ALARM_DS18B20_START_REG = 600;
    static const uint16_t LOW_ALARM_DS18B20_END_REG = 649;
    static const uint16_t LOW_ALARM_PT1000_START_REG = 650;
    static const uint16_t LOW_ALARM_PT1000_END_REG = 659;
    static const uint16_t HIGH_ALARM_DS18B20_START_REG = 700;
    static const uint16_t HIGH_ALARM_DS18B20_END_REG = 749;
    static const uint16_t HIGH_ALARM_PT1000_START_REG = 750;
    static const uint16_t HIGH_ALARM_PT1000_END_REG = 759;
};

#endif // REGISTER_MAP_H


================================================================================
File: Sensor.h
Size: 2.61 kB
================================================================================

#ifndef SENSOR_H
#define SENSOR_H

#include <Arduino.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <Adafruit_MAX31865.h>

// Define your sensor types
enum class SensorType {
    DS18B20,
    PT1000
};

// Error and alarm bitmasks
constexpr uint8_t ERROR_COMMUNICATION = 0x01;
constexpr uint8_t ERROR_OUT_OF_RANGE  = 0x02;
constexpr uint8_t ERROR_DISCONNECTED  = 0x04;

constexpr uint8_t ALARM_LOW_TEMP  = 0x01;
constexpr uint8_t ALARM_HIGH_TEMP = 0x02;

class Sensor {
public:
    Sensor(SensorType type, uint8_t address, const String& name);
    ~Sensor();

    // Setup methods for each sensor type
    void setupDS18B20(uint8_t pin, const uint8_t* deviceAddress);
    void setupPT1000(uint8_t csPin, uint8_t maxAddress);

    // Initialize hardware
    bool initialize();

    // Read temperature from the sensor, update internal state
    bool readTemperature();

    // Accessors
    SensorType getType() const;
    uint8_t getAddress() const;
    String getName() const;
    void setName(const String& newName);

    int16_t getCurrentTemp() const;
    int16_t getMinTemp() const;
    int16_t getMaxTemp() const;
    int16_t getLowAlarmThreshold() const;
    int16_t getHighAlarmThreshold() const;
    uint8_t getAlarmStatus() const;
    uint8_t getErrorStatus() const;
    uint8_t getPT1000ChipSelectPin() const;
    

    void setAddress(uint8_t newAddress);
    void setLowAlarmThreshold(int16_t threshold);
    void setHighAlarmThreshold(int16_t threshold);

    // DS18B20 ROM address accessor
    const uint8_t* getDS18B20Address() const;

    // Reset min/max values
    void resetMinMaxTemp();

    // Update alarm status (call after reading temperature or changing thresholds)
    void updateAlarmStatus();
    String getDS18B20RomString() const;        // ROM as hex string
    void getDS18B20RomArray(uint8_t out[8]) const; // ROM as array
    uint8_t getOneWirePin() {return connection.ds18b20.oneWirePin;}

private:
    uint8_t address;
    String name;
    SensorType type;

    int16_t currentTemp;
    int16_t minTemp;
    int16_t maxTemp;
    int16_t lowAlarmThreshold;
    int16_t highAlarmThreshold;
    uint8_t alarmStatus;
    uint8_t errorStatus;

    // Hardware-specific members
    OneWire* oneWire;
    DallasTemperature* dallasTemperature;
    Adafruit_MAX31865* max31865;

    // Connection details
    union {
        struct {
            uint8_t oneWirePin;
            uint8_t oneWireAddress[8];
        } ds18b20;
        struct {
            uint8_t csPin;
            uint8_t maxAddress;
        } pt1000;
    } connection;
};

#endif // SENSOR_H


================================================================================
File: SettingsCSVManager.h
Size: 826 B
================================================================================

#pragma once

#include <Arduino.h>
#include "ConfigAssist.h"

class SettingsCSVManager {
public:
    SettingsCSVManager(ConfigAssist& config);
    
    // CSV export/import for settings
    String exportSettingsToCSV();
    bool importSettingsFromCSV(const String& csvData);
    
    // Validation
    bool validateSettingsCSV(const String& csvData);
    String getLastError() const { return _lastError; }

private:
    ConfigAssist& _config;
    String _lastError;
    
    // Helper methods
    String _escapeCSVField(const String& field);
    String _unescapeCSVField(const String& field);
    bool _parseCSVLine(const String& line);
    
    // Add these helper methods for acknowledged delays
    void _exportAcknowledgedDelays(String& csv);
    bool _importAcknowledgedDelays(const String& key, const String& value);
};


================================================================================
File: TempModbusServer.h
Size: 1.03 kB
================================================================================

#ifndef TEMP_MODBUS_SERVER_H
#define TEMP_MODBUS_SERVER_H

#include <Arduino.h>
#include "ModbusServerRTU.h"
#include "RegisterMap.h"
#include "LoggerManager.h"

class TempModbusServer {
private:
    ModbusServerRTU* mbServer;
    RegisterMap& registerMap;
    uint8_t serverID;
    HardwareSerial& serial;
    int rxPin;
    int txPin;
    int dePin;
    int baudRate;
    
    // Worker functions for different Modbus function codes
    static ModbusMessage readHoldingRegistersWorker(ModbusMessage request);
    static ModbusMessage writeHoldingRegisterWorker(ModbusMessage request);
    static ModbusMessage writeMultipleRegistersWorker(ModbusMessage request);
    
    // Pointer to the RegisterMap instance for static worker functions
    static RegisterMap* registerMapPtr;

public:
    TempModbusServer(RegisterMap& regMap, uint8_t id, HardwareSerial& serialPort, 
                 int rx, int tx, int de, int baud = 9600);
    ~TempModbusServer();
    
    bool begin();
    void stop();
};



#endif // TEMP_MODBUS_SERVER_H


================================================================================
File: TemperatureController.h
Size: 7.97 kB
================================================================================

#pragma once

#include <Arduino.h>
#include <vector>
#include "Sensor.h"
#include "MeasurementPoint.h"
#include "RegisterMap.h"
#include "IndicatorInterface.h"
#include "Alarm.h"
#include <OneWire.h>
#include <DallasTemperature.h>
#include <ArduinoJson.h>
#include <algorithm>

class TemperatureController {
public:
    TemperatureController(uint8_t oneWirePin[4], uint8_t csPin[4], IndicatorInterface& indicator);

    

    ~TemperatureController();
    
    bool begin();
    
    // Measurement point management
    MeasurementPoint* getMeasurementPoint(uint8_t address);
    MeasurementPoint* getDS18B20Point(uint8_t idx);
    MeasurementPoint* getPT1000Point(uint8_t idx);
    
    // Sensor management
    bool addSensor(Sensor* sensor);
    bool removeSensorByRom(const String& romString);
    Sensor* findSensorByRom(const String& romString);
    Sensor* findSensorByChipSelect(uint8_t csPin);
    int getSensorCount() const { return sensors.size(); }
    Sensor* getSensorByIndex(int idx);
    
    // Sensor binding
    bool bindSensorToPointByRom(const String& romString, uint8_t pointAddress);
    bool bindSensorToPointByChipSelect(uint8_t csPin, uint8_t pointAddress);
    bool unbindSensorFromPoint(uint8_t pointAddress);
    Sensor* getBoundSensor(uint8_t pointAddress);
    bool unbindSensorFromPointBySensor(Sensor* sensor);
    
    // Main update and measurement
    void update();
    void readAllPoints();
    void updateRegisterMap();
    void applyConfigFromRegisterMap();
    void applyConfigToRegisterMap();
    
    // Sensor discovery
    bool discoverDS18B20Sensors();
    bool discoverPTSensors();
    
    // JSON output
    String getSensorsJson();
    String getPointsJson();
    String getSystemStatusJson();
    
    // Utility functions
    void resetMinMaxValues();
    RegisterMap& getRegisterMap() { return registerMap; }
    
    // Configuration
    void setDeviceId(uint16_t id);
    uint16_t getDeviceId() const;
    void setFirmwareVersion(uint16_t version);
    uint16_t getFirmwareVersion() const;
    void setMeasurementPeriod(uint16_t seconds);
    uint16_t getMeasurementPeriod() const;
    void setOneWireBusPin(uint8_t pin, size_t idx);
    uint8_t getOneWirePin(size_t bus);
    
    // Statistics
    int getDS18B20Count() const;
    int getPT1000Count() const;
    void updateAllSensors();
    int getSensorBus(Sensor* sensor);
    
    // New Alarm Management
    void updateAlarms();
    String getAlarmsJson();
    void handleAlarmDisplay();
    void handleAlarmOutputs();

    std::vector<Alarm*> getActiveAlarms() const;
    void createAlarm(AlarmType type, MeasurementPoint* source, AlarmPriority priority);
    Alarm* getHighestPriorityAlarm() const;
    void acknowledgeHighestPriorityAlarm();
    void acknowledgeAllAlarms();
    void clearResolvedAlarms();
    void clearConfiguredAlarms();

    // Alarm management (similar to sensor management)
    bool addAlarm(AlarmType type, uint8_t pointAddress, AlarmPriority priority);
    bool removeAlarm(const String& configKey);
    bool updateAlarm(const String& configKey, AlarmPriority priority, bool enabled);
    Alarm* findAlarm(const String& configKey);
    Alarm* getAlarmByIndex(int idx);
    int getAlarmCount() const { return _configuredAlarms.size(); }
    std::vector<Alarm*> getConfiguredAlarms() const { return _configuredAlarms; }

    // JSON output (similar to getSensorsJson, getPointsJson)
    //String getAlarmsJson();

    // Alarm handling scenarios (placeholders)
    void handleCriticalAlarms();
    void handleHighPriorityAlarms();
    void handleMediumPriorityAlarms();
    void handleLowPriorityAlarms();

    bool bindSensorToPointByBusNumber(uint8_t busNumber, uint8_t pointAddress);


    // Setters for acknowledged delays
    void setAcknowledgedDelayCritical(unsigned long delay);
    void setAcknowledgedDelayHigh(unsigned long delay);
    void setAcknowledgedDelayMedium(unsigned long delay);
    void setAcknowledgedDelayLow(unsigned long delay);
    
    // Getters for acknowledged delays
    unsigned long getAcknowledgedDelayCritical() const;
    unsigned long getAcknowledgedDelayHigh() const;
    unsigned long getAcknowledgedDelayMedium() const;
    unsigned long getAcknowledgedDelayLow() const;
    
    // Method to apply delays to existing alarms
    void applyAcknowledgedDelaysToAlarms();

    // int getAlarmCount(AlarmPriority priority) const;
    // int getAlarmCount(AlarmStage stage) const;
    int getAlarmCount(AlarmPriority priority, AlarmStage stage) const;
    // Add these method declarations to TemperatureController.h
    int getAlarmCount(AlarmPriority priority, const String& comparison = "==") const;
    int getAlarmCount(AlarmStage stage, const String& comparison = "==") const;
    int getAlarmCount(AlarmPriority priority, AlarmStage stage, const String& priorityComparison = "==", const String& stageComparison = "==") const;






private:
    // Hardware components
    IndicatorInterface& indicator;
    OneWire* oneWireBuses[4];
    DallasTemperature* dallasSensors[4];
    
    // Measurement points and sensors
    MeasurementPoint dsPoints[50];
    MeasurementPoint ptPoints[10];
    std::vector<Sensor*> sensors;
    
    // System configuration
    RegisterMap registerMap;
    uint16_t measurementPeriodSeconds;
    uint16_t deviceId;
    uint16_t firmwareVersion;
    unsigned long lastMeasurementTime;
    bool systemInitialized;
    uint8_t oneWireBusPin[4];
    uint8_t chipSelectPin[4];
    
    // Alarm system
    //std::vector<Alarm*> _alarms;
    std::vector<Alarm*> _configuredAlarms; 
    unsigned long _lastAlarmCheck;
    const unsigned long _alarmCheckInterval = 1000; // Check every second
    bool _lastButtonState;
    unsigned long _lastButtonPressTime;
    const unsigned long _buttonDebounceDelay = 200;
    
    // Display management
    Alarm* _currentDisplayedAlarm;
    unsigned long _okDisplayStartTime;
    bool _showingOK;
    
    // Internal methods
    bool isDS18B20Address(uint8_t address) const { return address < 50; }
    bool isPT1000Address(uint8_t address) const { return address >= 50 && address < 60; }
    
    // Alarm helper methods
    void _checkPointForAlarms(MeasurementPoint* point);
    bool _hasAlarmForPoint(MeasurementPoint* point, AlarmType type);
    void _checkButtonPress();
    void _updateNormalDisplay();
    void _showOKAndTurnOffOLED();

    unsigned long _acknowledgedDelayCritical;
    unsigned long _acknowledgedDelayHigh;
    unsigned long _acknowledgedDelayMedium;
    unsigned long _acknowledgedDelayLow;

    bool _relay1State = false;
    bool _relay2State = false;
    bool _redLedState = false;
    bool _yellowLedState = false;
    bool _blueLedState = false;

    bool _comparePriority(AlarmPriority alarmPriority, AlarmPriority targetPriority, const String& comparison) const;
    bool _compareStage(AlarmStage alarmStage, AlarmStage targetStage, const String& comparison) const;

    // Blinking control for low priority alarms
    bool _lowPriorityBlinkState = false;
    unsigned long _lastLowPriorityBlinkTime = 0;
    const unsigned long _blinkOnTime = 2000;   // 2 seconds on
    const unsigned long _blinkOffTime = 30000; // 30 seconds off
    void _handleLowPriorityBlinking();


    // Display management for alarms
    std::vector<Alarm*> _activeAlarmsQueue;
    std::vector<Alarm*> _acknowledgedAlarmsQueue;
    int _currentActiveAlarmIndex;
    int _currentAcknowledgedAlarmIndex;
    unsigned long _lastAlarmDisplayTime;
    unsigned long _acknowledgedAlarmDisplayDelay;
    bool _displayingActiveAlarm;
    
    // Helper methods for alarm display
    void _updateAlarmQueues();
    void _displayNextActiveAlarm();
    void _displayNextAcknowledgedAlarm();
    void _handleAlarmDisplayRotation();

    String _getPriorityString(AlarmPriority priority) const; 


    String _getAlarmTypeString(AlarmType type) const;
    
    //String _getPriorityString(AlarmPriority priority) const;

    
};


================================================================================
File: TimeManager.h
Size: 2.95 kB
================================================================================

#pragma once

#include <Arduino.h>
#include <WiFi.h>
#include <Wire.h>
#include <RTClib.h>
#include <NTPClient.h>
#include <WiFiUdp.h>
#include <ArduinoJson.h>

class TimeManager {
public:
    // Constructor
    TimeManager(int sdaPin = 21, int sclPin = 22);
    
    // Destructor
    ~TimeManager();
    
    // Initialization
    bool begin();
    bool init();
    
    // Time setting methods
    bool setTimeFromNTP(const char* ntpServer = "pool.ntp.org");
    bool setTime(int year, int month, int day, int hour, int minute, int second);
    bool setTime(DateTime dateTime);
    bool setTimeFromUnix(uint32_t unixTime);
    bool setTimeFromCompileTime();
    
    // Time getting methods
    DateTime getCurrentTime();
    String getFormattedTime(const String& format = "YYYY-MM-DD hh:mm:ss");
    String getTimeString();
    String getDateString();
    uint32_t getUnixTime();
    
    // Timezone management
    void setTimezone(int offsetHours, int offsetMinutes = 0);
    void setTimezoneOffset(long offsetSeconds);
    int getTimezoneHours();
    int getTimezoneMinutes();
    long getTimezoneOffset();
    
    // WiFi and NTP configuration
    void setNTPServer(const String& server);
    void setNTPUpdateInterval(unsigned long intervalMs);
    String getNTPServer();
    
    // Update methods (call in loop)
    void update();
    bool syncWithNTP();
    bool isNTPSyncEnabled();
    void enableNTPSync(bool enable);
    
    // Status methods
    bool isRTCConnected();
    bool isTimeSet();
    bool hasLostPower();
    unsigned long getLastNTPSync();
    float getTemperature(); // From DS3231 built-in sensor
    
    // Alarm functionality
    bool setAlarm1(DateTime alarmTime, Ds3231Alarm1Mode mode = DS3231_A1_Hour);
    bool setAlarm2(DateTime alarmTime, Ds3231Alarm2Mode mode = DS3231_A2_Hour);
    bool clearAlarm1();
    bool clearAlarm2();
    bool isAlarm1Triggered();
    bool isAlarm2Triggered();
    
    // Square wave output
    void enableSquareWave(Ds3231SqwPinMode mode = DS3231_SquareWave1Hz);
    void disableSquareWave();
    
    // JSON output for web interface
    String getTimeJSON();
    String getStatusJSON();
    
    // Configuration save/load
    void saveConfig();
    void loadConfig();

private:
    // Hardware
    RTC_DS3231 _rtc;
    WiFiUDP _ntpUDP;
    NTPClient* _timeClient;
    
    // Configuration
    int _sdaPin;
    int _sclPin;
    long _timezoneOffset;  // Offset in seconds
    String _ntpServer;
    unsigned long _ntpUpdateInterval;
    bool _ntpSyncEnabled;
    
    // Status tracking
    bool _rtcConnected;
    bool _timeSet;
    unsigned long _lastNTPSync;
    unsigned long _lastNTPAttempt;
    
    // Internal methods
    void _initializeNTP();
    bool _isWiFiConnected();
    void _updateFromNTP();
    DateTime _applyTimezone(DateTime utcTime);
    DateTime _removeTimezone(DateTime localTime);
    String _formatDateTime(DateTime dt, const String& format);
};


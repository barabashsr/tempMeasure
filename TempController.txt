Project Overview
===============

Project Statistics:
Total Files: 40
Total Size: 545.15 KB

File Types:
  .cpp: 13 files
  .h: 12 files
  .html: 7 files
  no extension: 3 files
  .md: 2 files
  .yaml: 1 files
  .py: 1 files
  .ini: 1 files

Detected Technologies:
  - Python

Folder Structure (Tree)
=====================
Legend: ‚úì = Included in output, ‚úó = Excluded from output

‚îú‚îÄ‚îÄ .DS_Store (6.00 KB) ‚úó
‚îú‚îÄ‚îÄ .gitignore (94 B) ‚úì
‚îú‚îÄ‚îÄ LICENSE (11.09 KB) ‚úì
‚îú‚îÄ‚îÄ README.md (4.27 KB) ‚úì
‚îú‚îÄ‚îÄ alarm_handle.md (2.12 KB) ‚úì
‚îú‚îÄ‚îÄ config.yaml (1.51 KB) ‚úì
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ alarm-history.html (22.26 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ alarms.html (21.69 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ dashboard.html (28.41 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ download-logs.html (16.94 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ event-logs.html (22.84 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ points.html (20.55 KB) ‚úì
‚îÇ   ‚îî‚îÄ‚îÄ sensors.html (15.97 KB) ‚úì
‚îú‚îÄ‚îÄ download_fs.py (10.69 KB) ‚úì
‚îú‚îÄ‚îÄ include/
‚îÇ   ‚îú‚îÄ‚îÄ Alarm.h (4.31 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ CSVConfigManager.h (1.60 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ ConfigManager.h (4.10 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ IndicatorInterface.h (5.91 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ LoggerManager.h (9.46 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ MeasurementPoint.h (1.93 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ RegisterMap.h (3.92 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ Sensor.h (2.54 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ SettingsCSVManager.h (826 B) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ TempModbusServer.h (1.01 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ TemperatureController.h (7.79 KB) ‚úì
‚îÇ   ‚îî‚îÄ‚îÄ TimeManager.h (2.88 KB) ‚úì
‚îú‚îÄ‚îÄ platformio.ini (1.02 KB) ‚úì
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ Alarm.cpp (24.84 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ CSVConfigManager.cpp (12.31 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ ConfigManager.cpp (65.98 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ IndicatorInterface.cpp (29.11 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ LoggerManager.cpp (63.11 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ MeasurementPoint.cpp (3.92 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ RegisterMap.cpp (5.20 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ Sensor.cpp (7.31 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ SettingsCSVManager.cpp (6.01 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ TempModbusServer.cpp (14.62 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ TemperatureController.cpp (64.00 KB) ‚úì
‚îÇ   ‚îú‚îÄ‚îÄ TimeManager.cpp (11.16 KB) ‚úì
‚îÇ   ‚îî‚îÄ‚îÄ main.cpp (5.88 KB) ‚úì

==============

File Name: .gitignore
Size: 94 B
Code:
.pio
.vscode/.browse.c_cpp.db*
.vscode/c_cpp_properties.json
.vscode/launch.json
.vscode/ipch

-------- [ Separator ] ------

File Name: LICENSE
Size: 11.09 KB
Code:
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

-------- [ Separator ] ------

File Name: README.md
Size: 4.27 KB
Code:
# Industrial ESP32 Temperature Monitoring System

## Device Description

This industrial-grade ESP32-based device is designed for precision temperature monitoring in industrial environments. It collects temperature data from multiple sensors, including DS18B20 digital temperature sensors and PT1000/PT100 RTD sensors connected via MAX31865 modules. The system supports up to 50 DS18B20 sensors and 10 PT1000/PT100 sensors, with expansion capability for future sensor types.

### Key Features:
- Multi-sensor support (DS18B20 and PT1000/PT100)
- MODBUS-RTU communication over RS485
- Web interface for configuration and monitoring
- Configurable alarm thresholds for each sensor
- Error detection and reporting
- Temperature range: -40¬∞C to +200¬∞C (integer Celsius values)
- Industrial-grade reliability and accuracy

### Communication Interfaces:
- RS485 MODBUS-RTU for industrial system integration
- Web interface for configuration and monitoring
- Temperature data accessible via both interfaces

## MODBUS Register Map

### Device Information Registers (0-99)
| Register | Description | Data Type | Access |
|----------|-------------|-----------|--------|
| 0 | Device ID/Model Number | UINT16 | R |
| 1 | Firmware Version | UINT16 | R |
| 2 | Number of Active DS18B20 Sensors | UINT16 | R |
| 3 | Number of Active PT1000/PT100 Sensors | UINT16 | R |
| 4-10 | Device Status and Diagnostics | UINT16 | R |
| 11-99 | Reserved for Future Use | - | - |

### Temperature Data Registers (100-299)
| Register Range | Description | Data Type | Access |
|----------------|-------------|-----------|--------|
| 100-149 | Current Temperature Readings - DS18B20 (addresses 0-49) | INT16 | R |
| 150-159 | Current Temperature Readings - PT1000/PT100 (addresses 50-59) | INT16 | R |
| 160-199 | Reserved for Future Sensor Types | - | - |
| 200-249 | Min Temperature Readings - DS18B20 (addresses 0-49) | INT16 | R |
| 250-259 | Min Temperature Readings - PT1000/PT100 (addresses 50-59) | INT16 | R |
| 260-299 | Reserved for Future Sensor Types | - | - |

### Max Temperature Registers (300-399)
| Register Range | Description | Data Type | Access |
|----------------|-------------|-----------|--------|
| 300-349 | Max Temperature Readings - DS18B20 (addresses 0-49) | INT16 | R |
| 350-359 | Max Temperature Readings - PT1000/PT100 (addresses 50-59) | INT16 | R |
| 360-399 | Reserved for Future Sensor Types | - | - |

### Alarm and Error Registers (400-599)
| Register Range | Description | Data Type | Access |
|----------------|-------------|-----------|--------|
| 400-449 | Alarm Status - DS18B20 (addresses 0-49) | UINT16 | R |
| 450-459 | Alarm Status - PT1000/PT100 (addresses 50-59) | UINT16 | R |
| 460-499 | Reserved for Future Sensor Types | - | - |
| 500-549 | Error Status - DS18B20 (addresses 0-49) | UINT16 | R |
| 550-559 | Error Status - PT1000/PT100 (addresses 50-59) | UINT16 | R |
| 560-599 | Reserved for Future Sensor Types | - | - |

### Configuration Registers (600-799)
| Register Range | Description | Data Type | Access |
|----------------|-------------|-----------|--------|
| 600-649 | Low Temperature Alarm Thresholds - DS18B20 (addresses 0-49) | INT16 | R/W |
| 650-659 | Low Temperature Alarm Thresholds - PT1000/PT100 (addresses 50-59) | INT16 | R/W |
| 660-699 | Reserved for Future Sensor Types | - | - |
| 700-749 | High Temperature Alarm Thresholds - DS18B20 (addresses 0-49) | INT16 | R/W |
| 750-759 | High Temperature Alarm Thresholds - PT1000/PT100 (addresses 50-59) | INT16 | R/W |
| 760-799 | Reserved for Future Sensor Types | - | - |

## Alarm Status Bit Definitions
Each alarm status register contains the following bit flags:
- Bit 0: Low Temperature Alarm
- Bit 1: High Temperature Alarm
- Bits 2-15: Reserved for future alarm types

## Error Status Bit Definitions
Each error status register contains the following bit flags:
- Bit 0: Sensor Communication Error
- Bit 1: Sensor Out of Range
- Bit 2: Sensor Disconnected
- Bits 3-15: Reserved for future error types

## Notes
- All temperature values are in integer degrees Celsius
- Valid temperature range: -40¬∞C to +200¬∞C
- MODBUS function code 0x03 (Read Holding Registers) for reading values
- MODBUS function code 0x06 (Write Single Register) for writing configuration
- MODBUS function code 0x10 (Write Multiple Registers) for writing multiple configuration values

-------- [ Separator ] ------

File Name: alarm_handle.md
Size: 2.12 KB
Code:
Ok. Now it works excellent. Thank you.
The next step - we need to handle alarms properly. In the device the "loud" indication is with relays 1 and 2 - there is a siren  on the relay 1 and a blinking beacon on relay2, green, yellow, blue and red LEDs are on teh device, so we need to use two kinds of indication separately and there are different scenarios for different alarm priorities as well. Lets solve the loud notification first. I think we should put all the alarms into a sort of stack sorted by priority and a stage within each priority. If there are any alarms within the group, we handle the loud notification this way (for example):
1. Critical unacknowledged - both siren and beacon are ON constantly
2. High priority unacknowledged, or Critical not cleared but acknowledged - beacon is ON constantly
3. All Critical alarms are resolved, but High priority not cleared but acknowledged, or Medium priority is either active or acknowleged - beacon is getting on from time to time (for 10 secconds once in a few minutes - this also should be a setting)

So actually we need a scenario for each alarm priority with standard options
ACTIVE - siren action, beacon action
ACKNOWLEDGED - siren action, beacon action


Also we should display and handle acknolagement of uresolved alarms in a different way. We should display the highest priority alarm in ACTIVE status. After acknowlegment if there are any unacknowleged alarms we should show next unacknowledged alarm etc. When all the alarms in active status got acknowledged we need to show them in a cycle with some delay (10 secconds - it should be a setting). We should also turn on one of the LEDs - Red for CRITICAL, Yellow for HIGH and Blue for MEDIUM priority.

So, all the alarms should be sorted by priority and status and the loud notification should act according the groups which are not empty. We should start to display alerms in a cycle when all the alarms got acknowledged. We should have settings for the scenario of each alarm priority. We should be able to move acknowledged alarm to active by timer.

This all should be done by TemperatureController class or a new class if it is advisable.

-------- [ Separator ] ------

File Name: config.yaml
Size: 1.51 KB
Code:
Wifi settings:
  - st_ssid:
      label: WiFi SSID
      default: ''
  - st_pass:
      label: WiFi Password
      default: ''
  - host_name:
      label: Device Hostname
      default: 'temp-monitor-{mac}'

Device settings:
  - device_id:
      label: Device ID
      type: number
      min: 1
      max: 9999
      default: 1000
  - firmware_version:
      label: Firmware Version
      default: '1.0'
      readonly: true
  - measurement_period:
      label: Measurement Period (seconds)
      type: number
      min: 1
      max: 3600
      default: 10

Modbus settings:
  - modbus_enabled:
      label: Enable Modbus RTU
      checked: true
  - modbus_address:
      label: Modbus Device Address
      type: number
      min: 1
      max: 247
      default: 1
  - modbus_baud_rate:
      label: Baud Rate
      options: '4800', '9600', '19200', '38400', '57600', '115200'
      default: '9600'
  - rs485_rx_pin:
      label: RS485 RX Pin
      type: number
      min: 0
      max: 39
      default: 22
  - rs485_tx_pin:
      label: RS485 TX Pin
      type: number
      min: 0
      max: 39
      default: 23
  - rs485_de_pin:
      label: RS485 DE/RE Pin
      type: number
      min: 0
      max: 39
      default: 18

Sensor settings:
  - onewire_pin:
      label: OneWire Bus Pin
      type: number
      min: 0
      max: 39
      default: 4
  - auto_discover:
      label: Auto-discover sensors on startup
      checked: true
  - reset_min_max:
      label: Reset Min/Max Values
      type: button
      attribs: onClick="resetMinMax()"

-------- [ Separator ] ------

File Name: data/alarm-history.html
Size: 22.26 KB
Code:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temperature Controller - Alarm History</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        nav {
            margin-bottom: 20px;
            padding: 10px;
            background: #007bff;
            border-radius: 5px;
        }
        nav a {
            color: white;
            text-decoration: none;
            margin-right: 15px;
            padding: 5px 10px;
            border-radius: 3px;
        }
        nav a:hover {
            background: rgba(255,255,255,0.2);
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .controls button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-success {
            background-color: #28a745;
            color: white;
        }
        .btn-warning {
            background-color: #ffc107;
            color: black;
        }
        .btn-danger {
            background-color: #dc3545;
            color: white;
        }
        .btn:hover {
            opacity: 0.8;
        }
        .filter-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .filter-group label {
            font-weight: bold;
            margin-right: 5px;
        }
        .filter-group select, .filter-group input {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        .date-range {
            display: flex;
            gap: 10px;
            align-items: center;
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        th:hover {
            background-color: #e9ecef;
        }
        th.sortable::after {
            content: " ‚Üï";
            color: #999;
            font-size: 12px;
        }
        th.sort-asc::after {
            content: " ‚Üë";
            color: #007bff;
            font-weight: bold;
        }
        th.sort-desc::after {
            content: " ‚Üì";
            color: #007bff;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .priority-critical {
            background-color: #f8d7da;
            color: #721c24;
            font-weight: bold;
        }
        .priority-high {
            background-color: #ffeaa7;
            color: #856404;
            font-weight: bold;
        }
        .priority-medium {
            background-color: #d1ecf1;
            color: #0c5460;
        }
        .priority-low {
            background-color: #d4edda;
            color: #155724;
        }
        .alarm-type {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .type-high-temp {
            background-color: #ff6b6b;
            color: white;
        }
        .type-low-temp {
            background-color: #4ecdc4;
            color: white;
        }
        .type-sensor-error {
            background-color: #ffe66d;
            color: black;
        }
        .type-sensor-disconnected {
            background-color: #a8e6cf;
            color: black;
        }
        .no-history {
            text-align: center;
            padding: 40px;
            color: #6c757d;
            font-style: italic;
        }
        .timestamp {
            font-size: 12px;
            color: #6c757d;
        }
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
        }
        .pagination button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            border-radius: 4px;
        }
        .pagination button:hover {
            background: #f8f9fa;
        }
        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .pagination .current-page {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        .state-transition {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .state-arrow {
            color: #6c757d;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="/dashboard.html">Home</a>
            <a href="/sensors.html">Sensors</a>
            <a href="/points.html">Points</a>
            <a href="/alarms.html">Alarms</a>
            <a href="/alarm-history.html">Alarm History</a>
            <a href="/event-logs.html">Event Logs</a>
            <a href="/config">Configuration</a>
        </nav>

        <h1>Alarm History</h1>

        <!-- Controls -->
        <div class="controls">
            <div class="date-range">
                <label>Date Range:</label>
                <input type="date" id="startDate">
                <span>to</span>
                <input type="date" id="endDate">
                <button class="btn btn-primary" onclick="loadHistory()">üîç Load History</button>
            </div>
            
            <button class="btn btn-success" onclick="exportHistory()">üì• Export CSV</button>
            
            <div class="filter-group">
                <label>Filter by Point:</label>
                <select id="pointFilter" onchange="filterTable()">
                    <option value="">All Points</option>
                </select>
            </div>

            <div class="filter-group">
                <label>Filter by Type:</label>
                <select id="typeFilter" onchange="filterTable()">
                    <option value="">All Types</option>
                    <option value="HIGH_TEMP">High Temperature</option>
                    <option value="LOW_TEMP">Low Temperature</option>
                    <option value="SENSOR_ERROR">Sensor Error</option>
                    <option value="DISCONNECTED">Sensor Disconnected</option>
                </select>
            </div>

            <div class="filter-group">
                <label>Filter by Priority:</label>
                <select id="priorityFilter" onchange="filterTable()">
                    <option value="">All Priorities</option>
                    <option value="CRITICAL">Critical</option>
                    <option value="HIGH">High</option>
                    <option value="MEDIUM">Medium</option>
                    <option value="LOW">Low</option>
                </select>
            </div>

            <div class="filter-group">
                <label>Filter by State:</label>
                <select id="stateFilter" onchange="filterTable()">
                    <option value="">All States</option>
                    <option value="NEW">New</option>
                    <option value="ACTIVE">Active</option>
                    <option value="ACKNOWLEDGED">Acknowledged</option>
                    <option value="CLEARED">Cleared</option>
                    <option value="RESOLVED">Resolved</option>
                </select>
            </div>
        </div>

        <!-- History Table -->
        <table id="historyTable">
            <thead>
                <tr>
                    <th class="sortable" onclick="sortTable(0)">Timestamp</th>
                    <th class="sortable" onclick="sortTable(1)">Point</th>
                    <th class="sortable" onclick="sortTable(2)">Point Name</th>
                    <th class="sortable" onclick="sortTable(3)">Type</th>
                    <th class="sortable" onclick="sortTable(4)">Priority</th>
                    <th class="sortable" onclick="sortTable(5)">State Change</th>
                    <th class="sortable" onclick="sortTable(6)">Temperature</th>
                    <th class="sortable" onclick="sortTable(7)">Threshold</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td colspan="8" class="no-history">Select a date range and click "Load History" to view alarm events</td>
                </tr>
            </tbody>
        </table>

        <!-- Pagination -->
        <div class="pagination" id="pagination" style="display: none;">
            <button id="prevPage" onclick="changePage(-1)">‚Üê Previous</button>
            <span id="pageInfo">Page 1 of 1</span>
            <button id="nextPage" onclick="changePage(1)">Next ‚Üí</button>
        </div>
    </div>

    <script>
        let historyData = [];
        let filteredData = [];
        let sortColumn = -1;
        let sortDirection = 'asc';
        let currentPage = 1;
        const itemsPerPage = 100;

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            // Set default date range (last 7 days)
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 7);
            
            document.getElementById('endDate').value = endDate.toISOString().split('T')[0];
            document.getElementById('startDate').value = startDate.toISOString().split('T')[0];
            
            loadPointsForFilter();
        });

        // Load points for filter dropdown
        async function loadPointsForFilter() {
            try {
                const response = await fetch('/api/points');
                const data = await response.json();
                const pointFilter = document.getElementById('pointFilter');
                
                // Clear existing options except "All Points"
                pointFilter.innerHTML = '<option value="">All Points</option>';
                
                if (data.points) {
                    data.points.forEach(point => {
                        const option = document.createElement('option');
                        option.value = point.address;
                        option.textContent = `${point.address} - ${point.name || 'Unnamed'}`;
                        pointFilter.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Error loading points:', error);
            }
        }

        // Load alarm history from API
        async function loadHistory() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            if (!startDate || !endDate) {
                alert('Please select both start and end dates');
                return;
            }
            
            if (new Date(startDate) > new Date(endDate)) {
                alert('Start date must be before end date');
                return;
            }

            try {
                const response = await fetch(`/api/alarm-history?start=${startDate}&end=${endDate}`);
                const data = await response.json();
                
                if (data.success) {
                    historyData = data.history || [];
                    currentPage = 1;
                    displayHistory();
                } else {
                    throw new Error(data.error || 'Failed to load history');
                }
            } catch (error) {
                console.error('Error loading alarm history:', error);
                document.querySelector('#historyTable tbody').innerHTML = 
                    '<tr><td colspan="8" class="no-history">Error loading alarm history: ' + error.message + '</td></tr>';
            }
        }

        // Display history in table
        function displayHistory() {
            const tbody = document.querySelector('#historyTable tbody');
            
            if (historyData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" class="no-history">No alarm history found for the selected date range</td></tr>';
                document.getElementById('pagination').style.display = 'none';
                return;
            }

            // Apply filters
            filterTable();
        }

        // Create table row for history entry
        function createHistoryRow(entry) {
            const row = document.createElement('tr');
            
            row.innerHTML = `
                <td><span class="timestamp">${entry.timestamp}</span></td>
                <td>${entry.pointNumber}</td>
                <td>${entry.pointName || 'Unknown'}</td>
                <td><span class="alarm-type ${getTypeClass(entry.alarmType)}">${entry.alarmType}</span></td>
                <td><span class="priority-${entry.alarmPriority.toLowerCase()}">${entry.alarmPriority}</span></td>
                <td>
                    <div class="state-transition">
                        <span class="status-${entry.previousState.toLowerCase()}">${entry.previousState}</span>
                        <span class="state-arrow">‚Üí</span>
                        <span class="status-${entry.newState.toLowerCase()}">${entry.newState}</span>
                    </div>
                </td>
                <td>${entry.currentTemperature !== undefined ? entry.currentTemperature + '¬∞C' : 'N/A'}</td>
                <td>${entry.threshold !== undefined ? entry.threshold + '¬∞C' : 'N/A'}</td>
            `;
            
            // Set data attributes for filtering
            row.dataset.point = entry.pointNumber;
            row.dataset.type = entry.alarmType;
            row.dataset.priority = entry.alarmPriority;
            row.dataset.previousState = entry.previousState;
            row.dataset.newState = entry.newState;
            
            return row;
        }

        // Helper functions
        function getTypeClass(type) {
            const typeClasses = {
                'HIGH_TEMP': 'type-high-temp',
                'LOW_TEMP': 'type-low-temp',
                'SENSOR_ERROR': 'type-sensor-error',
                'DISCONNECTED': 'type-sensor-disconnected'
            };
            return typeClasses[type] || '';
        }

        // Filter table function
        function filterTable() {
            const pointFilter = document.getElementById('pointFilter').value;
            const typeFilter = document.getElementById('typeFilter').value;
            const priorityFilter = document.getElementById('priorityFilter').value;
            const stateFilter = document.getElementById('stateFilter').value;
            
            filteredData = historyData.filter(entry => {
                const pointMatch = !pointFilter || entry.pointNumber == pointFilter;
                const typeMatch = !typeFilter || entry.alarmType === typeFilter;
                const priorityMatch = !priorityFilter || entry.alarmPriority === priorityFilter;
                const stateMatch = !stateFilter || entry.previousState === stateFilter || entry.newState === stateFilter;
                
                return pointMatch && typeMatch && priorityMatch && stateMatch;
            });
            
            currentPage = 1;
            displayFilteredData();
        }

        // Display filtered and paginated data
        function displayFilteredData() {
            const tbody = document.querySelector('#historyTable tbody');
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageData = filteredData.slice(startIndex, endIndex);
            
            if (pageData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" class="no-history">No alarm history matches the current filters</td></tr>';
                document.getElementById('pagination').style.display = 'none';
                return;
            }
            
            tbody.innerHTML = '';
            pageData.forEach(entry => {
                tbody.appendChild(createHistoryRow(entry));
            });
            
            // Update pagination
            const totalPages = Math.ceil(filteredData.length / itemsPerPage);
            if (totalPages > 1) {
                document.getElementById('pagination').style.display = 'flex';
                document.getElementById('pageInfo').textContent = `Page ${currentPage} of ${totalPages} (${filteredData.length} entries)`;
                document.getElementById('prevPage').disabled = currentPage === 1;
                document.getElementById('nextPage').disabled = currentPage === totalPages;
            } else {
                document.getElementById('pagination').style.display = 'none';
            }
        }

        // Pagination functions
        function changePage(direction) {
            const totalPages = Math.ceil(filteredData.length / itemsPerPage);
            const newPage = currentPage + direction;
            
            if (newPage >= 1 && newPage <= totalPages) {
                currentPage = newPage;
                displayFilteredData();
            }
        }

        // Table sorting function
        function sortTable(columnIndex) {
            const table = document.getElementById('historyTable');
            
            // Update sort direction
            if (sortColumn === columnIndex) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortDirection = 'asc';
                sortColumn = columnIndex;
            }

            // Clear previous sort indicators
            table.querySelectorAll('th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });

            // Add current sort indicator
            const currentHeader = table.querySelector(`th:nth-child(${columnIndex + 1})`);
            currentHeader.classList.add(sortDirection === 'asc' ? 'sort-asc' : 'sort-desc');

            // Sort the filtered data
            filteredData.sort((a, b) => {
                let aValue, bValue;
                
                switch (columnIndex) {
                    case 0: // Timestamp
                        aValue = new Date(a.timestamp);
                        bValue = new Date(b.timestamp);
                        break;
                    case 1: // Point
                        aValue = a.pointNumber;
                        bValue = b.pointNumber;
                        break;
                    case 2: // Point Name
                        aValue = a.pointName || '';
                        bValue = b.pointName || '';
                        break;
                    case 3: // Type
                        aValue = a.alarmType;
                        bValue = b.alarmType;
                        break;
                    case 4: // Priority
                        aValue = a.alarmPriority;
                        bValue = b.alarmPriority;
                        break;
                    case 5: // State Change
                        aValue = a.newState;
                        bValue = b.newState;
                        break;
                    case 6: // Temperature
                        aValue = a.currentTemperature || 0;
                        bValue = b.currentTemperature || 0;
                        break;
                    case 7: // Threshold
                        aValue = a.threshold || 0;
                        bValue = b.threshold || 0;
                        break;
                    default:
                        return 0;
                }
                
                let comparison = 0;
                if (typeof aValue === 'number' && typeof bValue === 'number') {
                    comparison = aValue - bValue;
                } else if (aValue instanceof Date && bValue instanceof Date) {
                    comparison = aValue - bValue;
                } else {
                    comparison = String(aValue).localeCompare(String(bValue));
                }
                
                return sortDirection === 'asc' ? comparison : -comparison;
            });
            
            displayFilteredData();
        }

        // Export history to CSV
        async function exportHistory() {
            if (filteredData.length === 0) {
                alert('No data to export. Please load history first.');
                return;
            }
            
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            try {
                const response = await fetch(`/api/alarm-history/export?start=${startDate}&end=${endDate}`, {
                    method: 'GET'
                });
                
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `alarm_history_${startDate}_to_${endDate}.csv`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                } else {
                    throw new Error('Export failed');
                }
            } catch (error) {
                console.error('Error exporting history:', error);
                alert('Failed to export history: ' + error.message);
            }
        }
    </script>
</body>
</html>
-------- [ Separator ] ------

File Name: data/alarms.html
Size: 21.69 KB
Code:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temperature Controller - Alarms</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        nav {
            margin-bottom: 20px;
            padding: 10px;
            background: #007bff;
            border-radius: 5px;
        }
        nav a {
            color: white;
            text-decoration: none;
            margin-right: 15px;
            padding: 5px 10px;
            border-radius: 3px;
        }
        nav a:hover {
            background: rgba(255,255,255,0.2);
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .controls button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-success {
            background-color: #28a745;
            color: white;
        }
        .btn-warning {
            background-color: #ffc107;
            color: black;
        }
        .btn-danger {
            background-color: #dc3545;
            color: white;
        }
        .btn:hover {
            opacity: 0.8;
        }
        .filter-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .filter-group label {
            font-weight: bold;
            margin-right: 5px;
        }
        .filter-group select {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        th:hover {
            background-color: #e9ecef;
        }
        th.sortable::after {
            content: " ‚Üï";
            color: #999;
            font-size: 12px;
        }
        th.sort-asc::after {
            content: " ‚Üë";
            color: #007bff;
            font-weight: bold;
        }
        th.sort-desc::after {
            content: " ‚Üì";
            color: #007bff;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .status-new {
            color: #6f42c1;
            font-weight: bold;
        }
        .status-active {
            color: #dc3545;
            font-weight: bold;
        }
        .status-acknowledged {
            color: #fd7e14;
            font-weight: bold;
        }
        .status-cleared {
            color: #20c997;
            font-weight: bold;
        }
        .status-resolved {
            color: #6c757d;
        }
        .priority-critical {
            background-color: #f8d7da;
            color: #721c24;
            font-weight: bold;
        }
        .priority-high {
            background-color: #ffeaa7;
            color: #856404;
            font-weight: bold;
        }
        .priority-medium {
            background-color: #d1ecf1;
            color: #0c5460;
        }
        .priority-low {
            background-color: #d4edda;
            color: #155724;
        }
        .alarm-type {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .type-high-temp {
            background-color: #ff6b6b;
            color: white;
        }
        .type-low-temp {
            background-color: #4ecdc4;
            color: white;
        }
        .type-sensor-error {
            background-color: #ffe66d;
            color: black;
        }
        .type-sensor-disconnected {
            background-color: #a8e6cf;
            color: black;
        }
        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .stat-card {
            flex: 1;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            color: white;
            font-weight: bold;
        }
        .stat-critical {
            background-color: #dc3545;
        }
        .stat-high {
            background-color: #fd7e14;
        }
        .stat-medium {
            background-color: #ffc107;
            color: black;
        }
        .stat-low {
            background-color: #28a745;
        }
        .no-alarms {
            text-align: center;
            padding: 40px;
            color: #6c757d;
            font-style: italic;
        }
        .timestamp {
            font-size: 12px;
            color: #6c757d;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="/dashboard.html">Home</a>
            <a href="/sensors.html">Sensors</a>
            <a href="/points.html">Points</a>
            <a href="/alarms.html">Alarms</a>
            <a href="/alarm-history.html">Alarm History</a>
            <a href="/event-logs.html">Event Logs</a>
            <a href="/config">Configuration</a>
        </nav>

        <h1>Alarm Management</h1>

        <!-- Statistics -->
        <div class="stats">
            <div class="stat-card stat-critical">
                <div id="criticalCount">0</div>
                <div>Critical</div>
            </div>
            <div class="stat-card stat-high">
                <div id="highCount">0</div>
                <div>High</div>
            </div>
            <div class="stat-card stat-medium">
                <div id="mediumCount">0</div>
                <div>Medium</div>
            </div>
            <div class="stat-card stat-low">
                <div id="lowCount">0</div>
                <div>Low</div>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <button class="btn btn-primary" onclick="refreshAlarms()">üîÑ Refresh</button>
            <button class="btn btn-success" onclick="acknowledgeAllActive()">‚úì Acknowledge All Active</button>
            <button class="btn btn-warning" onclick="clearResolved()">üóë Clear Resolved</button>
            
            <div class="filter-group">
                <label>Filter by Status:</label>
                <select id="statusFilter" onchange="filterTable()">
                    <option value="">All Statuses</option>
                    <option value="NEW">New</option>
                    <option value="CLEARED">Cleared</option>
                    <option value="RESOLVED">Resolved</option>
                    <option value="ACKNOWLEDGED">Acknowledged</option>
                    <option value="ACTIVE">Active</option>


                </select>
            </div>

            <div class="filter-group">
                <label>Filter by Priority:</label>
                <select id="priorityFilter" onchange="filterTable()">
                    <option value="">All Priorities</option>
                    <option value="3">Critical</option>
                    <option value="2">High</option>
                    <option value="1">Medium</option>
                    <option value="0">Low</option>
                </select>
            </div>

            <div class="filter-group">
                <label>Filter by Type:</label>
                <select id="typeFilter" onchange="filterTable()">
                    <option value="">All Types</option>
                    <option value="0">High Temperature</option>
                    <option value="1">Low Temperature</option>
                    <option value="2">Sensor Error</option>
                    <option value="3">Sensor Disconnected</option>
                </select>
            </div>
        </div>

        <!-- Alarms Table -->
        <table id="alarmsTable">
            <thead>
                <tr>
                    <th class="sortable" onclick="sortTable(0)">Point</th>
                    <th class="sortable" onclick="sortTable(1)">Point Name</th>
                    <th class="sortable" onclick="sortTable(2)">Type</th>
                    <th class="sortable" onclick="sortTable(3)">Priority</th>
                    <th class="sortable" onclick="sortTable(4)">Status</th>
                    <th class="sortable" onclick="sortTable(5)">Current Temp</th>
                    <th class="sortable" onclick="sortTable(6)">Threshold</th>
                    <th class="sortable" onclick="sortTable(7)">Created</th>
                    <th class="sortable" onclick="sortTable(8)">Acknowledged</th>
                    <th class="sortable" onclick="sortTable(9)">Time Left</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td colspan="11" class="no-alarms">Loading alarms...</td>
                </tr>
            </tbody>
        </table>
    </div>

    <script>
        const UPDATE_INTERVAL = 5000;
        let alarmsData = [];
        let sortColumn = -1;
        let sortDirection = 'asc';

        // Load alarms on page load
        document.addEventListener('DOMContentLoaded', function() {
            refreshAlarms();
            setInterval(refreshAlarms, UPDATE_INTERVAL); // Auto-refresh every 30 seconds
        });

        // Load alarms from API
        async function refreshAlarms() {
            try {
                const response = await fetch('/api/alarms');
                const data = await response.json();
                alarmsData = data.alarms || [];
                updateStatistics();
                displayAlarms();
            } catch (error) {
                console.error('Error loading alarms:', error);
                document.querySelector('#alarmsTable tbody').innerHTML = 
                    '<tr><td colspan="10" class="no-alarms">Error loading alarms</td></tr>';
            }
        }

        // Update statistics
        function updateStatistics() {
            const stats = {
                critical: 0,
                high: 0,
                medium: 0,
                low: 0
            };

            alarmsData.forEach(alarm => {
                if (alarm.enabled && (alarm.stage === 1 || alarm.stage === 2)) { // ACTIVE or ACKNOWLEDGED
                    switch (alarm.priority) {
                        case 3: stats.critical++; break;
                        case 2: stats.high++; break;
                        case 1: stats.medium++; break;
                        case 0: stats.low++; break;
                    }
                }
            });

            document.getElementById('criticalCount').textContent = stats.critical;
            document.getElementById('highCount').textContent = stats.high;
            document.getElementById('mediumCount').textContent = stats.medium;
            document.getElementById('lowCount').textContent = stats.low;
        }

        // Display alarms in table
        
        function displayAlarms() {
            const tbody = document.querySelector('#alarmsTable tbody');
            
            if (alarmsData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="11" class="no-alarms">No alarms configured</td></tr>';
                return;
            }

            tbody.innerHTML = alarmsData.map(alarm => createAlarmRow(alarm)).join('');
            filterTable(); // Apply current filters
        }


        // Create table row for alarm
        function createAlarmRow(alarm) {
            const createdDate = new Date(alarm.timestamp).toLocaleString();
            const acknowledgedDate = alarm.acknowledgedTime ? 
                new Date(alarm.acknowledgedTime).toLocaleString() : '-';
            
            // Format time left for acknowledged alarms
            const timeLeft = formatTimeLeft(alarm.acknowledgedTimeLeft, alarm.stage);

            return `
                <tr data-priority="${alarm.priority}" data-status="${getStageText(alarm.stage)}" data-type="${alarm.type}">
                    <td>${alarm.pointAddress}</td>
                    <td>${alarm.pointName || 'Unknown'}</td>
                    <td><span class="alarm-type ${getTypeClass(alarm.type)}">${getTypeText(alarm.type)}</span></td>
                    <td><span class="priority-${getPriorityClass(alarm.priority)}">${getPriorityText(alarm.priority)}</span></td>
                    <td><span class="status-${getStageText(alarm.stage).toLowerCase()}">${getStageText(alarm.stage)}</span></td>
                    <td>${alarm.currentTemp !== undefined ? alarm.currentTemp + '¬∞C' : 'N/A'}</td>
                    <td>${alarm.threshold !== undefined ? alarm.threshold + '¬∞C' : 'N/A'}</td>
                    <td><span class="timestamp">${createdDate}</span></td>
                    <td><span class="timestamp">${acknowledgedDate}</span></td>
                    <td><span class="timestamp">${timeLeft}</span></td>
                    <td>
                        ${alarm.isActive && !alarm.isAcknowledged ? 
                            `<button class="btn btn-warning" onclick="acknowledgeAlarm('${alarm.configKey}')">Acknowledge</button>` : 
                            ''}
                        ${`<button class="btn btn-danger" onclick="deleteAlarm('${alarm.configKey}')">Delete</button>`}
                    </td>
                </tr>
            `;
        }


        // Helper functions
        function getTypeText(type) {
            const types = ['High Temp', 'Low Temp', 'Sensor Error', 'Disconnected'];
            return types[type] || 'Unknown';
        }

        function getTypeClass(type) {
            const classes = ['type-high-temp', 'type-low-temp', 'type-sensor-error', 'type-sensor-disconnected'];
            return classes[type] || '';
        }

        function getPriorityText(priority) {
            const priorities = ['Low', 'Medium', 'High', 'Critical'];
            return priorities[priority] || 'Unknown';
        }

        function getPriorityClass(priority) {
            const classes = ['low', 'medium', 'high', 'critical'];
            return classes[priority] || 'low';
        }

        function getStageText(stage) {
            const stages = ['NEW', 'CLEARED', 'RESOLVED', 'ACKNOWLEDGED', 'ACTIVE'];
            return stages[stage] || 'UNKNOWN';
        }

        // Table sorting function
        function sortTable(columnIndex) {
            const table = document.getElementById('alarmsTable');
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr')).filter(row => 
                !row.querySelector('.no-alarms'));

            // Update sort direction
            if (sortColumn === columnIndex) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortDirection = 'asc';
                sortColumn = columnIndex;
            }

            // Clear previous sort indicators
            table.querySelectorAll('th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });

            // Add current sort indicator
            const currentHeader = table.querySelector(`th:nth-child(${columnIndex + 1})`);
            currentHeader.classList.add(sortDirection === 'asc' ? 'sort-asc' : 'sort-desc');

            // Sort rows
            rows.sort((a, b) => {
                const aValue = a.cells[columnIndex].textContent.trim();
                const bValue = b.cells[columnIndex].textContent.trim();

                let comparison = 0;
                
                // Handle numeric columns
                if (columnIndex === 0 || columnIndex === 5 || columnIndex === 6) { // Point, Current Temp, Threshold
                    const aNum = parseFloat(aValue) || 0;
                    const bNum = parseFloat(bValue) || 0;
                    comparison = aNum - bNum;
                } else if (columnIndex === 3) { // Priority
                    const priorityOrder = { 'Critical': 3, 'High': 2, 'Medium': 1, 'Low': 0 };
                    comparison = (priorityOrder[aValue] || 0) - (priorityOrder[bValue] || 0);
                } else if (columnIndex === 7 || columnIndex === 8) { // Timestamps
                    const aDate = new Date(aValue);
                    const bDate = new Date(bValue);
                    comparison = aDate - bDate;
                } else {
                    // String comparison
                    comparison = aValue.localeCompare(bValue);
                }

                return sortDirection === 'asc' ? comparison : -comparison;
            });

            // Re-append sorted rows
            rows.forEach(row => tbody.appendChild(row));
        }

        // Filter table function
        function filterTable() {
            const statusFilter = document.getElementById('statusFilter').value;
            const priorityFilter = document.getElementById('priorityFilter').value;
            const typeFilter = document.getElementById('typeFilter').value;
            
            const rows = document.querySelectorAll('#alarmsTable tbody tr');
            
            rows.forEach(row => {
                if (row.querySelector('.no-alarms')) return;
                
                const status = row.dataset.status;
                const priority = row.dataset.priority;
                const type = row.dataset.type;
                
                const statusMatch = !statusFilter || status === statusFilter;
                const priorityMatch = !priorityFilter || priority === priorityFilter;
                const typeMatch = !typeFilter || type === typeFilter;
                
                row.style.display = (statusMatch && priorityMatch && typeMatch) ? '' : 'none';
            });
        }

        // Acknowledge alarm
        async function acknowledgeAlarm(configKey) {
            try {
                const response = await fetch('/api/alarms/acknowledge', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ configKey: configKey })
                });

                if (response.ok) {
                    refreshAlarms();
                } else {
                    alert('Error acknowledging alarm');
                }
            } catch (error) {
                console.error('Error acknowledging alarm:', error);
                alert('Error acknowledging alarm');
            }
        }

        // Acknowledge all active alarms
        async function acknowledgeAllActive() {
            if (!confirm('Acknowledge all active alarms?')) return;

            try {
                const response = await fetch('/api/alarms/acknowledge-all', {
                    method: 'POST'
                });

                if (response.ok) {
                    refreshAlarms();
                } else {
                    alert('Error acknowledging alarms');
                }
            } catch (error) {
                console.error('Error acknowledging alarms:', error);
                alert('Error acknowledging alarms');
            }
        }

        // Delete resolved alarm
        async function deleteAlarm(configKey) {
            if (!confirm('Delete this resolved alarm?')) return;

            try {
                const response = await fetch(`/api/alarms?configKey=${encodeURIComponent(configKey)}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    refreshAlarms();
                } else {
                    alert('Error deleting alarm');
                }
            } catch (error) {
                console.error('Error deleting alarm:', error);
                alert('Error deleting alarm');
            }
        }

        // Clear all resolved alarms
        async function clearResolved() {
            if (!confirm('Clear all resolved alarms?')) return;

            try {
                const response = await fetch('/api/alarms/clear-resolved', {
                    method: 'POST'
                });

                if (response.ok) {
                    refreshAlarms();
                } else {
                    alert('Error clearing resolved alarms');
                }
            } catch (error) {
                console.error('Error clearing resolved alarms:', error);
                alert('Error clearing resolved alarms');
            }
        }


        function formatTimeLeft(timeLeftMs, stage) {
            // Only show time left for acknowledged alarms
            if (stage !== 2 || !timeLeftMs || timeLeftMs <= 0) { // 2 = ACKNOWLEDGED
                return '-';
            }
            
            // Convert milliseconds to seconds
            const totalSeconds = Math.floor(timeLeftMs / 1000);
            
            // Calculate hours, minutes, and seconds
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            // Format as HH:MM:SS
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        
    </script>
</body>
</html>

-------- [ Separator ] ------

File Name: data/dashboard.html
Size: 28.41 KB
Code:
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Temperature Monitoring System</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

.status-ok {
            color: #388e3c;
            font-weight: bold;
        }
        .status-error, .status-alarm, .status-unbound {
            color: #d32f2f;
            font-weight: bold;
        }
        .status-bound {
            color: #388e3c;
            font-weight: bold;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 10;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 8% auto;
            padding: 24px;
            border: 1px solid #888;
            width: 100%;
            max-width: 400px;
            border-radius: 6px;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover,
        .close:focus {
            color: #d32f2f;
            text-decoration: none;
            cursor: pointer;
        }
        .form-group {
            margin-bottom: 18px;
        }
        .form-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .form-group input[type="text"],
        .form-group input[type="number"] {
            width: 95%;
            padding: 6px;
            font-size: 1em;
        }
        .form-actions {
            text-align: right;
        }
        .form-actions button {
            margin-left: 10px;
            padding: 5px 15px;
        }
        
        /* Use styles from index.html */
        body {
            font-family: Arial, sans-serif;
            background: #f7f7f7;
            margin: 0;
            padding: 0;
        }
        header {
            background: #3f51b5;
            color: #fff;
            padding: 1em 2em;
            text-align: center;
            font-size: 1.5em;
            letter-spacing: 2px;
        }
        nav {
            background: #263238;
            padding: 0.5em 2em;
        }
        nav a {
            color: #fff;
            text-decoration: none;
            margin-right: 2em;
            font-weight: bold;
            transition: color 0.2s;
        }
        nav a:hover {
            color: #ffeb3b;
        }
        main {
            max-width: 1200px;
            margin: 2em auto;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            padding: 2em;
        }
        h2 {
            margin-top: 1em;
            color: #3f51b5;
            font-size: 1.2em;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.25em;
        }
        .actions {
            margin-bottom: 1.5em;
        }
        button {
            background: #3f51b5;
            color: #fff;
            border: none;
            padding: 0.5em 1.2em;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            margin-right: 0.5em;
            transition: background 0.2s;
        }
        button:hover {
            background: #283593;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 2em;
        }
        th, td {
            padding: 0.6em 0.8em;
            border-bottom: 1px solid #eee;
            text-align: left;
        }
        th {
            background: #f0f4ff;
            color: #3f51b5;
        }
        tr:last-child td {
            border-bottom: none;
        }
        .status-bound {
            color: #388e3c;
            font-weight: bold;
        }
        .status-unbound {
            color: #b71c1c;
            font-weight: bold;
        }
        .rom, .chip-select {
            font-family: monospace;
            font-size: 0.98em;
            color: #333;
        }
        @media (max-width: 800px) {
            main { padding: 1em; }
            th, td { font-size: 0.95em; }
        }
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            margin-top: 0;
        }
        .navbar {
            background-color: #333;
            overflow: hidden;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        .navbar a {
            float: left;
            display: block;
            color: white;
            text-align: center;
            padding: 14px 16px;
            text-decoration: none;
        }
        .navbar a:hover {
            background-color: #ddd;
            color: black;
        }
        .dashboard {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        .card {
            flex: 1;
            min-width: 300px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            background-color: #fff;
        }
        .card h2 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #f5f5f5;
        }
        .status-label {
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>Temperature Monitoring System</header>
        <nav>
            <a href="/dashboard.html">Home</a>
            <a href="/sensors.html">Sensors</a>
            <a href="/points.html">Points</a>
            <a href="/alarms.html">Alarms</a>
            <a href="/alarm-history.html">Alarm History</a>
            <a href="/event-logs.html">Event Logs</a>
            <a href="/config">Configuration</a>
    
        </nav>
        <!-- CSV Import/Export Section -->
        <div class="csv-section" style="margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px;">
            <h3>Configuration Backup/Restore</h3>
            
            <!-- Export Button -->
            <button id="exportCsvBtn" class="btn btn-primary" style="margin-right: 10px;">
                üì• Export Configuration to CSV
            </button>
            
            <!-- Import Section -->
            <input type="file" id="csvFileInput" accept=".csv" style="display: none;">
            <button id="importCsvBtn" class="btn btn-secondary">
                üì§ Import Configuration from CSV
            </button>
            
            <div id="csvStatus" style="margin-top: 10px; font-weight: bold;"></div>
        </div>

        <!-- Settings CSV Import/Export Section -->
        <div class="settings-csv-section" style="margin: 20px 0; padding: 15px; border: 1px solid #ccc; border-radius: 5px; background-color: #f9f9f9;">
            <h3>Device Settings Backup/Restore</h3>
            
            <!-- Export Button -->
            <button id="exportSettingsBtn" class="btn btn-success" style="margin-right: 10px;">
                üì• Export Device Settings to CSV
            </button>
            
            <!-- Import Section -->
            <input type="file" id="settingsFileInput" accept=".csv" style="display: none;">
            <button id="importSettingsBtn" class="btn btn-warning">
                üì§ Import Device Settings from CSV
            </button>
            
            <div id="settingsStatus" style="margin-top: 10px; font-weight: bold;"></div>
            
            <div style="margin-top: 10px; font-size: 12px; color: #666;">
                <strong>Note:</strong> Device will restart automatically after importing settings to apply changes.
            </div>
        </div>


        
        <div class="dashboard">
            <div class="card">
                <h2>System Status</h2>
                <div id="system-status">
                    <p>Loading system status...</p>
                </div>
            </div>
            
            <div class="card">
                <h2>Sensor Overview</h2>
                <div id="sensor-overview">
                    <p>Loading sensor data...</p>
                </div>
            </div>
        </div>
    </div>


    <main>
    <h2>DS18B20 Points</h2>
    
        <table>
            <thead>
                <tr>
                    <th>Address</th>
                    <th>Name</th>
                    <th>Current Temp</th>
                    <th>Min Temp</th>
                    <th>Max Temp</th>
                    <th>Alarm Status</th>
                    <th>Error Status</th>

                </tr>
            </thead>
            <tbody id="dsPointsTbody">
                <tr><td colspan="11">Loading DS18B20 points...</td></tr>
            </tbody>
        </table>

        <h2>PT1000 Points</h2>
        <table>
            <thead>
                <tr>
                    <th>Address</th>
                    <th>Name</th>
                    <th>Current Temp</th>
                    <th>Min Temp</th>
                    <th>Max Temp</th>
                    <th>Alarm Status</th>
                    <th>Error Status</th>
                </tr>
            </thead>
            <tbody id="ptPointsTbody">
                <tr><td colspan="11">Loading PT1000 points...</td></tr>
            </tbody>
        </table>
    </main>

    <!-- Modal -->
    <div id="pointConfigModal" class="modal">
        <div class="modal-content">
            <span class="close" id="modalCloseBtn">&times;</span>
            <h2>Edit Point</h2>
            <form id="pointConfigForm">
                <input type="hidden" id="modalPointAddress">
                <div class="form-group">
                    <label for="modalPointName">Name</label>
                    <input type="text" id="modalPointName" required>
                </div>
                <div class="form-group">
                    <label for="modalLowAlarm">Low Alarm Threshold (¬∞C)</label>
                    <input type="number" id="modalLowAlarm" step="0.1" required>
                </div>
                <div class="form-group">
                    <label for="modalHighAlarm">High Alarm Threshold (¬∞C)</label>
                    <input type="number" id="modalHighAlarm" step="0.1" required>
                </div>
                <div class="form-actions">
                    <button type="submit" class="button">Save</button>
                    <button type="button" class="button" id="modalCancelBtn" style="background:#888;">Cancel</button>
                </div>
            </form>
        </div>
    </div>




    <script>

        // Auto-update interval (ms)
        const UPDATE_INTERVAL = 5000;
        // Fetch system status
        function fetchSystemStatus() {
            fetch('/api/status')
                .then(response => response.json())
                .then(data => {
                    displaySystemStatus(data);
                })
                .catch(error => {
                    console.error('Error fetching system status:', error);
                    document.getElementById('system-status').innerHTML = 
                        '<p>Error loading system status. Please try again.</p>';
                });
        }
        
        // Display system status
        function displaySystemStatus(data) {
            const container = document.getElementById('system-status');
            
            let html = '';
            html += `<div class="status-item"><span class="status-label">Device ID:</span> <span>${data.deviceId}</span></div>`;
            html += `<div class="status-item"><span class="status-label">Firmware Version:</span> <span>${(data.firmwareVersion >> 8)}.${data.firmwareVersion & 0xFF}</span></div>`;
            html += `<div class="status-item"><span class="status-label">Measurement Period:</span> <span>${data.measurementPeriod} seconds</span></div>`;
            html += `<div class="status-item"><span class="status-label">Uptime:</span> <span>${formatUptime(data.uptime)}</span></div>`;
            
            container.innerHTML = html;
        }
        
        // Format uptime in a human-readable way
        function formatUptime(seconds) {
            const days = Math.floor(seconds / 86400);
            seconds %= 86400;
            const hours = Math.floor(seconds / 3600);
            seconds %= 3600;
            const minutes = Math.floor(seconds / 60);
            seconds %= 60;
            
            let result = '';
            if (days > 0) result += `${days}d `;
            if (hours > 0 || days > 0) result += `${hours}h `;
            if (minutes > 0 || hours > 0 || days > 0) result += `${minutes}m `;
            result += `${seconds}s`;
            
            return result;
        }
        
        // Fetch sensor overview
        function fetchSensorOverview() {
            fetch('/api/sensors')
                .then(response => response.json())
                .then(data => {
                    displaySensorOverview(data);
                })
                .catch(error => {
                    console.error('Error fetching sensors:', error);
                    document.getElementById('sensor-overview').innerHTML = 
                        '<p>Error loading sensor data. Please try again.</p>';
                });
        }
        
        // Display sensor overview
        function displaySensorOverview(data) {
            const container = document.getElementById('sensor-overview');
            
            if (!data.sensors || data.sensors.length === 0) {
                container.innerHTML = '<p>No sensors found. Go to the Sensors page to discover and configure sensors.</p>';
                return;
            }
            
            let html = '';
            html += `<div class="status-item"><span class="status-label">Total Sensors:</span> <span>${data.sensors.length}</span></div>`;
            
            const ds18b20Count = data.sensors.filter(s => s.type === 'DS18B20').length;
            const pt1000Count = data.sensors.filter(s => s.type === 'PT1000').length;
            
            html += `<div class="status-item"><span class="status-label">DS18B20 Sensors:</span> <span>${ds18b20Count}</span></div>`;
            html += `<div class="status-item"><span class="status-label">PT1000 Sensors:</span> <span>${pt1000Count}</span></div>`;
            
            const alarmsCount = data.sensors.filter(s => s.alarmStatus > 0).length;
            const errorsCount = data.sensors.filter(s => s.errorStatus > 0).length;
            
            html += `<div class="status-item"><span class="status-label">Sensors in Alarm:</span> <span>${alarmsCount}</span></div>`;
            html += `<div class="status-item"><span class="status-label">Sensors with Errors:</span> <span>${errorsCount}</span></div>`;
            
            html += `<p><a href="/sensors.html">View all sensors</a></p>`;
            
            container.innerHTML = html;
        }
        
        // Load data when page loads
        document.addEventListener('DOMContentLoaded', () => {
            fetchSystemStatus();
            fetchSensorOverview();
        });
        
        // Refresh data every 5 seconds
        setInterval(() => {
            fetchSystemStatus();
            fetchSensorOverview();
        }, UPDATE_INTERVAL);



        // Helper functions for status rendering
        function getAlarmText(alarmStatus) {
            if (alarmStatus === 0) return '<span class="status-ok">OK</span>';
            const alarms = [];
            if (alarmStatus & 0x01) alarms.push('Low Temp');
            if (alarmStatus & 0x02) alarms.push('High Temp');
            return `<span class="status-alarm">${alarms.join(', ')}</span>`;
        }
        function getErrorText(errorStatus) {
            if (errorStatus === 0) return '<span class="status-ok">OK</span>';
            const errors = [];
            if (errorStatus & 0x01) errors.push('Comm');
            if (errorStatus & 0x02) errors.push('OutOfRange');
            if (errorStatus & 0x04) errors.push('Disconnected');
            return `<span class="status-error">${errors.join(', ')}</span>`;
        }
        function getSensorStatus(bound) {
            return bound
                ? '<span class="status-bound">Bound</span>'
                : '<span class="status-unbound">Unbound</span>';
        }

        // Modal logic
        const modal = document.getElementById('pointConfigModal');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        const modalCancelBtn = document.getElementById('modalCancelBtn');
        const pointConfigForm = document.getElementById('pointConfigForm');
        let currentEditPoint = null;

        function openModal(point) {
            currentEditPoint = point;
            document.getElementById('modalPointAddress').value = point.address;
            document.getElementById('modalPointName').value = point.name || '';
            document.getElementById('modalLowAlarm').value = point.lowAlarmThreshold;
            document.getElementById('modalHighAlarm').value = point.highAlarmThreshold;
            modal.style.display = "block";
        }
        function closeModal() {
            modal.style.display = "none";
            currentEditPoint = null;
        }
        modalCloseBtn.onclick = closeModal;
        modalCancelBtn.onclick = closeModal;
        window.onclick = function(event) {
            if (event.target === modal) closeModal();
        };

        // Fetch and render points
        function fetchAndRenderPoints() {
            fetch('/api/points')
                .then(res => res.json())
                .then(data => renderPointsTables(data.points))
                .catch(() => {
                    document.getElementById('dsPointsTbody').innerHTML = '<tr><td colspan="11">Failed to load points.</td></tr>';
                    document.getElementById('ptPointsTbody').innerHTML = '<tr><td colspan="11">Failed to load points.</td></tr>';
                });
        }

        function renderPointsTables(points) {
            const dsTbody = document.getElementById('dsPointsTbody');
            const ptTbody = document.getElementById('ptPointsTbody');
            dsTbody.innerHTML = '';
            ptTbody.innerHTML = '';

            const dsPoints = points.filter(p => p.type === "DS18B20");
            const ptPoints = points.filter(p => p.type === "PT1000");

            if (dsPoints.length === 0) {
                dsTbody.innerHTML = '<tr><td colspan="11">No DS18B20 points found.</td></tr>';
            } else {
                dsPoints.forEach(point => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${point.address}</td>
                        <td>${point.name || ''}</td>
                        <td>${point.currentTemp !== undefined ? point.currentTemp : ''}</td>
                        <td>${point.minTemp !== undefined ? point.minTemp : ''}</td>
                        <td>${point.maxTemp !== undefined ? point.maxTemp : ''}</td>
                        <td>${getAlarmText(point.alarmStatus)}</td>
                        <td>${getErrorText(point.errorStatus)}</td>
                       
                    `;
                    dsTbody.appendChild(row);
                });
            }

            if (ptPoints.length === 0) {
                ptTbody.innerHTML = '<tr><td colspan="11">No PT1000 points found.</td></tr>';
            } else {
                ptPoints.forEach(point => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${point.address}</td>
                        <td>${point.name || ''}</td>
                        <td>${point.currentTemp !== undefined ? point.currentTemp : ''}</td>
                        <td>${point.minTemp !== undefined ? point.minTemp : ''}</td>
                        <td>${point.maxTemp !== undefined ? point.maxTemp : ''}</td>
                        <td>${getAlarmText(point.alarmStatus)}</td>
                        <td>${getErrorText(point.errorStatus)}</td>
                      
                    `;
                    ptTbody.appendChild(row);
                });
            }
        }

        // Edit handler
        function onEditPoint(address) {
            fetch('/api/points')
                .then(res => res.json())
                .then(data => {
                    const point = data.points.find(p => p.address === address);
                    if (point) openModal(point);
                });
        }
        window.onEditPoint = onEditPoint;

        // Handle form submit
        pointConfigForm.onsubmit = function(e) {
            e.preventDefault();
            const address = parseInt(document.getElementById('modalPointAddress').value, 10);
            const name = document.getElementById('modalPointName').value;
            const lowAlarm = parseFloat(document.getElementById('modalLowAlarm').value);
            const highAlarm = parseFloat(document.getElementById('modalHighAlarm').value);

            fetch('/api/points', {
                method: 'PUT',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ address, name, lowAlarmThreshold: lowAlarm, highAlarmThreshold: highAlarm })
            })
            .then(res => {
                if (!res.ok) throw new Error('Failed to update point');
                closeModal();
                fetchAndRenderPoints();
            })
            .catch(() => alert('Failed to update point!'));
        };

        // Initial load
        setInterval(fetchAndRenderPoints, UPDATE_INTERVAL);
        window.onload = fetchAndRenderPoints();
        // Optionally, set up periodic refresh if needed
        // setInterval(fetchAndRenderPoints, 10000);

        // Export CSV functionality
        document.getElementById('exportCsvBtn').addEventListener('click', function() {
            fetch('/api/csv/export', {
                method: 'GET'
            })
            .then(response => {
                if (response.ok) {
                    return response.blob();
                }
                throw new Error('Export failed');
            })
            .then(blob => {
                // Create download link
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'temperature_config_' + new Date().toISOString().split('T')[0] + '.csv';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                
                document.getElementById('csvStatus').innerHTML = '<span style="color: green;">‚úì Configuration exported successfully</span>';
            })
            .catch(error => {
                document.getElementById('csvStatus').innerHTML = '<span style="color: red;">‚úó Export failed: ' + error.message + '</span>';
            });
        });

        // Import CSV functionality
        document.getElementById('importCsvBtn').addEventListener('click', function() {
            document.getElementById('csvFileInput').click();
        });

        document.getElementById('csvFileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.toLowerCase().endsWith('.csv')) {
                document.getElementById('csvStatus').innerHTML = '<span style="color: red;">‚úó Please select a CSV file</span>';
                return;
            }
            
            const formData = new FormData();
            formData.append('csvFile', file);
            
            document.getElementById('csvStatus').innerHTML = '<span style="color: blue;">‚è≥ Importing configuration...</span>';
            
            fetch('/api/csv/import', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    document.getElementById('csvStatus').innerHTML = '<span style="color: green;">‚úì Configuration imported successfully</span>';
                    // Refresh the page to show updated data
                    setTimeout(() => {
                        location.reload();
                    }, 2000);
                } else {
                    document.getElementById('csvStatus').innerHTML = '<span style="color: red;">‚úó Import failed: ' + data.error + '</span>';
                }
            })
            .catch(error => {
                document.getElementById('csvStatus').innerHTML = '<span style="color: red;">‚úó Import failed: ' + error.message + '</span>';
            });
            
            // Reset file input
            event.target.value = '';
        });

        // Export Settings CSV functionality
        document.getElementById('exportSettingsBtn').addEventListener('click', function() {
            fetch('/api/settings/export', {
                method: 'GET'
            })
            .then(response => {
                if (response.ok) {
                    return response.blob();
                }
                throw new Error('Settings export failed');
            })
            .then(blob => {
                // Create download link
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'device_settings_' + new Date().toISOString().split('T')[0] + '.csv';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                
                document.getElementById('settingsStatus').innerHTML = '<span style="color: green;">‚úì Device settings exported successfully</span>';
            })
            .catch(error => {
                document.getElementById('settingsStatus').innerHTML = '<span style="color: red;">‚úó Export failed: ' + error.message + '</span>';
            });
        });

        // Import Settings CSV functionality
        document.getElementById('importSettingsBtn').addEventListener('click', function() {
            document.getElementById('settingsFileInput').click();
        });

        document.getElementById('settingsFileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.toLowerCase().endsWith('.csv')) {
                document.getElementById('settingsStatus').innerHTML = '<span style="color: red;">‚úó Please select a CSV file</span>';
                return;
            }
            
            if (!confirm('Importing settings will restart the device. Continue?')) {
                event.target.value = '';
                return;
            }
            
            const formData = new FormData();
            formData.append('settingsFile', file);
            
            document.getElementById('settingsStatus').innerHTML = '<span style="color: blue;">‚è≥ Importing settings...</span>';
            
            fetch('/api/settings/import', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    document.getElementById('settingsStatus').innerHTML = '<span style="color: green;">‚úì Settings imported successfully. Device restarting...</span>';
                } else {
                    document.getElementById('settingsStatus').innerHTML = '<span style="color: red;">‚úó Import failed: ' + data.error + '</span>';
                }
            })
            .catch(error => {
                document.getElementById('settingsStatus').innerHTML = '<span style="color: red;">‚úó Import failed: ' + error.message + '</span>';
            });
            
            // Reset file input
            event.target.value = '';
        });
    </script>
</body>
</html>

-------- [ Separator ] ------

File Name: data/download-logs.html
Size: 16.94 KB
Code:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Download Logs - Temperature Controller</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .nav-links {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .nav-links a {
            color: #667eea;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .nav-links a:hover {
            background-color: #f0f0f0;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .card-header {
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .card-header h3 {
            color: #333;
            font-size: 1.2em;
        }

        .filters {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
        }

        .filter-group label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
        }

        .filter-group select,
        .filter-group input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .btn:hover {
            background: #5a6fd8;
        }

        .btn-success {
            background: #28a745;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-sm {
            padding: 5px 10px;
            font-size: 12px;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .table th,
        .table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #555;
        }

        .table tr:hover {
            background: #f8f9fa;
        }

        .status {
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
        }

        .status.loading {
            background: #d1ecf1;
            color: #0c5460;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
        }

        .file-type-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .file-type-data {
            background: #e3f2fd;
            color: #1976d2;
        }

        .file-type-event {
            background: #fff3e0;
            color: #f57c00;
        }

        .file-type-alarm {
            background: #ffebee;
            color: #d32f2f;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        @media (max-width: 768px) {
            .filters {
                grid-template-columns: 1fr;
            }
            
            .nav-links {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üì• Download Log Files</h1>
            <div class="nav-links">
                <a href="/">üè† Home</a>
                <a href="/sensors.html">üå°Ô∏è Sensors</a>
                <a href="/points.html">üìç Points</a>
                <a href="/alarms.html">üö® Alarms</a>
                <a href="/alarm-history.html">üìä Alarm History</a>
                <a href="/event-logs.html">üìã Event Logs</a>
                <a href="/configuration.html">‚öôÔ∏è Configuration</a>
            </div>
        </div>

        <!-- Statistics -->
        <div class="card">
            <div class="card-header">
                <h3>üìä File Statistics</h3>
            </div>
            <div class="stats" id="fileStats">
                <div class="stat-card">
                    <div class="stat-number" id="totalFiles">0</div>
                    <div class="stat-label">Total Files</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="dataFiles">0</div>
                    <div class="stat-label">Data Files</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="eventFiles">0</div>
                    <div class="stat-label">Event Files</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="alarmFiles">0</div>
                    <div class="stat-label">Alarm Files</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalSize">0 KB</div>
                    <div class="stat-label">Total Size</div>
                </div>
            </div>
        </div>

        <!-- Filters -->
        <div class="card">
            <div class="card-header">
                <h3>üîç Filter Files</h3>
            </div>
            <div class="filters">
                <div class="filter-group">
                    <label for="logTypeFilter">Log Type:</label>
                    <select id="logTypeFilter">
                        <option value="all">All Types</option>
                        <option value="data">Temperature Data</option>
                        <option value="event">Event Logs</option>
                        <option value="alarm">Alarm States</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="dateFromFilter">Date From:</label>
                    <input type="date" id="dateFromFilter">
                </div>
                <div class="filter-group">
                    <label for="dateToFilter">Date To:</label>
                    <input type="date" id="dateToFilter">
                </div>
                <div class="filter-group">
                    <label for="sizeFilter">Min Size (KB):</label>
                    <input type="number" id="sizeFilter" min="0" placeholder="0">
                </div>
                <div class="filter-group">
                    <label>&nbsp;</label>
                    <button class="btn" onclick="applyFilters()">üîç Apply Filters</button>
                </div>
                <div class="filter-group">
                    <label>&nbsp;</label>
                    <button class="btn" onclick="clearFilters()">üîÑ Clear Filters</button>
                </div>
            </div>
        </div>

        <!-- File List -->
        <div class="card">
            <div class="card-header">
                <h3>üìÅ Available Files</h3>
                <button class="btn" onclick="refreshFileList()" style="float: right;">üîÑ Refresh</button>
            </div>
            
            <div id="statusMessage"></div>
            
            <div id="fileListContainer">
                <p>Click "Refresh" to load available files</p>
            </div>
        </div>
    </div>

    <script>
        let allFiles = [];
        let filteredFiles = [];

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            // Set default date range (last 30 days)
            const today = new Date();
            const thirtyDaysAgo = new Date(today.getTime() - (30 * 24 * 60 * 60 * 1000));
            
            document.getElementById('dateToFilter').value = today.toISOString().split('T')[0];
            document.getElementById('dateFromFilter').value = thirtyDaysAgo.toISOString().split('T')[0];
            
            refreshFileList();
        });

        function showStatus(message, type = 'loading') {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function hideStatus() {
            document.getElementById('statusMessage').innerHTML = '';
        }

        async function refreshFileList() {
            showStatus('üîÑ Loading file list...', 'loading');
            
            try {
                // Load all file types
                const [dataFiles, eventFiles, alarmFiles] = await Promise.all([
                    fetch('/api/data-log-files').then(r => r.json()),
                    fetch('/api/event-log-files').then(r => r.json()),
                    fetch('/api/alarm-log-files').then(r => r.json())
                ]);

                allFiles = [];

                // Process data files
                if (dataFiles.success) {
                    dataFiles.files.forEach(file => {
                        allFiles.push({
                            ...file,
                            type: 'data',
                            typeLabel: 'Temperature Data'
                        });
                    });
                }

                // Process event files
                if (eventFiles.success) {
                    eventFiles.files.forEach(file => {
                        allFiles.push({
                            ...file,
                            type: 'event',
                            typeLabel: 'Event Log'
                        });
                    });
                }

                // Process alarm files
                if (alarmFiles.success) {
                    alarmFiles.files.forEach(file => {
                        allFiles.push({
                            ...file,
                            type: 'alarm',
                            typeLabel: 'Alarm State'
                        });
                    });
                }

                updateStatistics();
                applyFilters();
                hideStatus();

            } catch (error) {
                console.error('Error loading file list:', error);
                showStatus('‚ùå Error loading file list', 'error');
            }
        }

        function updateStatistics() {
            const stats = {
                total: allFiles.length,
                data: allFiles.filter(f => f.type === 'data').length,
                event: allFiles.filter(f => f.type === 'event').length,
                alarm: allFiles.filter(f => f.type === 'alarm').length,
                totalSize: allFiles.reduce((sum, f) => sum + (f.size || 0), 0)
            };

            document.getElementById('totalFiles').textContent = stats.total;
            document.getElementById('dataFiles').textContent = stats.data;
            document.getElementById('eventFiles').textContent = stats.event;
            document.getElementById('alarmFiles').textContent = stats.alarm;
            document.getElementById('totalSize').textContent = Math.round(stats.totalSize / 1024) + ' KB';
        }

        function applyFilters() {
            const typeFilter = document.getElementById('logTypeFilter').value;
            const dateFrom = document.getElementById('dateFromFilter').value;
            const dateTo = document.getElementById('dateToFilter').value;
            const minSize = parseInt(document.getElementById('sizeFilter').value) || 0;

            filteredFiles = allFiles.filter(file => {
                // Type filter
                if (typeFilter !== 'all' && file.type !== typeFilter) {
                    return false;
                }

                // Date filter
                if (file.date) {
                    if (dateFrom && file.date < dateFrom) return false;
                    if (dateTo && file.date > dateTo) return false;
                }

                // Size filter
                if (file.size && (file.size / 1024) < minSize) {
                    return false;
                }

                return true;
            });

            displayFileList();
        }

        function clearFilters() {
            document.getElementById('logTypeFilter').value = 'all';
            document.getElementById('dateFromFilter').value = '';
            document.getElementById('dateToFilter').value = '';
            document.getElementById('sizeFilter').value = '';
            
            filteredFiles = [...allFiles];
            displayFileList();
        }

        function displayFileList() {
            const container = document.getElementById('fileListContainer');
            
            if (filteredFiles.length === 0) {
                container.innerHTML = '<p>No files match the current filters</p>';
                return;
            }

            // Sort files by date (newest first)
            filteredFiles.sort((a, b) => {
                if (a.date && b.date) {
                    return b.date.localeCompare(a.date);
                }
                return b.filename.localeCompare(a.filename);
            });

            let html = '<table class="table">';
            html += '<thead><tr><th>Type</th><th>Date</th><th>Filename</th><th>Size</th><th>Action</th></tr></thead>';
            html += '<tbody>';

            filteredFiles.forEach(file => {
                const sizeKB = file.size ? Math.round(file.size / 1024) : 0;
                const typeClass = `file-type-${file.type}`;
                
                html += `<tr>
                    <td><span class="file-type-badge ${typeClass}">${file.typeLabel}</span></td>
                    <td>${file.date || 'Unknown'}</td>
                    <td>${file.filename}</td>
                    <td>${sizeKB} KB</td>
                    <td>
                        <button onclick="downloadFile('${file.filename}', '${file.type}')" 
                                class="btn btn-sm btn-success">üì• Download</button>
                    </td>
                </tr>`;
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function downloadFile(filename, type) {
            let downloadUrl;
            
            switch(type) {
                case 'data':
                    downloadUrl = `/api/data-log-download?file=${encodeURIComponent(filename)}`;
                    break;
                case 'event':
                    downloadUrl = `/api/event-log-download?file=${encodeURIComponent(filename)}`;
                    break;
                case 'alarm':
                    downloadUrl = `/api/alarm-log-download?file=${encodeURIComponent(filename)}`;
                    break;
                default:
                    console.error('Unknown file type:', type);
                    return;
            }

            // Create temporary link and trigger download
            const link = document.createElement('a');
            link.href = downloadUrl;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            console.log(`Downloading ${type} file: ${filename}`);
            showStatus(`üì• Downloading ${filename}...`, 'success');
            
            // Hide status after 3 seconds
            setTimeout(hideStatus, 3000);
        }
    </script>
</body>
</html>

-------- [ Separator ] ------

File Name: data/event-logs.html
Size: 22.84 KB
Code:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temperature Controller - Event Logs</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        nav {
            margin-bottom: 20px;
            padding: 10px;
            background: #007bff;
            border-radius: 5px;
        }
        nav a {
            color: white;
            text-decoration: none;
            margin-right: 15px;
            padding: 5px 10px;
            border-radius: 3px;
        }
        nav a:hover {
            background: rgba(255,255,255,0.2);
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .controls button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-success {
            background-color: #28a745;
            color: white;
        }
        .btn-info {
            background-color: #17a2b8;
            color: white;
        }
        .btn:hover {
            opacity: 0.8;
        }
        .filter-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .filter-group label {
            font-weight: bold;
            margin-right: 5px;
        }
        .filter-group select, .filter-group input {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        .date-range {
            display: flex;
            gap: 10px;
            align-items: center;
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        th:hover {
            background-color: #e9ecef;
        }
        th.sortable::after {
            content: " ‚Üï";
            color: #999;
            font-size: 12px;
        }
        th.sort-asc::after {
            content: " ‚Üë";
            color: #007bff;
            font-weight: bold;
        }
        th.sort-desc::after {
            content: " ‚Üì";
            color: #007bff;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .priority-critical {
            background-color: #f8d7da;
            color: #721c24;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
        }
        .priority-error {
            background-color: #f8d7da;
            color: #721c24;
            padding: 4px 8px;
            border-radius: 4px;
        }
        .priority-warning {
            background-color: #fff3cd;
            color: #856404;
            padding: 4px 8px;
            border-radius: 4px;
        }
        .priority-info {
            background-color: #d1ecf1;
            color: #0c5460;
            padding: 4px 8px;
            border-radius: 4px;
        }
        .no-logs {
            text-align: center;
            padding: 40px;
            color: #6c757d;
            font-style: italic;
        }
        .timestamp {
            font-size: 12px;
            color: #6c757d;
        }
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
        }
        .pagination button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            border-radius: 4px;
        }
        .pagination button:hover {
            background: #f8f9fa;
        }
        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .pagination .current-page {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        .search-box {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .search-box input {
            width: 300px;
            padding: 5px 10px;
        }
        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .stat-card {
            flex: 1;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            color: white;
        }
        .stat-total {
            background-color: #6c757d;
        }
        .stat-critical {
            background-color: #dc3545;
        }
        .stat-error {
            background-color: #dc3545;
        }
        .stat-warning {
            background-color: #ffc107;
            color: black;
        }
        .stat-info {
            background-color: #17a2b8;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
        }
        .stat-label {
            font-size: 14px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="/dashboard.html">Home</a>
            <a href="/sensors.html">Sensors</a>
            <a href="/points.html">Points</a>
            <a href="/alarms.html">Alarms</a>
            <a href="/alarm-history.html">Alarm History</a>
            <a href="/event-logs.html">Event Logs</a>
            <a href="/config">Configuration</a>
        </nav>

        <h1>System Event Logs</h1>

        <!-- Statistics -->
        <div class="stats" id="statsContainer">
            <div class="stat-card stat-total">
                <div class="stat-value" id="totalCount">0</div>
                <div class="stat-label">Total Events</div>
            </div>
            <div class="stat-card stat-critical">
                <div class="stat-value" id="criticalCount">0</div>
                <div class="stat-label">Critical</div>
            </div>
            <div class="stat-card stat-error">
                <div class="stat-value" id="errorCount">0</div>
                <div class="stat-label">Errors</div>
            </div>
            <div class="stat-card stat-warning">
                <div class="stat-value" id="warningCount">0</div>
                <div class="stat-label">Warnings</div>
            </div>
            <div class="stat-card stat-info">
                <div class="stat-value" id="infoCount">0</div>
                <div class="stat-label">Info</div>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <div class="date-range">
                <label>Date Range:</label>
                <input type="date" id="startDate">
                <span>to</span>
                <input type="date" id="endDate">
                <button class="btn btn-primary" onclick="loadLogs()">üîç Load Logs</button>
            </div>
            
            <button class="btn btn-success" onclick="exportLogs()">üì• Export CSV</button>
            <button class="btn btn-info" onclick="refreshLogs()">üîÑ Refresh</button>
            
            <div class="filter-group">
                <label>Filter by Priority:</label>
                <select id="priorityFilter" onchange="filterTable()">
                    <option value="">All Priorities</option>
                    <option value="CRITICAL">Critical</option>
                    <option value="ERROR">Error</option>
                    <option value="WARNING">Warning</option>
                    <option value="INFO">Info</option>
                </select>
            </div>

            <div class="filter-group">
                <label>Filter by Source:</label>
                <select id="sourceFilter" onchange="filterTable()">
                    <option value="">All Sources</option>
                </select>
            </div>
        </div>

        <!-- Search Box -->
        <div class="controls">
            <div class="search-box">
                <label>Search Description:</label>
                <input type="text" id="searchBox" placeholder="Enter keywords..." onkeyup="filterTable()">
                <button class="btn btn-primary" onclick="clearSearch()">Clear</button>
            </div>
        </div>

        <!-- Event Logs Table -->
        <table id="logsTable">
            <thead>
                <tr>
                    <th class="sortable" onclick="sortTable(0)">Timestamp</th>
                    <th class="sortable" onclick="sortTable(1)">Source</th>
                    <th class="sortable" onclick="sortTable(2)">Description</th>
                    <th class="sortable" onclick="sortTable(3)">Priority</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td colspan="4" class="no-logs">Select a date range and click "Load Logs" to view system events</td>
                </tr>
            </tbody>
        </table>

        <!-- Pagination -->
        <div class="pagination" id="pagination" style="display: none;">
            <button id="prevPage" onclick="changePage(-1)">‚Üê Previous</button>
            <span id="pageInfo">Page 1 of 1</span>
            <button id="nextPage" onclick="changePage(1)">Next ‚Üí</button>
        </div>
    </div>

    <script>
        let logsData = [];
        let filteredData = [];
        let sortColumn = -1;
        let sortDirection = 'desc'; // Default to newest first
        let currentPage = 1;
        const itemsPerPage = 100;
        let uniqueSources = new Set();

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            // Set default date range (last 7 days)
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 7);
            
            document.getElementById('endDate').value = endDate.toISOString().split('T')[0];
            document.getElementById('startDate').value = startDate.toISOString().split('T')[0];
            
            // Load logs automatically on page load
            loadLogs();
        });

        // Load event logs from API
        async function loadLogs() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            if (!startDate || !endDate) {
                alert('Please select both start and end dates');
                return;
            }
            
            if (new Date(startDate) > new Date(endDate)) {
                alert('Start date must be before end date');
                return;
            }

            try {
                const response = await fetch(`/api/event-logs?start=${startDate}&end=${endDate}`);
                const data = await response.json();
                
                if (data.success) {
                    logsData = data.logs || [];
                    currentPage = 1;
                    
                    // Extract unique sources
                    uniqueSources.clear();
                    logsData.forEach(log => {
                        if (log.source) {
                            uniqueSources.add(log.source);
                        }
                    });
                    
                    // Update source filter dropdown
                    updateSourceFilter();
                    
                    // Sort by timestamp descending by default
                    sortColumn = 0;
                    sortDirection = 'desc';
                    
                    displayLogs();
                    updateStatistics();
                } else {
                    throw new Error(data.error || 'Failed to load logs');
                }
            } catch (error) {
                console.error('Error loading event logs:', error);
                document.querySelector('#logsTable tbody').innerHTML = 
                    '<tr><td colspan="4" class="no-logs">Error loading event logs: ' + error.message + '</td></tr>';
            }
        }

        // Update source filter dropdown
        function updateSourceFilter() {
            const sourceFilter = document.getElementById('sourceFilter');
            sourceFilter.innerHTML = '<option value="">All Sources</option>';
            
            // Sort sources alphabetically
            const sortedSources = Array.from(uniqueSources).sort();
            
            sortedSources.forEach(source => {
                const option = document.createElement('option');
                option.value = source;
                option.textContent = source;
                sourceFilter.appendChild(option);
            });
        }

        // Update statistics
        function updateStatistics() {
            const stats = {
                total: 0,
                critical: 0,
                error: 0,
                warning: 0,
                info: 0
            };

            filteredData.forEach(log => {
                stats.total++;
                switch (log.priority) {
                    case 'CRITICAL': stats.critical++; break;
                    case 'ERROR': stats.error++; break;
                    case 'WARNING': stats.warning++; break;
                    case 'INFO': stats.info++; break;
                }
            });

            document.getElementById('totalCount').textContent = stats.total;
            document.getElementById('criticalCount').textContent = stats.critical;
            document.getElementById('errorCount').textContent = stats.error;
            document.getElementById('warningCount').textContent = stats.warning;
            document.getElementById('infoCount').textContent = stats.info;
        }

        // Display logs in table
        function displayLogs() {
            const tbody = document.querySelector('#logsTable tbody');
            
            if (logsData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" class="no-logs">No event logs found for the selected date range</td></tr>';
                document.getElementById('pagination').style.display = 'none';
                return;
            }

            // Apply filters
            filterTable();
        }

        // Create table row for log entry
        function createLogRow(entry) {
            const row = document.createElement('tr');
            
            row.innerHTML = `
                <td><span class="timestamp">${entry.timestamp}</span></td>
                <td>${entry.source || 'Unknown'}</td>
                <td>${entry.description || ''}</td>
                <td><span class="priority-${entry.priority.toLowerCase()}">${entry.priority}</span></td>
            `;
            
            // Set data attributes for filtering
            row.dataset.priority = entry.priority;
            row.dataset.source = entry.source || '';
            row.dataset.description = (entry.description || '').toLowerCase();
            
            return row;
        }

        // Filter table function
        function filterTable() {
            const priorityFilter = document.getElementById('priorityFilter').value;
            const sourceFilter = document.getElementById('sourceFilter').value;
            const searchText = document.getElementById('searchBox').value.toLowerCase();
            
            filteredData = logsData.filter(entry => {
                const priorityMatch = !priorityFilter || entry.priority === priorityFilter;
                const sourceMatch = !sourceFilter || entry.source === sourceFilter;
                const searchMatch = !searchText || 
                    (entry.description && entry.description.toLowerCase().includes(searchText)) ||
                    (entry.source && entry.source.toLowerCase().includes(searchText));
                
                return priorityMatch && sourceMatch && searchMatch;
            });
            
            // Apply current sorting
            if (sortColumn >= 0) {
                applySorting();
            }
            
            currentPage = 1;
            displayFilteredData();
            updateStatistics();
        }

        // Apply sorting to filtered data
        function applySorting() {
            filteredData.sort((a, b) => {
                let aValue, bValue;
                
                switch (sortColumn) {
                    case 0: // Timestamp
                        aValue = new Date(a.timestamp);
                        bValue = new Date(b.timestamp);
                        break;
                    case 1: // Source
                        aValue = a.source || '';
                        bValue = b.source || '';
                        break;
                    case 2: // Description
                        aValue = a.description || '';
                        bValue = b.description || '';
                        break;
                    case 3: // Priority
                        const priorityOrder = { 'CRITICAL': 0, 'ERROR': 1, 'WARNING': 2, 'INFO': 3 };
                        aValue = priorityOrder[a.priority] || 999;
                        bValue = priorityOrder[b.priority] || 999;
                        break;
                    default:
                        return 0;
                }
                
                let comparison = 0;
                if (typeof aValue === 'number' && typeof bValue === 'number') {
                    comparison = aValue - bValue;
                } else if (aValue instanceof Date && bValue instanceof Date) {
                    comparison = aValue - bValue;
                } else {
                    comparison = String(aValue).localeCompare(String(bValue));
                }
                
                return sortDirection === 'asc' ? comparison : -comparison;
            });
        }

        // Display filtered and paginated data
        function displayFilteredData() {
            const tbody = document.querySelector('#logsTable tbody');
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageData = filteredData.slice(startIndex, endIndex);
            
            if (pageData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" class="no-logs">No event logs match the current filters</td></tr>';
                document.getElementById('pagination').style.display = 'none';
                return;
            }
            
            tbody.innerHTML = '';
            pageData.forEach(entry => {
                tbody.appendChild(createLogRow(entry));
            });
            
            // Update pagination
            const totalPages = Math.ceil(filteredData.length / itemsPerPage);
            if (totalPages > 1) {
                document.getElementById('pagination').style.display = 'flex';
                document.getElementById('pageInfo').textContent = `Page ${currentPage} of ${totalPages} (${filteredData.length} entries)`;
                document.getElementById('prevPage').disabled = currentPage === 1;
                document.getElementById('nextPage').disabled = currentPage === totalPages;
            } else {
                document.getElementById('pagination').style.display = 'none';
            }
        }

        // Pagination functions
        function changePage(direction) {
            const totalPages = Math.ceil(filteredData.length / itemsPerPage);
            const newPage = currentPage + direction;
            
            if (newPage >= 1 && newPage <= totalPages) {
                currentPage = newPage;
                displayFilteredData();
            }
        }

        // Table sorting function
        function sortTable(columnIndex) {
            const table = document.getElementById('logsTable');
            
            // Update sort direction
            if (sortColumn === columnIndex) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortDirection = columnIndex === 0 ? 'desc' : 'asc'; // Default newest first for timestamp
                sortColumn = columnIndex;
            }

            // Clear previous sort indicators
            table.querySelectorAll('th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });

            // Add current sort indicator
            const currentHeader = table.querySelector(`th:nth-child(${columnIndex + 1})`);
            currentHeader.classList.add(sortDirection === 'asc' ? 'sort-asc' : 'sort-desc');

            // Apply sorting and redisplay
            applySorting();
            displayFilteredData();
        }

        // Export logs to CSV
        async function exportLogs() {
            if (filteredData.length === 0) {
                alert('No data to export. Please load logs first.');
                return;
            }
            
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            try {
                const response = await fetch(`/api/event-logs/export?start=${startDate}&end=${endDate}`, {
                    method: 'GET'
                });
                
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `event_logs_${startDate}_to_${endDate}.csv`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                } else {
                    throw new Error('Export failed');
                }
            } catch (error) {
                console.error('Error exporting logs:', error);
                alert('Failed to export logs: ' + error.message);
            }
        }

        // Refresh logs
        function refreshLogs() {
            loadLogs();
        }

        // Clear search
        function clearSearch() {
            document.getElementById('searchBox').value = '';
            filterTable();
        }
    </script>
</body>
</html>
-------- [ Separator ] ------

File Name: data/points.html
Size: 20.55 KB
Code:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temperature Controller - Points</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        nav {
            margin-bottom: 20px;
            padding: 10px;
            background: #007bff;
            border-radius: 5px;
        }
        nav a {
            color: white;
            text-decoration: none;
            margin-right: 15px;
            padding: 5px 10px;
            border-radius: 3px;
        }
        nav a:hover {
            background: rgba(255,255,255,0.2);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .btn {
            padding: 5px 10px;
            margin: 2px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-warning {
            background-color: #ffc107;
            color: black;
        }
        .btn-danger {
            background-color: #dc3545;
            color: white;
        }
        .btn:hover {
            opacity: 0.8;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            border-radius: 8px;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover {
            color: black;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input, .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        .alarm-list {
            margin-top: 20px;
        }
        .alarm-item {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
        }
        .alarm-item.critical {
            border-left: 4px solid #dc3545;
        }
        .alarm-item.high {
            border-left: 4px solid #fd7e14;
        }
        .alarm-item.medium {
            border-left: 4px solid #ffc107;
        }
        .alarm-item.low {
            border-left: 4px solid #28a745;
        }
        .status-active {
            color: #dc3545;
            font-weight: bold;
        }
        .status-inactive {
            color: #6c757d;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="/dashboard.html">Home</a>
            <a href="/sensors.html">Sensors</a>
            <a href="/points.html">Points</a>
            <a href="/alarms.html">Alarms</a>
            <a href="/alarm-history.html">Alarm History</a>
            <a href="/event-logs.html">Event Logs</a>
            <a href="/config">Configuration</a>
        </nav>

        <h1>Temperature Measurement Points</h1>

        ## DS18B20 Points
        <table id="ds18b20Table">
            <thead>
                <tr>
                    <th>Address</th>
                    <th>Bus</th>
                    <th>Name</th>
                    <th>Current Temp</th>
                    <th>Min Temp</th>
                    <th>Max Temp</th>
                    <th>Low Alarm</th>
                    <th>High Alarm</th>
                    <th>Alarm Status</th>
                    <th>Error Status</th>
                    <th>Sensor Status</th>
                    <th>Edit Point</th>
                    <th>Edit Alarm</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td colspan="13">Loading DS18B20 points...</td>
                </tr>
            </tbody>
        </table>

        ## PT1000 Points
        <table id="pt1000Table">
            <thead>
                <tr>
                    <th>Address</th>
                    <th>Bus</th>
                    <th>Name</th>
                    <th>Current Temp</th>
                    <th>Min Temp</th>
                    <th>Max Temp</th>
                    <th>Low Alarm</th>
                    <th>High Alarm</th>
                    <th>Alarm Status</th>
                    <th>Error Status</th>
                    <th>Sensor Status</th>
                    <th>Edit Point</th>
                    <th>Edit Alarm</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td colspan="13">Loading PT1000 points...</td>
                </tr>
            </tbody>
        </table>
    </div>

    <!-- Point Edit Modal -->
    <div id="pointModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closePointModal()">&times;</span>
            <h2>Edit Point</h2>
            <form id="pointForm">
                <div class="form-group">
                    <label for="pointAddress">Address:</label>
                    <input type="number" id="pointAddress" readonly>
                </div>
                <div class="form-group">
                    <label for="pointName">Name:</label>
                    <input type="text" id="pointName" required>
                </div>
                <div class="form-group">
                    <label for="lowAlarm">Low Alarm Threshold:</label>
                    <input type="number" id="lowAlarm" step="0.1">
                </div>
                <div class="form-group">
                    <label for="highAlarm">High Alarm Threshold:</label>
                    <input type="number" id="highAlarm" step="0.1">
                </div>
                <button type="submit" class="btn btn-primary">Save Point</button>
                <button type="button" class="btn" onclick="closePointModal()">Cancel</button>
            </form>
        </div>
    </div>

    <!-- Alarm Configuration Modal -->
    <div id="alarmModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeAlarmModal()">&times;</span>
            <h2>Alarm Configuration for Point <span id="alarmPointInfo"></span></h2>
            
            <div class="form-group">
                <h3>Add New Alarm</h3>
                <form id="alarmForm">
                    <div class="form-group">
                        <label for="alarmType">Alarm Type:</label>
                        <select id="alarmType" required>
                            <option value="0">High Temperature</option>
                            <option value="1">Low Temperature</option>
                            <option value="2">Sensor Error</option>
                            <option value="3">Sensor Disconnected</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="alarmPriority">Priority:</label>
                        <select id="alarmPriority" required>
                            <option value="0">Low</option>
                            <option value="1">Medium</option>
                            <option value="2">High</option>
                            <option value="3">Critical</option>
                        </select>
                    </div>
                    <button type="submit" class="btn btn-primary">Add Alarm</button>
                </form>
            </div>

            <div class="alarm-list">
                <h3>Configured Alarms</h3>
                <div id="alarmsList">
                    <!-- Alarms will be loaded here -->
                </div>
            </div>

            <div style="margin-top: 20px;">
                <button type="button" class="btn" onclick="closeAlarmModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        const UPDATE_INTERVAL = 5000;
        let currentPointAddress = null;
        let pointsData = [];
        let alarmsData = [];

        // Load points data on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadPoints();
            loadAlarms();
        });

        // Load points from API
        async function loadPoints() {
            try {
                const response = await fetch('/api/points');
                const data = await response.json();
                pointsData = data.points || [];
                displayPoints();
            } catch (error) {
                console.error('Error loading points:', error);
            }
        }

        // Load alarms from API
        async function loadAlarms() {
            try {
                const response = await fetch('/api/alarms');
                const data = await response.json();
                alarmsData = data.alarms || [];
            } catch (error) {
                console.error('Error loading alarms:', error);
            }
        }

        // Display points in tables
        function displayPoints() {
            const ds18b20Table = document.getElementById('ds18b20Table').getElementsByTagName('tbody')[0];
            const pt1000Table = document.getElementById('pt1000Table').getElementsByTagName('tbody')[0];
            
            // Clear existing rows
            ds18b20Table.innerHTML = '';
            pt1000Table.innerHTML = '';

            pointsData.forEach(point => {
                const row = createPointRow(point);
                
                if (point.type === 'DS18B20') {
                    ds18b20Table.appendChild(row);
                } else if (point.type === 'PT1000') {
                    pt1000Table.appendChild(row);
                }
            });
        }

        // Create table row for a point
        function createPointRow(point) {
            const row = document.createElement('tr');
            
            const alarmCount = getAlarmCountForPoint(point.address);
            const alarmStatus = alarmCount > 0 ? `${alarmCount} configured` : 'None';
            
            row.innerHTML = `
                <td>${point.address}</td>
                <td>${point.bus || 'N/A'}</td>
                <td>${point.name}</td>
                <td>${point.currentTemp}¬∞C</td>
                <td>${point.minTemp}¬∞C</td>
                <td>${point.maxTemp}¬∞C</td>
                <td>${point.lowAlarmThreshold}¬∞C</td>
                <td>${point.highAlarmThreshold}¬∞C</td>
                <td>${alarmStatus}</td>
                <td>${point.errorStatus || 'OK'}</td>
                <td>${point.sensorType || 'No Sensor'}</td>
                <td><button class="btn btn-primary" onclick="editPoint(${point.address})">Edit</button></td>
                <td><button class="btn btn-warning" onclick="editAlarms(${point.address})">Alarms</button></td>
            `;
            
            return row;
        }

        // Get alarm count for a specific point
        function getAlarmCountForPoint(pointAddress) {
            return alarmsData.filter(alarm => alarm.pointAddress === pointAddress).length;
        }

        // Edit point function
        function editPoint(address) {
            const point = pointsData.find(p => p.address === address);
            if (!point) return;

            document.getElementById('pointAddress').value = point.address;
            document.getElementById('pointName').value = point.name;
            document.getElementById('lowAlarm').value = point.lowAlarmThreshold;
            document.getElementById('highAlarm').value = point.highAlarmThreshold;
            
            document.getElementById('pointModal').style.display = 'block';
        }

        // Edit alarms function
        function editAlarms(address) {
            currentPointAddress = address;
            const point = pointsData.find(p => p.address === address);
            if (!point) return;

            document.getElementById('alarmPointInfo').textContent = `${address} (${point.name})`;
            displayAlarmsForPoint(address);
            document.getElementById('alarmModal').style.display = 'block';
        }

        // Display alarms for specific point
        function displayAlarmsForPoint(pointAddress) {
            const alarmsList = document.getElementById('alarmsList');
            const pointAlarms = alarmsData.filter(alarm => alarm.pointAddress === pointAddress);
            
            if (pointAlarms.length === 0) {
                alarmsList.innerHTML = '<p>No alarms configured for this point.</p>';
                return;
            }

            alarmsList.innerHTML = pointAlarms.map(alarm => `
                <div class="alarm-item ${getPriorityClass(alarm.priority)}">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong>${getAlarmTypeText(alarm.type)}</strong> - 
                            <span class="${alarm.enabled ? 'status-active' : 'status-inactive'}">
                                ${alarm.enabled ? 'Enabled' : 'Disabled'}
                            </span>
                            <br>
                            <small>Priority: ${getPriorityText(alarm.priority)}</small>
                            ${alarm.isActive ? '<br><small class="status-active">Currently Active</small>' : ''}
                        </div>
                        <div>
                            <button class="btn btn-warning" onclick="toggleAlarm('${alarm.configKey}', ${!alarm.enabled})">
                                ${alarm.enabled ? 'Disable' : 'Enable'}
                            </button>
                            <button class="btn btn-danger" onclick="deleteAlarm('${alarm.configKey}')">Delete</button>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // Helper functions for alarm display
        function getAlarmTypeText(type) {
            const types = ['High Temperature', 'Low Temperature', 'Sensor Error', 'Sensor Disconnected'];
            return types[type] || 'Unknown';
        }

        function getPriorityText(priority) {
            const priorities = ['Low', 'Medium', 'High', 'Critical'];
            return priorities[priority] || 'Unknown';
        }

        function getPriorityClass(priority) {
            const classes = ['low', 'medium', 'high', 'critical'];
            return classes[priority] || 'low';
        }

        // Form submission handlers
        document.getElementById('pointForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const pointData = {
                address: parseInt(document.getElementById('pointAddress').value),
                name: document.getElementById('pointName').value,
                lowAlarmThreshold: parseFloat(document.getElementById('lowAlarm').value),
                highAlarmThreshold: parseFloat(document.getElementById('highAlarm').value)
            };

            try {
                const response = await fetch('/api/points', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(pointData)
                });

                if (response.ok) {
                    closePointModal();
                    loadPoints();
                } else {
                    alert('Error updating point');
                }
            } catch (error) {
                console.error('Error updating point:', error);
                alert('Error updating point');
            }
        });

        document.getElementById('alarmForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const alarmData = {
                type: parseInt(document.getElementById('alarmType').value),
                pointAddress: currentPointAddress,
                priority: parseInt(document.getElementById('alarmPriority').value)
            };

            try {
                const response = await fetch('/api/alarms', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(alarmData)
                });

                if (response.ok) {
                    document.getElementById('alarmForm').reset();
                    loadAlarms();
                    displayAlarmsForPoint(currentPointAddress);
                    loadPoints(); // Refresh points to update alarm count
                } else {
                    alert('Error adding alarm');
                }
            } catch (error) {
                console.error('Error adding alarm:', error);
                alert('Error adding alarm');
            }
        });

        // Alarm management functions
        async function toggleAlarm(configKey, enabled) {
            const alarm = alarmsData.find(a => a.configKey === configKey);
            if (!alarm) return;

            try {
                const response = await fetch('/api/alarms', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        configKey: configKey,
                        priority: alarm.priority,
                        enabled: enabled
                    })
                });

                if (response.ok) {
                    loadAlarms();
                    displayAlarmsForPoint(currentPointAddress);
                    loadPoints();
                } else {
                    alert('Error updating alarm');
                }
            } catch (error) {
                console.error('Error updating alarm:', error);
                alert('Error updating alarm');
            }
        }

        async function deleteAlarm(configKey) {
            if (!confirm('Are you sure you want to delete this alarm?')) return;

            try {
                const response = await fetch(`/api/alarms?configKey=${encodeURIComponent(configKey)}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    loadAlarms();
                    displayAlarmsForPoint(currentPointAddress);
                    loadPoints();
                } else {
                    alert('Error deleting alarm');
                }
            } catch (error) {
                console.error('Error deleting alarm:', error);
                alert('Error deleting alarm');
            }
        }

        // Modal control functions
        function closePointModal() {
            document.getElementById('pointModal').style.display = 'none';
        }

        function closeAlarmModal() {
            document.getElementById('alarmModal').style.display = 'none';
            currentPointAddress = null;
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            const pointModal = document.getElementById('pointModal');
            const alarmModal = document.getElementById('alarmModal');
            
            if (event.target === pointModal) {
                closePointModal();
            }
            if (event.target === alarmModal) {
                closeAlarmModal();
            }
        }

        // Auto-refresh data every 30 seconds
        setInterval(() => {
            loadPoints();
            loadAlarms();
        }, UPDATE_INTERVAL);
    </script>
</body>
</html>

-------- [ Separator ] ------

File Name: data/sensors.html
Size: 15.97 KB
Code:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sensors Management</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        /* Use styles from index.html */
        body {
            font-family: Arial, sans-serif;
            background: #f7f7f7;
            margin: 0;
            padding: 0;
        }
        header {
            background: #3f51b5;
            color: #fff;
            padding: 1em 2em;
            text-align: center;
            font-size: 1.5em;
            letter-spacing: 2px;
        }
        nav {
            background: #263238;
            padding: 0.5em 2em;
        }
        nav a {
            color: #fff;
            text-decoration: none;
            margin-right: 2em;
            font-weight: bold;
            transition: color 0.2s;
        }
        nav a:hover {
            color: #ffeb3b;
        }
        main {
            max-width: 1200px;
            margin: 2em auto;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            padding: 2em;
        }
        h2 {
            margin-top: 1em;
            color: #3f51b5;
            font-size: 1.2em;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.25em;
        }
        .actions {
            margin-bottom: 1.5em;
        }
        button {
            background: #3f51b5;
            color: #fff;
            border: none;
            padding: 0.5em 1.2em;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            margin-right: 0.5em;
            transition: background 0.2s;
        }
        button:hover {
            background: #283593;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 2em;
        }
        th, td {
            padding: 0.6em 0.8em;
            border-bottom: 1px solid #eee;
            text-align: left;
        }
        th {
            background: #f0f4ff;
            color: #3f51b5;
        }
        tr:last-child td {
            border-bottom: none;
        }
        .status-bound {
            color: #388e3c;
            font-weight: bold;
        }
        .status-unbound {
            color: #b71c1c;
            font-weight: bold;
        }
        .rom, .chip-select {
            font-family: monospace;
            font-size: 0.98em;
            color: #333;
        }
        @media (max-width: 800px) {
            main { padding: 1em; }
            th, td { font-size: 0.95em; }
        }
    </style>
</head>
<body>
    <header>Temperature Monitoring System</header>
    <nav>
        <a href="/dashboard.html">Home</a>
        <a href="/sensors.html">Sensors</a>
        <a href="/points.html">Points</a>
        <a href="/alarms.html">Alarms</a>
        <a href="/alarm-history.html">Alarm History</a>
        <a href="/event-logs.html">Event Logs</a>
        <a href="/config">Configuration</a>

    </nav>
    <main>
        <div class="actions">
            <button id="discoverBtn">Discover</button>
            <button id="resetMinMaxBtn">Reset Min/Max</button>
        </div>

        <h2>DS18B20 Sensors</h2>
        <table id="dsTable">
            <thead>
                <tr>
                    <th>#</th>
                    <th>Name</th>
                    <th>ROM Address</th>
                    <th>Bus</th>
                    <th>Current Temp (¬∞C)</th>
                    <th>Min Temp (¬∞C)</th>
                    <th>Max Temp (¬∞C)</th>
                    <th>Measurement Point</th>
                    <th>Errors</th>
                    <th>Alarms</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="dsTbody">
                <tr><td colspan="8">Loading DS18B20 sensors...</td></tr>
            </tbody>
        </table>

        <h2>PT1000 Sensors</h2>
        <table id="ptTable">
            <thead>
                <tr>
                    <th>#</th>
                    <th>Name</th>
                    <th>Chip Select Pin</th>
                    <th>Bus</th>
                    <th>Current Temp (¬∞C)</th>
                    <th>Min Temp (¬∞C)</th>
                    <th>Max Temp (¬∞C)</th>
                    <th>Measurement Point</th>
                    <th>Errors</th>
                    <th>Alarms</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="ptTbody">
                <tr><td colspan="8">Loading PT1000 sensors...</td></tr>
            </tbody>
        </table>
    </main>
    <script>
        // Auto-update interval (ms)
        const UPDATE_INTERVAL = 5000;

        function fetchSensors() {
            fetch('/api/sensors')
                .then(res => res.json())
                .then(data => {
                    renderSensorTables(data.sensors || []);
                });
        }

        // function renderSensorTables(sensors) {
        //     // Separate DS and PT
        //     const dsSensors = sensors.filter(s => s.type === "DS18B20");
        //     const ptSensors = sensors.filter(s => s.type === "PT1000");

        //     // DS Table
        //     const dsTbody = document.getElementById('dsTbody');
        //     dsTbody.innerHTML = '';
        //     if (dsSensors.length === 0) {
        //         dsTbody.innerHTML = '<tr><td colspan="8">No DS18B20 sensors found.</td></tr>';
        //     } else {
        //         dsSensors.forEach((sensor, idx) => {
        //             const row = document.createElement('tr');
        //             row.innerHTML = `
        //                 <td>${idx+1}</td>
        //                 <td>${sensor.name || ''}</td>
        //                 <td class="rom">${sensor.romString || ''}</td>
        //                 <td>${sensor.currentTemp !== undefined ? sensor.currentTemp : ''}</td>
        //                 <td>${sensor.minTemp !== undefined ? sensor.minTemp : ''}</td>
        //                 <td>${sensor.maxTemp !== undefined ? sensor.maxTemp : ''}</td>
        //                 <td>
        //                     ${sensor.boundPoint !== null && sensor.boundPoint !== undefined
        //                         ? `<span class="status-bound">#${sensor.boundPoint}</span>`
        //                         : `<span class="status-unbound">Unbound</span>`}
        //                 </td>
        //                 <td>
        //                     ${sensor.boundPoint === null || sensor.boundPoint === undefined
        //                         ? `<button onclick="bindPrompt('DS18B20','${sensor.romString}')">Bind</button>`
        //                         : `<button onclick="unbindSensor('DS18B20','${sensor.romString}')">Unbind</button>`}
        //                 </td>
        //             `;
        //             dsTbody.appendChild(row);
        //         });
        //     }

        //     // PT Table
        //     const ptTbody = document.getElementById('ptTbody');
        //     ptTbody.innerHTML = '';
        //     if (ptSensors.length === 0) {
        //         ptTbody.innerHTML = '<tr><td colspan="8">No PT1000 sensors found.</td></tr>';
        //     } else {
        //         ptSensors.forEach((sensor, idx) => {
        //             const row = document.createElement('tr');
        //             row.innerHTML = `
        //                 <td>${idx+1}</td>
        //                 <td>${sensor.name || ''}</td>
        //                 <td class="chip-select">${sensor.chipSelectPin !== undefined ? sensor.chipSelectPin : ''}</td>
        //                 <td>${sensor.currentTemp !== undefined ? sensor.currentTemp : ''}</td>
        //                 <td>${sensor.minTemp !== undefined ? sensor.minTemp : ''}</td>
        //                 <td>${sensor.maxTemp !== undefined ? sensor.maxTemp : ''}</td>
        //                 <td>
        //                     ${sensor.boundPoint !== null && sensor.boundPoint !== undefined
        //                         ? `<span class="status-bound">#${sensor.boundPoint}</span>`
        //                         : `<span class="status-unbound">Unbound</span>`}
        //                 </td>
        //                 <td>
        //                     ${sensor.boundPoint === null || sensor.boundPoint === undefined
        //                         ? `<button onclick="bindPrompt('PT1000','${sensor.chipSelectPin}')">Bind</button>`
        //                         : `<button onclick="unbindSensor('PT1000','${sensor.chipSelectPin}')">Unbind</button>`}
        //                 </td>
        //             `;
        //             ptTbody.appendChild(row);
        //         });
        //     }
        // }

        function renderSensorTables(sensors) {
    // Separate DS and PT
    const dsSensors = sensors.filter(s => s.type === "DS18B20");
    const ptSensors = sensors.filter(s => s.type === "PT1000");

    // Helper functions to interpret status bitmasks
    function getErrorText(errorStatus) {
        if (errorStatus === 0) return '';
        
        const errors = [];
        if (errorStatus & 0x01) errors.push('Communication Error');
        if (errorStatus & 0x02) errors.push('Out of Range');
        if (errorStatus & 0x04) errors.push('Disconnected');
        
        return errors.join(', ');
    }
    
    function getAlarmText(alarmStatus) {
        if (alarmStatus === 0) return '';
        
        const alarms = [];
        if (alarmStatus & 0x01) alarms.push('Low Temperature');
        if (alarmStatus & 0x02) alarms.push('High Temperature');
        
        return alarms.join(', ');
    }
    
    function getStatusClass(errorStatus, alarmStatus) {
        if (errorStatus > 0) return 'status-error';
        if (alarmStatus > 0) return 'status-alarm';
        return 'status-normal';
    }

    // DS Table
    const dsTbody = document.getElementById('dsTbody');
    dsTbody.innerHTML = '';
    if (dsSensors.length === 0) {
        dsTbody.innerHTML = '<tr><td colspan="10">No DS18B20 sensors found.</td></tr>';
    } else {
        dsSensors.forEach((sensor, idx) => {
            const errorText = getErrorText(sensor.errorStatus);
            const alarmText = getAlarmText(sensor.alarmStatus);
            const statusClass = getStatusClass(sensor.errorStatus, sensor.alarmStatus);
            
            const row = document.createElement('tr');
            row.className = statusClass;
            row.innerHTML = `
                <td>${idx+1}</td>
                <td>${sensor.name || ''}</td>
                <td class="rom">${sensor.romString || ''}</td>
                <td>${sensor.bus !== undefined && sensor.bus !== null ? sensor.bus : ''}</td>
                <td>${sensor.currentTemp !== undefined ? sensor.currentTemp : ''}</td>
                <td>${sensor.minTemp !== undefined ? sensor.minTemp : ''}</td>
                <td>${sensor.maxTemp !== undefined ? sensor.maxTemp : ''}</td>
                <td>
                    ${sensor.boundPoint !== null && sensor.boundPoint !== undefined
                        ? `<span class="status-bound">#${sensor.boundPoint}</span>`
                        : `<span class="status-unbound">Unbound</span>`}
                </td>
                <td class="${errorText ? 'error-cell' : ''}">${errorText}</td>
                <td class="${alarmText ? 'alarm-cell' : ''}">${alarmText}</td>
                <td>
                    ${sensor.boundPoint === null || sensor.boundPoint === undefined
                        ? `<button onclick="bindPrompt('DS18B20','${sensor.romString}')">Bind</button>`
                        : `<button onclick="unbindSensor('DS18B20','${sensor.romString}')">Unbind</button>`}
                </td>
            `;
            dsTbody.appendChild(row);
        });
    }

    // PT Table
    const ptTbody = document.getElementById('ptTbody');
    ptTbody.innerHTML = '';
    if (ptSensors.length === 0) {
        ptTbody.innerHTML = '<tr><td colspan="10">No PT1000 sensors found.</td></tr>';
    } else {
        ptSensors.forEach((sensor, idx) => {
            const errorText = getErrorText(sensor.errorStatus);
            const alarmText = getAlarmText(sensor.alarmStatus);
            const statusClass = getStatusClass(sensor.errorStatus, sensor.alarmStatus);
            
            const row = document.createElement('tr');
            row.className = statusClass;
            row.innerHTML = `
                <td>${idx+1}</td>
                <td>${sensor.name || ''}</td>
                <td class="chip-select">${sensor.chipSelectPin !== undefined ? sensor.chipSelectPin : ''}</td>
                <td>${sensor.bus !== undefined && sensor.bus !== null ? sensor.bus : ''}</td>
                <td>${sensor.currentTemp !== undefined ? sensor.currentTemp : ''}</td>
                <td>${sensor.minTemp !== undefined ? sensor.minTemp : ''}</td>
                <td>${sensor.maxTemp !== undefined ? sensor.maxTemp : ''}</td>
                <td>
                    ${sensor.boundPoint !== null && sensor.boundPoint !== undefined
                        ? `<span class="status-bound">#${sensor.boundPoint}</span>`
                        : `<span class="status-unbound">Unbound</span>`}
                </td>
                <td class="${errorText ? 'error-cell' : ''}">${errorText}</td>
                <td class="${alarmText ? 'alarm-cell' : ''}">${alarmText}</td>
                <td>
                    ${sensor.boundPoint === null || sensor.boundPoint === undefined
                        ? `<button onclick="bindPrompt('PT1000','${sensor.chipSelectPin}')">Bind</button>`
                        : `<button onclick="unbindSensor('PT1000','${sensor.chipSelectPin}')">Unbind</button>`}
                </td>
            `;
            ptTbody.appendChild(row);
        });
    }
}


        // Prompt user for measurement point to bind
        function bindPrompt(type, id) {
            let point = prompt("Enter Measurement Point address to bind:");
            if (point === null || point.trim() === "") return;
            point = parseInt(point, 10);
            if (isNaN(point)) {
                alert("Invalid address!");
                return;
            }
            bindSensor(type, id, point);
        }

        // Bind sensor to point
        function bindSensor(type, id, pointAddress) {
            let payload = { pointAddress };
            if (type === "DS18B20") payload.romString = id;
            else if (type === "PT1000") payload.chipSelect = parseInt(id, 10);
            fetch('/api/sensor-bind', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            }).then(res => {
                if (res.ok) fetchSensors();
                else alert("Failed to bind sensor");
            });
        }

        // Unbind sensor
        function unbindSensor(type, id) {
            let payload = {};
            if (type === "DS18B20") payload.romString = id;
            else if (type === "PT1000") payload.chipSelect = parseInt(id, 10);
            fetch('/api/sensor-unbind', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            }).then(res => {
                if (res.ok) fetchSensors();
                else alert("Failed to unbind sensor");
            });
        }

        // Discover sensors
        document.getElementById('discoverBtn').onclick = function() {
            fetch('/api/discover', { method: 'POST' })
                .then(res => {
                    if (res.ok) fetchSensors();
                    else alert("Discovery failed");
                });
        };

        // Reset min/max
        document.getElementById('resetMinMaxBtn').onclick = function() {
            fetch('/api/reset-minmax', { method: 'POST' })
                .then(res => {
                    if (res.ok) fetchSensors();
                    else alert("Reset failed");
                });
        };

        // Auto-update
        setInterval(fetchSensors, UPDATE_INTERVAL);
        window.onload = fetchSensors;
    </script>
</body>
</html>

-------- [ Separator ] ------

File Name: download_fs.py
Size: 10.69 KB
Code:
# Written by Maximilian Gerhardt <maximilian.gerhardt@rub.de>
# 29th December 2020
# and Christian Baars, Johann Obermeier
# 2023 / 2024
# License: Apache
# Expanded from functionality provided by PlatformIO's espressif32 and espressif8266 platforms, credited below.
# This script provides functions to download the filesystem (LittleFS) from a running ESP32 / ESP8266
# over the serial bootloader using esptool.py, and mklittlefs for extracting.
# run by either using the VSCode task "Custom" -> "Download Filesystem"
# or by doing 'pio run -t downloadfs' (with optional '-e <environment>') from the commandline.
# output will be saved, by default, in the "unpacked_fs" of the project.
# this folder can be changed by writing 'custom_unpack_dir = some_other_dir' in the corresponding platformio.ini
# environment.
import re
import sys
from os.path import isfile, join
from enum import Enum
import os
import subprocess
import shutil

Import("env")
platform = env.PioPlatform()
board = env.BoardConfig()
mcu = board.get("build.mcu", "esp32")


class FSType(Enum):
    LITTLEFS="littlefs"
    FATFS="fatfs"

class FSInfo:
    def __init__(self, fs_type, start, length, page_size, block_size):
        self.fs_type = fs_type
        self.start = start
        self.length = length
        self.page_size = page_size
        self.block_size = block_size
    def __repr__(self):
        return f"FS type {self.fs_type} Start {hex(self.start)} Len {self.length} Page size {self.page_size} Block size {self.block_size}"
    # extract command supposed to be implemented by subclasses
    def get_extract_cmd(self, input_file, output_dir):
        raise NotImplementedError()

class FS_Info(FSInfo):
    def __init__(self, start, length, page_size, block_size):
        self.tool = env["MKFSTOOL"]
        self.tool = join(platform.get_package_dir("tool-mklittlefs"), self.tool)
        super().__init__(FSType.LITTLEFS, start, length, page_size, block_size)
    def __repr__(self):
        return f"{self.fs_type} Start {hex(self.start)} Len {hex(self.length)} Page size {hex(self.page_size)} Block size {hex(self.block_size)}"
    def get_extract_cmd(self, input_file, output_dir):
        return f'"{self.tool}" -b {self.block_size} -s {self.length} -p {self.page_size} --unpack "{output_dir}" "{input_file}"'

# SPIFFS helpers copied from ESP32, https://github.com/platformio/platform-espressif32/blob/develop/builder/main.py
# Copyright 2014-present PlatformIO <contact@platformio.org>
# Licensed under the Apache License, Version 2.0 (the "License");

def _parse_size(value):
    if isinstance(value, int):
        return value
    elif value.isdigit():
        return int(value)
    elif value.startswith("0x"):
        return int(value, 16)
    elif value[-1].upper() in ("K", "M"):
        base = 1024 if value[-1].upper() == "K" else 1024 * 1024
        return int(value[:-1]) * base
    return value

## FS helpers for ESP8266
# copied from https://github.com/platformio/platform-espressif8266/blob/develop/builder/main.py
# Copyright 2014-present PlatformIO <contact@platformio.org>
# Licensed under the Apache License, Version 2.0 (the "License");

def _parse_ld_sizes(ldscript_path):
    assert ldscript_path
    result = {}
    # get flash size from LD script path
    match = re.search(r"\.flash\.(\d+[mk]).*\.ld", ldscript_path)
    if match:
        result['flash_size'] = _parse_size(match.group(1))

    appsize_re = re.compile(
        r"irom0_0_seg\s*:.+len\s*=\s*(0x[\da-f]+)", flags=re.I)
    filesystem_re = re.compile(
        r"PROVIDE\s*\(\s*_%s_(\w+)\s*=\s*(0x[\da-f]+)\s*\)" % "FS"
        if "arduino" in env.subst("$PIOFRAMEWORK")
        else "SPIFFS",
        flags=re.I,
    )
    with open(ldscript_path) as fp:
        for line in fp.readlines():
            line = line.strip()
            if not line or line.startswith("/*"):
                continue
            match = appsize_re.search(line)
            if match:
                result['app_size'] = _parse_size(match.group(1))
                continue
            match = filesystem_re.search(line)
            if match:
                result['fs_%s' % match.group(1)] = _parse_size(
                    match.group(2))
    return result

def esp8266_fetch_fs_size(env):
    ldsizes = _parse_ld_sizes(env.GetActualLDScript())
    for key in ldsizes:
        if key.startswith("fs_"):
            env[key.upper()] = ldsizes[key]

    assert all([
        k in env
        for k in ["FS_START", "FS_END", "FS_PAGE", "FS_BLOCK"]
    ])

    # esptool flash starts from 0
    for k in ("FS_START", "FS_END"):
        _value = 0
        if env[k] < 0x40300000:
            _value = env[k] & 0xFFFFF
        elif env[k] < 0x411FB000:
            _value = env[k] & 0xFFFFFF
            _value -= 0x200000  # correction
        else:
            _value = env[k] & 0xFFFFFF
            _value += 0xE00000  # correction

        env[k] = _value

## Script interface functions
def parse_partition_table(content):
    entries = [e for e in content.split(b'\xaaP') if len(e) > 0]
    #print("Partition data:")
    for entry in entries:
        type = entry[1]
        if type in [0x82,0x83]: # SPIFFS or LITTLEFS
            offset = int.from_bytes(entry[2:5], byteorder='little', signed=False)
            size = int.from_bytes(entry[6:9], byteorder='little', signed=False)
            #print("type:",hex(type))
            #print("address:",hex(offset))
            #print("size:",hex(size))
            env["FS_START"] = offset
            env["FS_SIZE"] = size
            env["FS_PAGE"] = int("0x100", 16)
            env["FS_BLOCK"] = int("0x1000", 16)

def get_partition_table():
    esptoolpy = join(platform.get_package_dir("tool-esptoolpy") or "", "esptool.py")
    upload_port = join(env.get("UPLOAD_PORT", "none"))
    download_speed = join(str(board.get("download.speed", "115200")))
    if "none" in upload_port:
        env.AutodetectUploadPort()
        upload_port = join(env.get("UPLOAD_PORT", "none"))
    fs_file = join(env["PROJECT_DIR"], "partition_table_from_flash.bin")
    esptoolpy_flags = [
            "--chip", mcu,
            "--port", upload_port,
            "--baud",  download_speed,
            "--before", "default_reset",
            "--after", "hard_reset",
            "read_flash",
            "0x8000",
            "0x1000",
            fs_file
    ]
    esptoolpy_cmd = [env["PYTHONEXE"], esptoolpy] + esptoolpy_flags
    try:
        returncode = subprocess.call(esptoolpy_cmd, shell=False)
    except subprocess.CalledProcessError as exc:
        print("Downloading failed with " + str(exc))
    with open(fs_file, mode="rb") as file:
        content = file.read()
        parse_partition_table(content)

def get_fs_type_start_and_length():
    platform = env["PIOPLATFORM"]
    if platform == "espressif32":
        print(f"Retrieving filesystem info for {mcu}.")
        get_partition_table()
        return FS_Info(env["FS_START"], env["FS_SIZE"], env["FS_PAGE"], env["FS_BLOCK"])
    elif platform == "espressif8266":
        print("Retrieving filesystem info for ESP8266.")
        filesystem = board.get("build.filesystem", "littlefs")
        if filesystem not in ("littlefs"):
            print("Unrecognized board_build.filesystem option '" + str(filesystem) + "'.")
            env.Exit(1)
        # fetching sizes is the same for all filesystems
        esp8266_fetch_fs_size(env)
        #print("FS_START: " + hex(env["FS_START"]))
        #print("FS_SIZE: " + hex(env["FS_END"] - env["FS_START"]))
        #print("FS_PAGE: " + hex(env["FS_PAGE"]))
        #print("FS_BLOCK: " + hex(env["FS_BLOCK"]))
        if filesystem == "littlefs":
            print("Recognized LittleFS filesystem.")
            return FS_Info(env["FS_START"], env["FS_END"] - env["FS_START"], env["FS_PAGE"], env["FS_BLOCK"])
        else:
            print("Unrecongized configuration.")
    pass

def download_fs(fs_info: FSInfo):
    print(fs_info)
    esptoolpy = join(platform.get_package_dir("tool-esptoolpy") or "", "esptool.py")
    upload_port = join(env.get("UPLOAD_PORT", "none"))
    download_speed = join(str(board.get("download.speed", "115200")))
    if "none" in upload_port:
        env.AutodetectUploadPort()
        upload_port = join(env.get("UPLOAD_PORT", "none"))
    fs_file = join(env.subst("$BUILD_DIR"), f"downloaded_fs_{hex(fs_info.start)}_{hex(fs_info.length)}.bin")
    esptoolpy_flags = [
            "--chip", mcu,
            "--port", upload_port,
            "--baud",  download_speed,
            "--before", "default_reset",
            "--after", "hard_reset",
            "read_flash",
            hex(fs_info.start),
            hex(fs_info.length),
            fs_file
    ]
    esptoolpy_cmd = [env["PYTHONEXE"], esptoolpy] + esptoolpy_flags
    print("Download filesystem image")
    try:
        returncode = subprocess.call(esptoolpy_cmd, shell=False)
        return (True, fs_file)
    except subprocess.CalledProcessError as exc:
        print("Downloading failed with " + str(exc))
        return (False, "")

def unpack_fs(fs_info: FSInfo, downloaded_file: str):
    # by writing custom_unpack_dir = some_dir in the platformio.ini, one can
    # control the unpack directory
    unpack_dir = env.GetProjectOption("custom_unpack_dir", "unpacked_fs")
    if not os.path.exists(downloaded_file):
        print(f"ERROR: {downloaded_file} with filesystem not found, maybe download failed due to download_speed setting being too high.")
        assert(0)
    try:
        if os.path.exists(unpack_dir):
            shutil.rmtree(unpack_dir)
    except Exception as exc:
        print("Exception while attempting to remove the folder '" + str(unpack_dir) + "': " + str(exc))
    if not os.path.exists(unpack_dir):
        os.makedirs(unpack_dir)

    cmd = fs_info.get_extract_cmd(downloaded_file, unpack_dir)
    print("Unpack files from filesystem image")
    try:
        returncode = subprocess.call(cmd, shell=True)
        return (True, unpack_dir)
    except subprocess.CalledProcessError as exc:
        print("Unpacking filesystem failed with " + str(exc))
        return (False, "")

def display_fs(extracted_dir):
    # extract command already nicely lists all extracted files.
    # no need to display that ourselves. just display a summary
    file_count = sum([len(files) for r, d, files in os.walk(extracted_dir)])
    print("Extracted " + str(file_count) + " file(s) from filesystem.")

def command_download_fs(*args, **kwargs):
    info = get_fs_type_start_and_length()
    download_ok, downloaded_file = download_fs(info)
    unpack_ok, unpacked_dir = unpack_fs(info, downloaded_file)
    if unpack_ok is True:
        display_fs(unpacked_dir)


env.AddCustomTarget(
    name="downloadfs",
    dependencies=None,
    actions=[
        command_download_fs
    ],
    title="Download Filesystem",
    description="Downloads and displays files stored in the target ESP32/ESP8266"
)

-------- [ Separator ] ------

File Name: include/Alarm.h
Size: 4.31 KB
Code:
#pragma once

#include <Arduino.h>
#include <vector>
#include "MeasurementPoint.h"
#include "LoggerManager.h"

// Forward declaration
class MeasurementPoint;

enum class AlarmType {
    HIGH_TEMPERATURE,    // This should be OK since it's not just "HIGH"
    LOW_TEMPERATURE,     // This should be OK since it's not just "LOW"
    SENSOR_ERROR,
    SENSOR_DISCONNECTED
};


enum class AlarmStage {
    NEW,                    // Just triggered
    CLEARED,                // Condition cleared but still in delay
    RESOLVED,                // Fully resolved
    ACKNOWLEDGED,           // Operator acknowledged
    ACTIVE                 // Confirmed and active


};

enum class AlarmPriority {
    PRIORITY_LOW,
    PRIORITY_MEDIUM,
    PRIORITY_HIGH,
    PRIORITY_CRITICAL
};


class Alarm {
public:
    // Constructor
    Alarm(AlarmType type, MeasurementPoint* source, AlarmPriority priority = AlarmPriority::PRIORITY_MEDIUM);
    
    // Destructor
    ~Alarm();
    
    // Getters
    AlarmType getType() const { return _type; }
    AlarmStage getStage() const { return _stage; }
    AlarmPriority getPriority() const { return _priority; }
    MeasurementPoint* getSource() const { return _source; }
    unsigned long getTimestamp() const { return _timestamp; }
    unsigned long getAcknowledgedTime() const { return _acknowledgedTime; }
    unsigned long getClearedTime() const { return _clearedTime; }
    String getMessage() const { return _message; }
    bool isActive() const { return _stage == AlarmStage::ACTIVE || _stage == AlarmStage::ACKNOWLEDGED; }
    bool isAcknowledged() const { return _stage == AlarmStage::ACKNOWLEDGED || _stage == AlarmStage::CLEARED; }
    bool isResolved() const { return _stage == AlarmStage::RESOLVED; }
    
    // State management
    void acknowledge();
    void clear();
    void resolve();
    void reactivate();
    
    // Update alarm condition
    bool updateCondition();
    
    // Display methods
    String getDisplayText() const;
    String getStatusText() const;
    
    // Alarm behavior configuration
    void setDelayTime(unsigned long delayMs) { _delayTime = delayMs; }
    unsigned long getDelayTime() const { return _delayTime; }
    
    // Check if delay has elapsed
    bool isDelayElapsed() const;
    
    // Comparison operators for sorting
    bool operator<(const Alarm& other) const;
    bool operator==(const Alarm& other) const;

    String getTypeString() const;
    String getStageString() const;

    // Configuration support
    String getConfigKey() const;
    void setConfigKey(const String& key);
    bool isEnabled() const { return _enabled; }
    void setEnabled(bool enabled);
    uint8_t getPointAddress() const { return _source ? _source->getAddress() : 255; }

    void setPriority(AlarmPriority priority);
    void setStage(AlarmStage stage);
    
    void setHysteresis(int16_t hysteresis);
    int16_t getHysteresis() const { return _hysteresis; }

    void setAcknowledgedDelay(unsigned long delay);
    unsigned long getAcknowledgedDelay() const;
    bool isAcknowledgedDelayElapsed() const;
    unsigned long getAcknowledgedTimeLeft() const;


    

private:
    AlarmType _type;
    AlarmStage _stage;
    AlarmPriority _priority;
    MeasurementPoint* _source;
    
    // Timestamps
    unsigned long _timestamp;        // When alarm was created
    unsigned long _acknowledgedTime; // When alarm was acknowledged
    unsigned long _clearedTime;      // When condition cleared

    int16_t _hysteresis;  // Configurable hysteresis value
    
    // Configuration
    unsigned long _delayTime;        // Delay before auto-resolve
    
    // Display message
    String _message;
    
    // Internal methods
    void _updateMessage();
    bool _checkCondition();

    String _getPriorityString() const;

    String _configKey;  // Format: "alarm_<point>_<type>"
    bool _enabled;      // Whether this alarm is active in configuration
    unsigned long _acknowledgedDelay; 
    String _getPriorityString(AlarmPriority priority) const;
};

// Alarm comparison function for sorting by priority and timestamp
struct AlarmComparator {
    bool operator()(const Alarm* a, const Alarm* b) const {
        if (a->getPriority() != b->getPriority()) {
            return static_cast<int>(a->getPriority()) > static_cast<int>(b->getPriority());
        }
        return a->getTimestamp() < b->getTimestamp();
    }
};

-------- [ Separator ] ------

File Name: include/CSVConfigManager.h
Size: 1.60 KB
Code:
#pragma once

#include <Arduino.h>
#include <CSV_Parser.h>
#include "TemperatureController.h"

class CSVConfigManager {
public:
    CSVConfigManager(TemperatureController& controller);
    
    // CSV export/import for combined points and alarms
    String exportPointsWithAlarmsToCSV();
    bool importPointsWithAlarmsFromCSV(const String& csvData);
    
    // Individual exports (if needed)
    String exportSensorsToCSV();
    bool importSensorsFromCSV(const String& csvData);
    
    // File operations
    bool saveCSVToFile(const String& filename, const String& csvData);
    String loadCSVFromFile(const String& filename);
    
    // Validation
    bool validatePointsCSV(const String& csvData);
    String getLastError() const { return _lastError; }

private:
    TemperatureController& _controller;
    String _lastError;
    
    // Helper methods
    String _escapeCSVField(const String& field);
    String _unescapeCSVField(const String& field);
    bool _parseAlarmFromCSV(int pointAddress, const String& alarmType, 
                           const String& priority, const String& enabled, 
                           const String& hysteresis);
    
    // Additional helper methods needed
    String _getAlarmTypeString(AlarmType type);
    AlarmType _parseAlarmType(const String& typeStr);
    String _getPriorityString(AlarmPriority priority);
    AlarmPriority _parsePriority(const String& priorityStr);
    void _exportPointToCSV(String& csv, MeasurementPoint* point, const String& pointType);
    bool _parseCSVLine(const String& line);
    String _getAlarmPriorityForPoint(int pointAddress, AlarmType alarmType);
};

-------- [ Separator ] ------

File Name: include/ConfigManager.h
Size: 4.10 KB
Code:
#ifndef CONFIG_MANAGER_H
#define CONFIG_MANAGER_H

#include <Arduino.h>
#include <ConfigAssist.h>
#include <ConfigAssistHelper.h>
#include <WebServer.h>
#include <LittleFS.h>
#include "TemperatureController.h"
#include "CSVConfigManager.h"
#include "SettingsCSVManager.h"
#include "LoggerManager.h" 

// YAML configuration definition
extern const char* VARIABLES_DEF_YAML;

class ConfigManager {
private:
    SettingsCSVManager settingsCSVManager;
    CSVConfigManager csvManager;
    ConfigAssist conf;
    ConfigAssistHelper* confHelper;
    TemperatureController& controller;
    WebServer* server;
    bool portalActive;
    
    // Callback function for ConfigAssist
    static void onConfigChanged(String key);
    
    // Pointer to instance for callback functions
    static ConfigManager* instance;
    void _applySettingsWithoutRestart();

    void basicAPI();
    void sensorAPI();
    void csvImportExportAPI();
    void pointsAPI();
    void alarmsAPI();
    void logsAPI();
    void downloadAPI();

    
    // Save sensor configuration to file
    //void saveSensorConfig();
    
    // Load sensor configuration from file
    //void loadSensorConfig();

public:
    ConfigManager(TemperatureController& tempController);
    ~ConfigManager();
    
    // Initialize configuration
    bool begin();
    
    // Update configuration (call in loop)
    void update();
    
    // Connect to WiFi
    bool connectWiFi(int timeoutMs = 15000);
    
    // Add sensor to configuration
    // bool addSensorToConfig(SensorType type, uint8_t address, const String& name, 
    //                       const uint8_t* romAddress = nullptr);
    
    // Remove sensor from configuration
    //bool removeSensorFromConfig(uint8_t address);
    
    // Update sensor in configuration
    // bool updateSensorInConfig(uint8_t address, const String& name, 
    //                          int16_t lowAlarm, int16_t highAlarm);
    
    // Get web server instance
    WebServer* getWebServer() { return server; }
    
    // Check if portal is active
    bool isPortalActive() { return portalActive; }
    
    // Get configuration values
    String getWifiSSID() { return conf("st_ssid"); }
    String getWifiPassword() { return conf("st_pass"); }
    String getHostname() { return conf("host_name"); }
    uint16_t getDeviceId() { return conf("device_id").toInt(); }
    uint16_t getMeasurementPeriod() { return conf("measurement_period").toInt(); }
    bool isModbusEnabled() { return conf("modbus_enabled").toInt() == 1; }
    uint8_t getModbusAddress() { return conf("modbus_address").toInt(); }
    uint32_t getModbusBaudRate() { return conf("modbus_baud_rate").toInt(); }
    uint8_t getRxPin() { return conf("rs485_rx_pin").toInt(); }
    uint8_t getTxPin() { return conf("rs485_tx_pin").toInt(); }
    //uint8_t getDePin() { return conf("rs485_de_pin").toInt(); }
    //uint8_t getOneWirePin() { return conf("onewire_pin").toInt(); }
    bool getAutoDiscover() { return conf("auto_discover").toInt() == 1; }
    
    // Reset min/max values
    void resetMinMaxValues();
    //void updateSensorInConfig(Sensor* sensor);
    // Remove:
// void saveSensorConfig();
// void loadSensorConfig();
// bool addSensorToConfig(...);
// bool removeSensorFromConfig(...);
// bool updateSensorInConfig(...);
// void updateSensorInConfig(Sensor* sensor);

    // Add:
    void savePointsConfig();
    void loadPointsConfig();
    bool updatePointInConfig(uint8_t address, const String& name, int16_t lowAlarm, int16_t highAlarm,
                            const String& ds18b20RomString = "", int pt1000ChipSelect = -1);
    
    void saveAlarmsConfig();
    void loadAlarmsConfig();

    CSVConfigManager& getCSVManager() { return csvManager; }

    uint16_t getAcknowledgedDelayCritical() { return conf("ack_delay_critical").toInt(); }
    uint16_t getAcknowledgedDelayHigh() { return conf("ack_delay_high").toInt(); }
    uint16_t getAcknowledgedDelayMedium() { return conf("ack_delay_medium").toInt(); }
    uint16_t getAcknowledgedDelayLow() { return conf("ack_delay_low").toInt(); }
    };

// Initialize static member
//ConfigManager* ConfigManager::instance = nullptr;

#endif // CONFIG_MANAGER_H

-------- [ Separator ] ------

File Name: include/IndicatorInterface.h
Size: 5.91 KB
Code:
#ifndef INDICATOR_INTERFACE_H
#define INDICATOR_INTERFACE_H

#include <Arduino.h>
#include <Wire.h>
#include <map>
#include <string>
#include "PCF8575.h"
#include <U8g2lib.h>
#include <vector>
#include "LoggerManager.h"

class IndicatorInterface {
public:
    struct BlinkingPort {
        std::string portName;
        unsigned long onTime;
        unsigned long offTime;
        unsigned long lastToggleTime;
        bool currentState;
        bool isActive;
    };
    // Constructor
    IndicatorInterface(TwoWire& i2cBus, uint8_t pcf_i2cAddress, int intPin = -1);
    
    // Destructor
    ~IndicatorInterface();
    
    // Initialization
    bool begin();
    void update();
    
    // Configuration setters
    void setDirection(uint16_t directionMask);          // 0 = input, 1 = output
    void setMode(uint16_t modeMask);                    // 0 = normal, 1 = inverted
    void setPortNames(const std::map<std::string, uint8_t>& portNames);
    void setPortName(const std::string& name, uint8_t portNumber);
    
    // Port control methods
    bool writePort(const std::string& portName, bool state);
    bool writePort(uint8_t portNumber, bool state);
    void writePorts(uint16_t portMask);                 // Write only to outputs
    void setAllOutputs(bool state);
    void setAllOutputsHigh();
    void setAllOutputsLow();
    
    void setPortInverted(const std::string& portName, bool inverted);
    void setPortInverted(uint8_t portNumber, bool inverted);

    
    // Port reading methods
    uint16_t getCurrentState();
    bool readPort(const std::string& portName);
    bool readPort(uint8_t portNumber);
    
    // Utility methods
    bool isOutput(uint8_t portNumber);
    bool isInput(uint8_t portNumber);
    bool isInverted(uint8_t portNumber);
    uint8_t getPortNumber(const std::string& portName);
    std::string getPortName(uint8_t portNumber);
    
    // Interrupt handling
    void handleInterrupt();
    void setInterruptCallback(void (*callback)(uint16_t currentState, uint16_t changedPins));
    
    // Debug methods
    void printPortStates();
    void printConfiguration();

    // OLED control methods
    void setOledSleepDelay(long sleepDelay);        // -1 = never sleep
    void setOledMode(int lines);                    // 1-5 lines
    void printText(String buffer[], int bufferSize);
    void setOLEDblink(int timeOn, int timeOff, bool blinkOn = true);
    void setOLEDOff();
    void setOLEDOn();
    void updateOLED();                              // Call this in loop for scrolling/blinking

    // Add these to the public section:
    void pushLine(String newLine);                      // Push new line, shift others down
    void displayOK();                                   // Display huge "OK"
    void displayCross();                                // Display huge cross in circle
    void blinkOK(int blinkDelay);                       // Blink between OK and previous text
    void blinkCross(int blinkDelay);                    // Blink between cross and previous text
    void stopBlinking();                                // Stop any blinking and restore text

    void startBlinking(const std::string& portName, unsigned long onTime, unsigned long offTime);
    void stopBlinking(const std::string& portName);
    void updateBlinking();
    bool isBlinking(const std::string& portName);


private:



    std::vector<BlinkingPort> _blinkingPorts;

    // Hardware configuration
    TwoWire* _i2cBus;
    uint8_t _pcf_i2cAddress;
    uint8_t oled_i2cAddress;
    int _intPin;
    PCF8575 _pcf8575;
    
    // Port configuration
    uint16_t _directionMask;    // 0 = input, 1 = output
    uint16_t _modeMask;         // 0 = normal, 1 = inverted
    std::map<std::string, uint8_t> _portNames;
    std::map<uint8_t, std::string> _portNumbers;
    
    // State tracking
    uint16_t _currentState;
    uint16_t _lastState;
    unsigned long _lastReadTime;
    unsigned long _pollInterval;
    
    // Interrupt handling
    volatile bool _interruptFlag;
    bool _useInterrupts;
    void (*_interruptCallback)(uint16_t currentState, uint16_t changedPins);
    
    // Internal methods
    void _updateState();
    void _clearInterrupt();
    uint16_t _readPCF();
    void _writePCF(uint16_t state);
    bool _applyModeLogic(uint8_t portNumber, bool state);
    bool _reverseModeLogic(uint8_t portNumber, bool state);
    void _configureInterruptPin();
    
    // Static interrupt handler
    static IndicatorInterface* _instance;
    static void IRAM_ATTR _staticInterruptHandler();
    static U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2;

    // OLED configuration
    long _oledSleepDelay;
    int _oledLines;
    String _textBuffer[5];                          // Max 5 lines
    int _textBufferSize;
    bool _oledOn;
    bool _oledBlink;
    int _blinkTimeOn;
    int _blinkTimeOff;
    unsigned long _lastBlinkTime;
    bool _blinkState;
    unsigned long _lastActivityTime;
    bool _oledSleeping;
    
    // Scrolling variables
    int _scrollOffset[5];                           // Scroll offset for each line
    unsigned long _lastScrollTime;
    int _scrollDelay;
    int _charWidth;
    int _lineHeight;
    int _maxCharsPerLine;
    
    // Internal OLED methods
    void _initOLED();
    void _updateOLEDDisplay();
    void _handleOLEDSleep();
    void _handleOLEDBlink();
    void _handleScrolling();
    void _drawTextLine(int lineIndex, int yPos);
    void _calculateDisplayParams();
    void _wakeOLED();
    //void _fixSH1106Offset();
    // Add these to the private section:
    String _savedTextBuffer[5];                         // Backup of text before OK/Cross
    int _savedTextBufferSize;
    int _savedOledLines;
    bool _isBlinkingOK;
    bool _isBlinkingCross;
    int _blinkDelayTime;
    unsigned long _lastBlinkToggle;
    bool _blinkShowSpecial;                             // true = show OK/Cross, false = show text

    // Internal methods
    void _saveCurrentText();
    void _restoreCurrentText();
    void _handleSpecialBlink();

};

#endif

-------- [ Separator ] ------

File Name: include/LoggerManager.h
Size: 9.46 KB
Code:
#ifndef LOGGERMANAGER_H
#define LOGGERMANAGER_H

#include <Arduino.h>
#include "FS.h"
#include "SD.h"
//#include "TemperatureController.h"
#include "TimeManager.h"
#include <vector>
#include "LoggerManager.h"

// Add forward declaration instead
class TemperatureController;  // Forward declaration
class MeasurementPoint;

class LoggerManager {
private:
    static LoggerManager* _instance;
    TemperatureController* _controller;
    TimeManager* _timeManager;
    fs::FS* _fs;
    
    unsigned long _logFrequency;     // Logging frequency in milliseconds
    unsigned long _lastLogTime;     // Last time data was logged
    String _currentLogFile;         // Current log file name
    bool _headerWritten;            // Flag to track if header is written
    
    // Configuration
    bool _enabled;
    String _logDirectory;
    bool _dailyFiles;               // Create new file each day
    String _lastLogDate;            // Track date for daily file creation
    
    // Private methods
    String _generateLogFileName();
    String _generateCSVHeader();
    bool _writeHeader();
    bool _writeDataRow();
    String _escapeCSVField(const String& field);
    bool _ensureDirectoryExists();
    String _getCurrentDateString();
    String _getCurrentTimeString();
    

    bool _recoverFromExistingFiles();
    String _findLatestFileForDate(const String& dateStr);
    int _extractSequenceNumber(const String& filename);
    String _readHeaderFromFile(const String& filename);
    std::vector<String> _getFilesForDate(const String& dateStr);
    int _findHighestSequenceForDate(const String& dateStr);

    // Header change detection
    String _lastGeneratedHeader;
    bool _headerChanged;
    int _fileSequenceNumber;
    
    // New private methods
    bool _hasHeaderChanged();
    String _generateLogFileNameWithSequence();
    void _incrementSequenceNumber();

    // Event logging
    bool _eventLoggingEnabled;
    String _eventLogDirectory;
    String _currentEventLogFile;
    String _lastEventLogDate;
    
    // Event logging methods
    String _generateEventLogFileName();
    bool _writeEventHeader();
    bool _writeEventRow(const String& timestamp, const String& source, 
                       const String& description, const String& priority);
    bool _ensureEventLogExists();

    // Alarm state logging
    bool _alarmStateLoggingEnabled;
    String _alarmStateLogDirectory;
    String _currentAlarmStateLogFile;
    String _lastAlarmStateLogDate;
    
    // Alarm state logging methods
    String _generateAlarmStateLogFileName();
    bool _writeAlarmStateHeader();
    bool _ensureAlarmStateLogExists();
    bool _writeAlarmStateRow(const String& timestamp, int pointNumber, const String& pointName,
        const String& alarmType, const String& alarmPriority,
        const String& previousState, const String& newState,
        int16_t currentTemp, int16_t threshold);

    
    bool _isSDCardAvailable();

    
public:
    LoggerManager(TemperatureController& controller, TimeManager& timeManager, fs::FS& filesystem);
    ~LoggerManager();

    static LoggerManager* getInstance() { return _instance; }
    
    // Add these static convenience methods
    static bool info(const String& source, const String& description) {
        return _instance ? _instance->logInfo(source, description) : false;
    }
    
    static bool warning(const String& source, const String& description) {
        return _instance ? _instance->logWarning(source, description) : false;
    }
    
    static bool error(const String& source, const String& description) {
        return _instance ? _instance->logError(source, description) : false;
    }
    
    static bool critical(const String& source, const String& description) {
        return _instance ? _instance->logCritical(source, description) : false;
    }
    
    // Initialization
    bool init(); 
    bool begin();
    
    // Configuration methods
    void setLogFrequency(unsigned long frequencyMs);
    unsigned long getLogFrequency() const;
    void setEnabled(bool enabled);
    bool isEnabled() const;
    void setDailyFiles(bool enabled);
    bool isDailyFiles() const;
    void setLogDirectory(const String& directory);
    static String getLogDirectory();
    
    // Logging methods
    void update();                  // Call this in main loop
    bool logDataNow();             // Force immediate logging
    bool createNewLogFile();       // Create new log file
    
    // File management
    String getCurrentLogFile() const;
    bool closeCurrentFile();
    static std::vector<String> getLogFiles();
    bool deleteLogFile(const String& filename);
    
    // Statistics
    unsigned long getLastLogTime() const;
    size_t getLogFileSize() const;
    
    // Error handling
    String getLastError() const;

    void forceNewFile();
    int getCurrentSequenceNumber() const;
    void resetSequenceNumber();

        // Event logging configuration
        void setEventLoggingEnabled(bool enabled);
        bool isEventLoggingEnabled() const;
        void setEventLogDirectory(const String& directory);
        String getEventLogDirectory() const;
        
        // Event logging methods
        bool logEvent(const String& source, const String& description, const String& priority = "INFO");
        bool logInfo(const String& source, const String& description);
        bool logWarning(const String& source, const String& description);
        bool logError(const String& source, const String& description);
        bool logCritical(const String& source, const String& description);
        
        // Event log management
        String getCurrentEventLogFile() const;
        std::vector<String> getEventLogFiles();
        bool deleteEventLogFile(const String& filename);


    // Alarm state logging configuration
    void setAlarmStateLoggingEnabled(bool enabled);
    bool isAlarmStateLoggingEnabled() const;
    void setAlarmStateLogDirectory(const String& directory);
    String getAlarmStateLogDirectory() const;
    
    // Static method for alarm state logging
    static bool logAlarmStateChange(int pointNumber, const String& pointName, 
                                   const String& alarmType, const String& alarmPriority,
                                   const String& previousState, const String& newState,
                                   int16_t currentTemp, int16_t threshold);
    
    // Instance method for alarm state logging
    bool logAlarmState(int pointNumber, const String& pointName, 
                      const String& alarmType, const String& alarmPriority,
                      const String& previousState, const String& newState,
                      int16_t currentTemp, int16_t threshold);
    
    // Alarm state log management
    String getCurrentAlarmStateLogFile() const;
    //static std::vector<String> getAlarmStateLogFiles();
    bool deleteAlarmStateLogFile(const String& filename);

        // Static alarm history retrieval methods
    // static String getAlarmHistoryJson(const String& startDate, const String& endDate);
    // static String getAlarmHistoryCsv(const String& startDate, const String& endDate);
    
    // Event log retrieval methods
    // static String getEventLogsJson(const String& startDate, const String& endDate);
    // static String getEventLogsCsv(const String& startDate, const String& endDate);

    // Static event log retrieval methods
    static String getEventLogsJson(const String& startDate, const String& endDate);
    static String getEventLogsCsv(const String& startDate, const String& endDate);
    static String getEventLogStatsJson(const String& startDate, const String& endDate);
    //static std::vector<String> getEventLogFilesStatic();
    
    // Static alarm history retrieval methods (already existing)
    static String getAlarmHistoryJson(const String& startDate, const String& endDate);
    static String getAlarmHistoryCsv(const String& startDate, const String& endDate);

    // Static methods for file operations
    //static std::vector<String> getLogFiles();
    static std::vector<String> getEventLogFilesStatic();
    static std::vector<String> getAlarmStateLogFiles();
    
    // Static methods for file information
    static bool getFileInfo(const String& filename, const String& type, size_t& fileSize, String& date);
    
    // Static methods for file streaming
    static File openLogFile(const String& filename, const String& type);
    static String getLogDirectoryPath(const String& type);
    
    
private:
    String _lastError;
    // Make helper methods static too
    // static std::vector<String> _getAlarmLogFilesInRange(const String& startDate, const String& endDate);
    // static bool _parseAlarmStateLogEntry(const String& line, DynamicJsonDocument& entry);
    // static String _normalizeDate(const String& dateStr);

    // Helper methods for event logs
    // static std::vector<String> _getEventLogFilesInRange(const String& startDate, const String& endDate);
    // static bool _parseEventLogEntry(const String& line, DynamicJsonDocument& entry);

    // Static helper methods for event logs
    static std::vector<String> _getEventLogFilesInRange(const String& startDate, const String& endDate);
    static bool _parseEventLogEntry(const String& line, DynamicJsonDocument& entry);
    
    // Make existing helper methods static too (if not already)
    static std::vector<String> _getAlarmLogFilesInRange(const String& startDate, const String& endDate);
    static bool _parseAlarmStateLogEntry(const String& line, DynamicJsonDocument& entry);
    static String _normalizeDate(const String& dateStr);
};

#endif // LOGGERMANAGER_H

-------- [ Separator ] ------

File Name: include/MeasurementPoint.h
Size: 1.93 KB
Code:
#ifndef MEASUREMENT_POINT_H
#define MEASUREMENT_POINT_H

#include <Arduino.h>
#include "Sensor.h"
#include "LoggerManager.h"



class MeasurementPoint {
public:
    // Constructor
    MeasurementPoint() : address(0), name(""), currentTemp(0), minTemp(32767), maxTemp(-32768),
    lowAlarmThreshold(-10), highAlarmThreshold(50), alarmStatus(0), errorStatus(0), boundSensor(nullptr) {}
    MeasurementPoint(uint8_t address, const String& name);

    // Destructor
    ~MeasurementPoint();

    // Getters
    uint8_t getAddress() const;
    String getName() const;
    int16_t getCurrentTemp() const;
    int16_t getMinTemp() const;
    int16_t getMaxTemp() const;
    int16_t getLowAlarmThreshold() const;
    int16_t getHighAlarmThreshold() const;
    uint8_t getAlarmStatus() const;
    uint8_t getErrorStatus() const;

    // Setters
    void setName(const String& newName);
    void setLowAlarmThreshold(int16_t threshold);
    void setHighAlarmThreshold(int16_t threshold);

    // Sensor binding (optional)
    void bindSensor(Sensor* sensor);
    void unbindSensor();
    Sensor* getBoundSensor() const;

    // Operations
    void update();              // Should be called to refresh temperature and status
    void resetMinMaxTemp();     // Resets min/max to current
    // void setOneWireBus(uint8_t bus);
    // uint8_t getOneWireBus();

private:
    uint8_t address;
    String name;
    // uint8_t oneWireBus;

    int16_t currentTemp;        // Latest temperature (¬∞C x1)
    int16_t minTemp;            // Minimum recorded temperature
    int16_t maxTemp;            // Maximum recorded temperature
    int16_t lowAlarmThreshold;  // Alarm threshold low
    int16_t highAlarmThreshold; // Alarm threshold high
    uint8_t alarmStatus;        // Alarm status bits
    uint8_t errorStatus;        // Error status bits

    Sensor* boundSensor;        // Pointer to bound sensor, or nullptr

    void updateAlarmStatus();
};


#endif // TEMPERATURE_CONTROLLER_H

-------- [ Separator ] ------

File Name: include/RegisterMap.h
Size: 3.92 KB
Code:
#ifndef REGISTER_MAP_H
#define REGISTER_MAP_H

#include <stdint.h>
#include "MeasurementPoint.h"

class RegisterMap {
private:
    // Device Information Registers (0-99)
    uint16_t deviceId;
    uint16_t firmwareVersion;
    uint16_t numActiveDS18B20;
    uint16_t numActivePT1000;
    uint16_t deviceStatus[7]; // Registers 4-10

    // Temperature Data Registers (100-599)
    int16_t currentTemps[60];    // 100-159
    int16_t minTemps[60];        // 200-259
    int16_t maxTemps[60];        // 300-359
    uint16_t alarmStatus[60];    // 400-459
    uint16_t errorStatus[60];    // 500-559

    // Configuration Registers (600-799)
    int16_t lowAlarmThresholds[60];  // 600-659
    int16_t highAlarmThresholds[60]; // 700-759

    // Helpers
    bool isValidAddress(uint16_t address);
    bool isReadOnlyRegister(uint16_t address);

public:
    RegisterMap();

    // Register read/write
    uint16_t readHoldingRegister(uint16_t address);
    bool writeHoldingRegister(uint16_t address, uint16_t value);

    // Update register map from measurement point data
    void updateFromMeasurementPoint(const MeasurementPoint& point);

    // Apply config (thresholds) to and from measurement points
    void applyConfigToMeasurementPoint(MeasurementPoint& point);
    void applyConfigFromMeasurementPoint(const MeasurementPoint& point);

    // Utility methods for device info
    void incrementActiveDS18B20() { numActiveDS18B20++; }
    void decrementActiveDS18B20() { if (numActiveDS18B20 > 0) numActiveDS18B20--; }
    void incrementActivePT1000() { numActivePT1000++; }
    void decrementActivePT1000() { if (numActivePT1000 > 0) numActivePT1000--; }

    uint16_t getDeviceId() const { return deviceId; }
    uint16_t getFirmwareVersion() const { return firmwareVersion; }
    uint16_t getNumActiveDS18B20() const { return numActiveDS18B20; }
    uint16_t getNumActivePT1000() const { return numActivePT1000; }

    // Register address constants (as in your original code)
    static const uint16_t DEVICE_ID_REG = 0;
    static const uint16_t FIRMWARE_VERSION_REG = 1;
    static const uint16_t NUM_DS18B20_REG = 2;
    static const uint16_t NUM_PT1000_REG = 3;
    static const uint16_t DEVICE_STATUS_START_REG = 4;
    static const uint16_t DEVICE_STATUS_END_REG = 10;
    static const uint16_t CURRENT_TEMP_DS18B20_START_REG = 100;
    static const uint16_t CURRENT_TEMP_DS18B20_END_REG = 149;
    static const uint16_t CURRENT_TEMP_PT1000_START_REG = 150;
    static const uint16_t CURRENT_TEMP_PT1000_END_REG = 159;
    static const uint16_t MIN_TEMP_DS18B20_START_REG = 200;
    static const uint16_t MIN_TEMP_DS18B20_END_REG = 249;
    static const uint16_t MIN_TEMP_PT1000_START_REG = 250;
    static const uint16_t MIN_TEMP_PT1000_END_REG = 259;
    static const uint16_t MAX_TEMP_DS18B20_START_REG = 300;
    static const uint16_t MAX_TEMP_DS18B20_END_REG = 349;
    static const uint16_t MAX_TEMP_PT1000_START_REG = 350;
    static const uint16_t MAX_TEMP_PT1000_END_REG = 359;
    static const uint16_t ALARM_STATUS_DS18B20_START_REG = 400;
    static const uint16_t ALARM_STATUS_DS18B20_END_REG = 449;
    static const uint16_t ALARM_STATUS_PT1000_START_REG = 450;
    static const uint16_t ALARM_STATUS_PT1000_END_REG = 459;
    static const uint16_t ERROR_STATUS_DS18B20_START_REG = 500;
    static const uint16_t ERROR_STATUS_DS18B20_END_REG = 549;
    static const uint16_t ERROR_STATUS_PT1000_START_REG = 550;
    static const uint16_t ERROR_STATUS_PT1000_END_REG = 559;
    static const uint16_t LOW_ALARM_DS18B20_START_REG = 600;
    static const uint16_t LOW_ALARM_DS18B20_END_REG = 649;
    static const uint16_t LOW_ALARM_PT1000_START_REG = 650;
    static const uint16_t LOW_ALARM_PT1000_END_REG = 659;
    static const uint16_t HIGH_ALARM_DS18B20_START_REG = 700;
    static const uint16_t HIGH_ALARM_DS18B20_END_REG = 749;
    static const uint16_t HIGH_ALARM_PT1000_START_REG = 750;
    static const uint16_t HIGH_ALARM_PT1000_END_REG = 759;
};

#endif // REGISTER_MAP_H

-------- [ Separator ] ------

File Name: include/Sensor.h
Size: 2.54 KB
Code:
#ifndef SENSOR_H
#define SENSOR_H

#include <Arduino.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <Adafruit_MAX31865.h>

// Define your sensor types
enum class SensorType {
    DS18B20,
    PT1000
};

// Error and alarm bitmasks
constexpr uint8_t ERROR_COMMUNICATION = 0x01;
constexpr uint8_t ERROR_OUT_OF_RANGE  = 0x02;
constexpr uint8_t ERROR_DISCONNECTED  = 0x04;

constexpr uint8_t ALARM_LOW_TEMP  = 0x01;
constexpr uint8_t ALARM_HIGH_TEMP = 0x02;

class Sensor {
public:
    Sensor(SensorType type, uint8_t address, const String& name);
    ~Sensor();

    // Setup methods for each sensor type
    void setupDS18B20(uint8_t pin, const uint8_t* deviceAddress);
    void setupPT1000(uint8_t csPin, uint8_t maxAddress);

    // Initialize hardware
    bool initialize();

    // Read temperature from the sensor, update internal state
    bool readTemperature();

    // Accessors
    SensorType getType() const;
    uint8_t getAddress() const;
    String getName() const;
    void setName(const String& newName);

    int16_t getCurrentTemp() const;
    int16_t getMinTemp() const;
    int16_t getMaxTemp() const;
    int16_t getLowAlarmThreshold() const;
    int16_t getHighAlarmThreshold() const;
    uint8_t getAlarmStatus() const;
    uint8_t getErrorStatus() const;
    uint8_t getPT1000ChipSelectPin() const;
    

    void setAddress(uint8_t newAddress);
    void setLowAlarmThreshold(int16_t threshold);
    void setHighAlarmThreshold(int16_t threshold);

    // DS18B20 ROM address accessor
    const uint8_t* getDS18B20Address() const;

    // Reset min/max values
    void resetMinMaxTemp();

    // Update alarm status (call after reading temperature or changing thresholds)
    void updateAlarmStatus();
    String getDS18B20RomString() const;        // ROM as hex string
    void getDS18B20RomArray(uint8_t out[8]) const; // ROM as array
    uint8_t getOneWirePin() {return connection.ds18b20.oneWirePin;}

private:
    uint8_t address;
    String name;
    SensorType type;

    int16_t currentTemp;
    int16_t minTemp;
    int16_t maxTemp;
    int16_t lowAlarmThreshold;
    int16_t highAlarmThreshold;
    uint8_t alarmStatus;
    uint8_t errorStatus;

    // Hardware-specific members
    OneWire* oneWire;
    DallasTemperature* dallasTemperature;
    Adafruit_MAX31865* max31865;

    // Connection details
    union {
        struct {
            uint8_t oneWirePin;
            uint8_t oneWireAddress[8];
        } ds18b20;
        struct {
            uint8_t csPin;
            uint8_t maxAddress;
        } pt1000;
    } connection;
};

#endif // SENSOR_H

-------- [ Separator ] ------

File Name: include/SettingsCSVManager.h
Size: 826 B
Code:
#pragma once

#include <Arduino.h>
#include "ConfigAssist.h"

class SettingsCSVManager {
public:
    SettingsCSVManager(ConfigAssist& config);
    
    // CSV export/import for settings
    String exportSettingsToCSV();
    bool importSettingsFromCSV(const String& csvData);
    
    // Validation
    bool validateSettingsCSV(const String& csvData);
    String getLastError() const { return _lastError; }

private:
    ConfigAssist& _config;
    String _lastError;
    
    // Helper methods
    String _escapeCSVField(const String& field);
    String _unescapeCSVField(const String& field);
    bool _parseCSVLine(const String& line);
    
    // Add these helper methods for acknowledged delays
    void _exportAcknowledgedDelays(String& csv);
    bool _importAcknowledgedDelays(const String& key, const String& value);
};

-------- [ Separator ] ------

File Name: include/TempModbusServer.h
Size: 1.01 KB
Code:
#ifndef TEMP_MODBUS_SERVER_H
#define TEMP_MODBUS_SERVER_H

#include <Arduino.h>
#include "ModbusServerRTU.h"
#include "RegisterMap.h"
#include "LoggerManager.h"

class TempModbusServer {
private:
    ModbusServerRTU* mbServer;
    RegisterMap& registerMap;
    uint8_t serverID;
    HardwareSerial& serial;
    int rxPin;
    int txPin;
    int dePin;
    int baudRate;
    
    // Worker functions for different Modbus function codes
    static ModbusMessage readHoldingRegistersWorker(ModbusMessage request);
    static ModbusMessage writeHoldingRegisterWorker(ModbusMessage request);
    static ModbusMessage writeMultipleRegistersWorker(ModbusMessage request);
    
    // Pointer to the RegisterMap instance for static worker functions
    static RegisterMap* registerMapPtr;

public:
    TempModbusServer(RegisterMap& regMap, uint8_t id, HardwareSerial& serialPort, 
                 int rx, int tx, int de, int baud = 9600);
    ~TempModbusServer();
    
    bool begin();
    void stop();
};



#endif // TEMP_MODBUS_SERVER_H

-------- [ Separator ] ------

File Name: include/TemperatureController.h
Size: 7.79 KB
Code:
#pragma once

#include <Arduino.h>
#include <vector>
#include "Sensor.h"
#include "MeasurementPoint.h"
#include "RegisterMap.h"
#include "IndicatorInterface.h"
#include "Alarm.h"
#include <OneWire.h>
#include <DallasTemperature.h>
#include <ArduinoJson.h>
#include <algorithm>

class TemperatureController {
public:
    TemperatureController(uint8_t oneWirePin[4], uint8_t csPin[4], IndicatorInterface& indicator);

    

    ~TemperatureController();
    
    bool begin();
    
    // Measurement point management
    MeasurementPoint* getMeasurementPoint(uint8_t address);
    MeasurementPoint* getDS18B20Point(uint8_t idx);
    MeasurementPoint* getPT1000Point(uint8_t idx);
    
    // Sensor management
    bool addSensor(Sensor* sensor);
    bool removeSensorByRom(const String& romString);
    Sensor* findSensorByRom(const String& romString);
    Sensor* findSensorByChipSelect(uint8_t csPin);
    int getSensorCount() const { return sensors.size(); }
    Sensor* getSensorByIndex(int idx);
    
    // Sensor binding
    bool bindSensorToPointByRom(const String& romString, uint8_t pointAddress);
    bool bindSensorToPointByChipSelect(uint8_t csPin, uint8_t pointAddress);
    bool unbindSensorFromPoint(uint8_t pointAddress);
    Sensor* getBoundSensor(uint8_t pointAddress);
    bool unbindSensorFromPointBySensor(Sensor* sensor);
    
    // Main update and measurement
    void update();
    void readAllPoints();
    void updateRegisterMap();
    void applyConfigFromRegisterMap();
    void applyConfigToRegisterMap();
    
    // Sensor discovery
    bool discoverDS18B20Sensors();
    bool discoverPTSensors();
    
    // JSON output
    String getSensorsJson();
    String getPointsJson();
    String getSystemStatusJson();
    
    // Utility functions
    void resetMinMaxValues();
    RegisterMap& getRegisterMap() { return registerMap; }
    
    // Configuration
    void setDeviceId(uint16_t id);
    uint16_t getDeviceId() const;
    void setFirmwareVersion(uint16_t version);
    uint16_t getFirmwareVersion() const;
    void setMeasurementPeriod(uint16_t seconds);
    uint16_t getMeasurementPeriod() const;
    void setOneWireBusPin(uint8_t pin, size_t idx);
    uint8_t getOneWirePin(size_t bus);
    
    // Statistics
    int getDS18B20Count() const;
    int getPT1000Count() const;
    void updateAllSensors();
    int getSensorBus(Sensor* sensor);
    
    // New Alarm Management
    void updateAlarms();
    String getAlarmsJson();
    void handleAlarmDisplay();
    void handleAlarmOutputs();

    std::vector<Alarm*> getActiveAlarms() const;
    void createAlarm(AlarmType type, MeasurementPoint* source, AlarmPriority priority);
    Alarm* getHighestPriorityAlarm() const;
    void acknowledgeHighestPriorityAlarm();
    void acknowledgeAllAlarms();
    void clearResolvedAlarms();
    void clearConfiguredAlarms();

    // Alarm management (similar to sensor management)
    bool addAlarm(AlarmType type, uint8_t pointAddress, AlarmPriority priority);
    bool removeAlarm(const String& configKey);
    bool updateAlarm(const String& configKey, AlarmPriority priority, bool enabled);
    Alarm* findAlarm(const String& configKey);
    Alarm* getAlarmByIndex(int idx);
    int getAlarmCount() const { return _configuredAlarms.size(); }
    std::vector<Alarm*> getConfiguredAlarms() const { return _configuredAlarms; }

    // JSON output (similar to getSensorsJson, getPointsJson)
    //String getAlarmsJson();

    // Alarm handling scenarios (placeholders)
    void handleCriticalAlarms();
    void handleHighPriorityAlarms();
    void handleMediumPriorityAlarms();
    void handleLowPriorityAlarms();

    bool bindSensorToPointByBusNumber(uint8_t busNumber, uint8_t pointAddress);


    // Setters for acknowledged delays
    void setAcknowledgedDelayCritical(unsigned long delay);
    void setAcknowledgedDelayHigh(unsigned long delay);
    void setAcknowledgedDelayMedium(unsigned long delay);
    void setAcknowledgedDelayLow(unsigned long delay);
    
    // Getters for acknowledged delays
    unsigned long getAcknowledgedDelayCritical() const;
    unsigned long getAcknowledgedDelayHigh() const;
    unsigned long getAcknowledgedDelayMedium() const;
    unsigned long getAcknowledgedDelayLow() const;
    
    // Method to apply delays to existing alarms
    void applyAcknowledgedDelaysToAlarms();

    // int getAlarmCount(AlarmPriority priority) const;
    // int getAlarmCount(AlarmStage stage) const;
    int getAlarmCount(AlarmPriority priority, AlarmStage stage) const;
    // Add these method declarations to TemperatureController.h
    int getAlarmCount(AlarmPriority priority, const String& comparison = "==") const;
    int getAlarmCount(AlarmStage stage, const String& comparison = "==") const;
    int getAlarmCount(AlarmPriority priority, AlarmStage stage, const String& priorityComparison = "==", const String& stageComparison = "==") const;






private:
    // Hardware components
    IndicatorInterface& indicator;
    OneWire* oneWireBuses[4];
    DallasTemperature* dallasSensors[4];
    
    // Measurement points and sensors
    MeasurementPoint dsPoints[50];
    MeasurementPoint ptPoints[10];
    std::vector<Sensor*> sensors;
    
    // System configuration
    RegisterMap registerMap;
    uint16_t measurementPeriodSeconds;
    uint16_t deviceId;
    uint16_t firmwareVersion;
    unsigned long lastMeasurementTime;
    bool systemInitialized;
    uint8_t oneWireBusPin[4];
    uint8_t chipSelectPin[4];
    
    // Alarm system
    //std::vector<Alarm*> _alarms;
    std::vector<Alarm*> _configuredAlarms; 
    unsigned long _lastAlarmCheck;
    const unsigned long _alarmCheckInterval = 1000; // Check every second
    bool _lastButtonState;
    unsigned long _lastButtonPressTime;
    const unsigned long _buttonDebounceDelay = 200;
    
    // Display management
    Alarm* _currentDisplayedAlarm;
    unsigned long _okDisplayStartTime;
    bool _showingOK;
    
    // Internal methods
    bool isDS18B20Address(uint8_t address) const { return address < 50; }
    bool isPT1000Address(uint8_t address) const { return address >= 50 && address < 60; }
    
    // Alarm helper methods
    void _checkPointForAlarms(MeasurementPoint* point);
    bool _hasAlarmForPoint(MeasurementPoint* point, AlarmType type);
    void _checkButtonPress();
    void _updateNormalDisplay();
    void _showOKAndTurnOffOLED();

    unsigned long _acknowledgedDelayCritical;
    unsigned long _acknowledgedDelayHigh;
    unsigned long _acknowledgedDelayMedium;
    unsigned long _acknowledgedDelayLow;

    bool _relay1State = false;
    bool _relay2State = false;
    bool _redLedState = false;
    bool _yellowLedState = false;
    bool _blueLedState = false;

    bool _comparePriority(AlarmPriority alarmPriority, AlarmPriority targetPriority, const String& comparison) const;
    bool _compareStage(AlarmStage alarmStage, AlarmStage targetStage, const String& comparison) const;

    // Blinking control for low priority alarms
    bool _lowPriorityBlinkState = false;
    unsigned long _lastLowPriorityBlinkTime = 0;
    const unsigned long _blinkOnTime = 2000;   // 2 seconds on
    const unsigned long _blinkOffTime = 30000; // 30 seconds off
    void _handleLowPriorityBlinking();


    // Display management for alarms
    std::vector<Alarm*> _activeAlarmsQueue;
    std::vector<Alarm*> _acknowledgedAlarmsQueue;
    int _currentActiveAlarmIndex;
    int _currentAcknowledgedAlarmIndex;
    unsigned long _lastAlarmDisplayTime;
    unsigned long _acknowledgedAlarmDisplayDelay;
    bool _displayingActiveAlarm;
    
    // Helper methods for alarm display
    void _updateAlarmQueues();
    void _displayNextActiveAlarm();
    void _displayNextAcknowledgedAlarm();
    void _handleAlarmDisplayRotation();

    String _getPriorityString(AlarmPriority priority) const; 


    String _getAlarmTypeString(AlarmType type) const;
    
    //String _getPriorityString(AlarmPriority priority) const;

    
};

-------- [ Separator ] ------

File Name: include/TimeManager.h
Size: 2.88 KB
Code:
#pragma once

#include <Arduino.h>
#include <WiFi.h>
#include <Wire.h>
#include <RTClib.h>
#include <NTPClient.h>
#include <WiFiUdp.h>
#include <ArduinoJson.h>

class TimeManager {
public:
    // Constructor
    TimeManager(int sdaPin = 21, int sclPin = 22);
    
    // Destructor
    ~TimeManager();
    
    // Initialization
    bool begin();
    bool init();
    
    // Time setting methods
    bool setTimeFromNTP(const char* ntpServer = "pool.ntp.org");
    bool setTime(int year, int month, int day, int hour, int minute, int second);
    bool setTime(DateTime dateTime);
    bool setTimeFromUnix(uint32_t unixTime);
    bool setTimeFromCompileTime();
    
    // Time getting methods
    DateTime getCurrentTime();
    String getFormattedTime(const String& format = "YYYY-MM-DD hh:mm:ss");
    String getTimeString();
    String getDateString();
    uint32_t getUnixTime();
    
    // Timezone management
    void setTimezone(int offsetHours, int offsetMinutes = 0);
    void setTimezoneOffset(long offsetSeconds);
    int getTimezoneHours();
    int getTimezoneMinutes();
    long getTimezoneOffset();
    
    // WiFi and NTP configuration
    void setNTPServer(const String& server);
    void setNTPUpdateInterval(unsigned long intervalMs);
    String getNTPServer();
    
    // Update methods (call in loop)
    void update();
    bool syncWithNTP();
    bool isNTPSyncEnabled();
    void enableNTPSync(bool enable);
    
    // Status methods
    bool isRTCConnected();
    bool isTimeSet();
    bool hasLostPower();
    unsigned long getLastNTPSync();
    float getTemperature(); // From DS3231 built-in sensor
    
    // Alarm functionality
    bool setAlarm1(DateTime alarmTime, Ds3231Alarm1Mode mode = DS3231_A1_Hour);
    bool setAlarm2(DateTime alarmTime, Ds3231Alarm2Mode mode = DS3231_A2_Hour);
    bool clearAlarm1();
    bool clearAlarm2();
    bool isAlarm1Triggered();
    bool isAlarm2Triggered();
    
    // Square wave output
    void enableSquareWave(Ds3231SqwPinMode mode = DS3231_SquareWave1Hz);
    void disableSquareWave();
    
    // JSON output for web interface
    String getTimeJSON();
    String getStatusJSON();
    
    // Configuration save/load
    void saveConfig();
    void loadConfig();

private:
    // Hardware
    RTC_DS3231 _rtc;
    WiFiUDP _ntpUDP;
    NTPClient* _timeClient;
    
    // Configuration
    int _sdaPin;
    int _sclPin;
    long _timezoneOffset;  // Offset in seconds
    String _ntpServer;
    unsigned long _ntpUpdateInterval;
    bool _ntpSyncEnabled;
    
    // Status tracking
    bool _rtcConnected;
    bool _timeSet;
    unsigned long _lastNTPSync;
    unsigned long _lastNTPAttempt;
    
    // Internal methods
    void _initializeNTP();
    bool _isWiFiConnected();
    void _updateFromNTP();
    DateTime _applyTimezone(DateTime utcTime);
    DateTime _removeTimezone(DateTime localTime);
    String _formatDateTime(DateTime dt, const String& format);
};

-------- [ Separator ] ------

File Name: platformio.ini
Size: 1.02 KB
Code:
[env:esp-wrover-kit]
platform = espressif32
board = esp-wrover-kit
framework = arduino
monitor_speed = 115200
build_flags = 
    -DBOARD_HAS_PSRAM -mfix-esp32-psram-cache-issue
    -DCA_USE_LITTLEFS       ; Use littlefs remove for spiffs
    -DLOGGER_LOG_LEVEL=3
    -DCA_USE_WIFISCAN=1
    -DCA_USE_TESTWIFI=1
board_build.partitions = huge_app.csv
board_build.filesystem = littlefs
lib_ldf_mode = chain+
lib_deps = 
    adafruit/Adafruit MAX31865 library
    Wire
    WiFi
    OneWire
    https://github.com/me-no-dev/ESPAsyncWebServer.git#master
    me-no-dev/AsyncTCP
    bblanchon/ArduinoJson
    paulstoffregen/OneWire
    milesburton/DallasTemperature
    ModbusClient=https://github.com/eModbus/eModbus.git
    #https://github.com/s00500/ESPUI.git#fix_littlefs_esp32
    # Replace WebConfig with ConfigAssist
    https://github.com/gemi254/ConfigAssist.git
    robtillaart/PCF8575
    olikraus/U8g2
    https://github.com/michalmonday/CSV-Parser-for-Arduino
    adafruit/RTClib
    arduino-libraries/NTPClient

extra_scripts = download_fs.py
-------- [ Separator ] ------

File Name: src/Alarm.cpp
Size: 24.84 KB
Code:
#include "Alarm.h"
#include "LoggerManager.h" 

// Alarm::Alarm(AlarmType type, MeasurementPoint* source, AlarmPriority priority)
//     : _type(type), _stage(AlarmStage::NEW), _priority(priority), _source(source),
//       _timestamp(millis()), _acknowledgedTime(0), _clearedTime(0),
//       _acknowledgedDelay(10 * 60 * 1000), // Default 10 minutes 
//       _delayTime(5 * 60 * 1000), _enabled(true), _hysteresis(1) // Add _hysteresis(1) - 1 degree default
// {
//     if (_source) {
//         _configKey = "alarm_" + String(_source->getAddress()) + "_" + String(static_cast<int>(_type));
//     }

//     _updateMessage();
    
//     Serial.printf("New alarm created: %s for point %d (%s)\n", 
//                   getTypeString().c_str(), 
//                   _source ? _source->getAddress() : -1,
//                   _source ? _source->getName().c_str() : "Unknown");
// }

Alarm::Alarm(AlarmType type, MeasurementPoint* source, AlarmPriority priority)
    : _type(type), _stage(AlarmStage::NEW), _priority(priority), _source(source),
      _timestamp(millis()), _acknowledgedTime(0), _clearedTime(0),
      _acknowledgedDelay(10 * 60 * 1000), _delayTime(5 * 60 * 1000), 
      _enabled(true), _hysteresis(1)
{
    if (_source) {
        _configKey = "alarm_" + String(_source->getAddress()) + "_" + String(static_cast<int>(_type));
    }

    _updateMessage();
    
    // LOG: Alarm creation
    String source_ = "ALARM_" + String(_source ? _source->getAddress() : -1);
    String description = "New alarm created: " + getTypeString() + 
                        " for point " + String(_source ? _source->getAddress() : -1) + 
                        " (" + (_source ? _source->getName() : "Unknown") + ")";
    LoggerManager::info(source_, description);
    
    Serial.printf("New alarm created: %s for point %d (%s)\n", 
                  getTypeString().c_str(), 
                  _source ? _source->getAddress() : -1,
                  _source ? _source->getName().c_str() : "Unknown");
}




// Alarm::~Alarm() {
//     Serial.printf("Alarm destroyed: %s for point %d\n", 
//                   getTypeString().c_str(), 
//                   _source ? _source->getAddress() : -1);
// }

Alarm::~Alarm() {
    // LOG: Alarm destruction
    String source_ = "ALARM_" + String(_source ? _source->getAddress() : -1);
    String description = "Alarm destroyed: " + getTypeString() + 
                        " for point " + String(_source ? _source->getAddress() : -1);
    LoggerManager::info(source_, description);
    
    Serial.printf("Alarm destroyed: %s for point %d\n", 
                  getTypeString().c_str(), 
                  _source ? _source->getAddress() : -1);
}


void Alarm::acknowledge() {
    if (_stage == AlarmStage::NEW || _stage == AlarmStage::ACTIVE) {
        String oldStage = getStageString();
        _stage = AlarmStage::ACKNOWLEDGED;
        _acknowledgedTime = millis();
        _updateMessage();
        
        // LOG: Manual acknowledgment
        String source_ = "ALARM_" + String(_source ? _source->getAddress() : -1);
        String description = "Alarm acknowledged: " + getTypeString() + 
                            " for point " + String(_source ? _source->getAddress() : -1) + 
                            " (" + (_source ? _source->getName() : "Unknown") + ")";
        LoggerManager::info(source_, description);
        
        // LOG: Alarm state change
        if (_source) {
            int16_t currentTemp = _source->getCurrentTemp();
            int16_t threshold = (_type == AlarmType::HIGH_TEMPERATURE) ? 
                               _source->getHighAlarmThreshold() : _source->getLowAlarmThreshold();
            
            LoggerManager::logAlarmStateChange(_source->getAddress(), _source->getName(),
                                             getTypeString(), _getPriorityString(),
                                             oldStage, "ACKNOWLEDGED", currentTemp, threshold);
        }
        
        Serial.printf("Alarm acknowledged: %s for point %d\n", 
                      getTypeString().c_str(), 
                      _source ? _source->getAddress() : -1);
    }
}



void Alarm::clear() {
    if (_stage == AlarmStage::ACTIVE || _stage == AlarmStage::ACKNOWLEDGED) {
        _stage = AlarmStage::CLEARED;
        _clearedTime = millis();
        _updateMessage();
        
        // LOG: Alarm cleared
        String source_ = "ALARM_" + String(_source ? _source->getAddress() : -1);
        String description = "Alarm cleared: " + getTypeString() + 
                            " for point " + String(_source ? _source->getAddress() : -1) + 
                            " (" + (_source ? _source->getName() : "Unknown") + ")";
        LoggerManager::info(source_, description);
        
        Serial.printf("Alarm cleared: %s for point %d\n", 
                      getTypeString().c_str(), 
                      _source ? _source->getAddress() : -1);
    }
}

void Alarm::resolve() {
    _stage = AlarmStage::RESOLVED;
    _updateMessage();
    
    // LOG: Alarm resolved
    String source_ = "ALARM_" + String(_source ? _source->getAddress() : -1);
    String description = "Alarm resolved: " + getTypeString() + 
                        " for point " + String(_source ? _source->getAddress() : -1) + 
                        " (" + (_source ? _source->getName() : "Unknown") + ")";
    LoggerManager::info(source_, description);
    
    Serial.printf("Alarm resolved: %s for point %d\n", 
                  getTypeString().c_str(), 
                  _source ? _source->getAddress() : -1);
}


void Alarm::reactivate() {
    if (_stage == AlarmStage::CLEARED) {
        _stage = _acknowledgedTime > 0 ? AlarmStage::ACKNOWLEDGED : AlarmStage::ACTIVE;
        _clearedTime = 0;
        _updateMessage();
        
        // LOG: Alarm reactivated
        String source_ = "ALARM_" + String(_source ? _source->getAddress() : -1);
        String description = "Alarm reactivated: " + getTypeString() + 
                            " for point " + String(_source ? _source->getAddress() : -1) + 
                            " (" + (_source ? _source->getName() : "Unknown") + ")";
        LoggerManager::warning(source_, description);
        
        Serial.printf("Alarm reactivated: %s for point %d\n", 
                      getTypeString().c_str(), 
                      _source ? _source->getAddress() : -1);
    }
}

bool Alarm::_checkCondition() {
    if (!_source) {
        Serial.println("Alarm: No source point");
        return false;
    }
    
    int16_t currentTemp = _source->getCurrentTemp();
    bool condition = false;
    
    switch (_type) {
        case AlarmType::HIGH_TEMPERATURE:
            {
                int16_t threshold = _source->getHighAlarmThreshold();
                if (_stage == AlarmStage::CLEARED || _stage == AlarmStage::RESOLVED) {
                    // When cleared/resolved, need temperature to drop below (threshold - hysteresis) to stay cleared
                    // Return true if still above (threshold - hysteresis) = condition still exists
                    condition = currentTemp > (threshold - _hysteresis);
                } else {
                    // Normal activation check: activate when >= threshold
                    condition = currentTemp >= threshold;
                }
                Serial.printf("HIGH_TEMP check: Point %d, Temp=%d, Threshold=%d, Hysteresis=%d, Stage=%s, Condition=%s\n",
                             _source->getAddress(), currentTemp, threshold, _hysteresis,
                             getStageString().c_str(), condition ? "TRUE" : "FALSE");
            }
            break;
            
        case AlarmType::LOW_TEMPERATURE:
            {
                int16_t threshold = _source->getLowAlarmThreshold();
                if (_stage == AlarmStage::CLEARED || _stage == AlarmStage::RESOLVED) {
                    // When cleared/resolved, need temperature to rise above (threshold + hysteresis) to stay cleared
                    // Return true if still below (threshold + hysteresis) = condition still exists
                    condition = currentTemp < (threshold + _hysteresis);
                } else {
                    // Normal activation check: activate when <= threshold
                    condition = currentTemp <= threshold;
                }
                Serial.printf("LOW_TEMP check: Point %d, Temp=%d, Threshold=%d, Hysteresis=%d, Stage=%s, Condition=%s\n",
                             _source->getAddress(), currentTemp, threshold, _hysteresis,
                             getStageString().c_str(), condition ? "TRUE" : "FALSE");
            }
            break;
            
        case AlarmType::SENSOR_ERROR:
            condition = _source->getErrorStatus() != 0;
            Serial.printf("SENSOR_ERROR check: Point %d, Error=%d, Condition=%s\n",
                         _source->getAddress(), _source->getErrorStatus(), 
                         condition ? "TRUE" : "FALSE");
            break;
            
        case AlarmType::SENSOR_DISCONNECTED:
            condition = _source->getBoundSensor() == nullptr;
            Serial.printf("DISCONNECTED check: Point %d, Sensor=%p, Condition=%s\n",
                         _source->getAddress(), _source->getBoundSensor(), 
                         condition ? "TRUE" : "FALSE");
            break;
            
        default:
            Serial.println("Unknown alarm type");
            return false;
    }
    
    return condition;
}




// bool Alarm::_checkCondition() {
//     if (!_source) {
//         Serial.println("Alarm: No source point");
//         return false;
//     }
//     const int HYSTERESIS = 2; // 1 degree hysteresis
    
//     bool condition = false;
    
//     switch (_type) {
//         // case AlarmType::HIGH_TEMPERATURE:
//         //     condition = _source->getCurrentTemp() >= _source->getHighAlarmThreshold();
//         //     Serial.printf("HIGH_TEMP check: Point %d, Temp=%d, Threshold=%d, Condition=%s\n",
//         //                  _source->getAddress(), _source->getCurrentTemp(), 
//         //                  _source->getHighAlarmThreshold(), condition ? "TRUE" : "FALSE");
//         //     break;
            
//         // case AlarmType::LOW_TEMPERATURE:
//         //     condition = _source->getCurrentTemp() <= _source->getLowAlarmThreshold();
//         //     Serial.printf("LOW_TEMP check: Point %d, Temp=%d, Threshold=%d, Condition=%s\n",
//         //                  _source->getAddress(), _source->getCurrentTemp(), 
//         //                  _source->getLowAlarmThreshold(), condition ? "TRUE" : "FALSE");
//         //     break;
        

//         case AlarmType::HIGH_TEMPERATURE:
//             if (_stage == AlarmStage::CLEARED) {
//                 // When cleared, need temperature to go below threshold - hysteresis
//                 return _source->getCurrentTemp() >= (_source->getHighAlarmThreshold() - HYSTERESIS);
//             } else {
//                 // Normal check
//                 return _source->getCurrentTemp() >= _source->getHighAlarmThreshold();
//             }
            
//         case AlarmType::LOW_TEMPERATURE:
//             if (_stage == AlarmStage::CLEARED) {
//                 // When cleared, need temperature to go above threshold + hysteresis
//                 return _source->getCurrentTemp() <= (_source->getLowAlarmThreshold() + HYSTERESIS);
//             } else {
//                 // Normal check
//                 return _source->getCurrentTemp() <= _source->getLowAlarmThreshold();
//             }
            
//         case AlarmType::SENSOR_ERROR:
//             condition = _source->getErrorStatus() != 0;
//             Serial.printf("SENSOR_ERROR check: Point %d, Error=%d, Condition=%s\n",
//                          _source->getAddress(), _source->getErrorStatus(), 
//                          condition ? "TRUE" : "FALSE");
//             break;
            
//         case AlarmType::SENSOR_DISCONNECTED:
//             condition = _source->getBoundSensor() == nullptr;
//             Serial.printf("DISCONNECTED check: Point %d, Sensor=%p, Condition=%s\n",
//                          _source->getAddress(), _source->getBoundSensor(), 
//                          condition ? "TRUE" : "FALSE");
//             break;
            
//         default:
//             Serial.println("Unknown alarm type");
//             return false;
//     }
    
//     return condition;
// }



bool Alarm::isDelayElapsed() const {
    if (_stage != AlarmStage::CLEARED || _clearedTime == 0) {
        return false;
    }
    return (millis() - _clearedTime) >= _delayTime;
}

String Alarm::getDisplayText() const {
    if (!_source) return "Unknown Alarm";
    
    String text = String(_source->getAddress()) + "." + _source->getName();
    text += "\n";
    
    switch (_type) {
        case AlarmType::HIGH_TEMPERATURE:
            text += "H: " + String(_source->getCurrentTemp()) + "¬∞C";
            break;
        case AlarmType::LOW_TEMPERATURE:
            text += "L: " + String(_source->getCurrentTemp()) + "¬∞C";
            break;
        case AlarmType::SENSOR_ERROR:
            text += "E: " + String(_source->getErrorStatus());
            break;
        case AlarmType::SENSOR_DISCONNECTED:
            text += "DISCONNECTED";
            break;
    }
    
    if (_stage == AlarmStage::ACKNOWLEDGED) {
        text += " ACK";
    }
    
    return text;
}

String Alarm::getStatusText() const {
    String status = getTypeString() + " - " + getStageString();
    if (_source) {
        status += " (Point " + String(_source->getAddress()) + ")";
    }
    return status;
}

void Alarm::_updateMessage() {
    _message = getDisplayText();
}

String Alarm::getTypeString() const {
    switch (_type) {
        case AlarmType::HIGH_TEMPERATURE: return "HIGH_TEMP";
        case AlarmType::LOW_TEMPERATURE: return "LOW_TEMP";
        case AlarmType::SENSOR_ERROR: return "SENSOR_ERROR";
        case AlarmType::SENSOR_DISCONNECTED: return "DISCONNECTED";
        default: return "UNKNOWN";
    }
}

String Alarm::getStageString() const {
    switch (_stage) {
        case AlarmStage::NEW: return "NEW";
        case AlarmStage::ACTIVE: return "ACTIVE";
        case AlarmStage::ACKNOWLEDGED: return "ACKNOWLEDGED";
        case AlarmStage::CLEARED: return "CLEARED";
        case AlarmStage::RESOLVED: return "RESOLVED";
        default: return "UNKNOWN";
    }
}

String Alarm::_getPriorityString() const {
    switch (_priority) {
        case AlarmPriority::PRIORITY_LOW: return "LOW";
        case AlarmPriority::PRIORITY_MEDIUM: return "MEDIUM";
        case AlarmPriority::PRIORITY_HIGH: return "HIGH";
        case AlarmPriority::PRIORITY_CRITICAL: return "CRITICAL";
        default: return "UNKNOWN";
    }
}

bool Alarm::operator<(const Alarm& other) const {
    // Sort by priority first (higher priority first), then by timestamp (older first)
    if (_priority != other._priority) {
        return static_cast<int>(_priority) > static_cast<int>(other._priority);
    }
    return _timestamp < other._timestamp;
}

bool Alarm::operator==(const Alarm& other) const {
    return _type == other._type && 
           _source == other._source && 
           _timestamp == other._timestamp;
}



String Alarm::getConfigKey() const {
    return _configKey;
}

void Alarm::setConfigKey(const String& key) {
    _configKey = key;
}

void Alarm::setPriority(AlarmPriority priority) {
    if (_priority != priority) {
        AlarmPriority oldPriority = _priority;
        _priority = priority;
        
        // LOG: Priority change
        String source_ = "CONFIG_" + String(_source ? _source->getAddress() : -1);
        String description = "Alarm priority changed from " + _getPriorityString(oldPriority) + 
                            " to " + _getPriorityString(priority) + 
                            " for " + getTypeString() + " alarm";
        LoggerManager::info(source_, description);
    }
}

void Alarm::setHysteresis(int16_t hysteresis) {
    if (_hysteresis != hysteresis) {
        int16_t oldHysteresis = _hysteresis;
        _hysteresis = hysteresis;
        
        // LOG: Hysteresis change
        String source_ = "CONFIG_" + String(_source ? _source->getAddress() : -1);
        String description = "Alarm hysteresis changed from " + String(oldHysteresis) + 
                            " to " + String(hysteresis) + 
                            " for " + getTypeString() + " alarm";
        LoggerManager::info(source_, description);
    }
}

void Alarm::setEnabled(bool enabled) {
    if (_enabled != enabled) {
        _enabled = enabled;
        
        // LOG: Enable/disable change
        String source_ = "CONFIG_" + String(_source ? _source->getAddress() : -1);
        String description = getTypeString() + " alarm " + (enabled ? "enabled" : "disabled");
        LoggerManager::info(source_, description);
    }
}



void Alarm::setStage(AlarmStage stage){
    _stage = stage;
};

// Modify the updateCondition method to handle acknowledged timeout
bool Alarm::updateCondition() {
    if (!_source) {
        Serial.println("Alarm updateCondition: No source");
        return true;
    }
    
    bool conditionExists = _checkCondition();
    AlarmStage oldStage = _stage;
    
    Serial.printf("Alarm update: Point %d, Type=%s, Stage=%s, Condition=%s\n",
                  _source->getAddress(), getTypeString().c_str(), 
                  getStageString().c_str(), conditionExists ? "EXISTS" : "CLEARED");
    
    String source_ = "ALARM_" + String(_source->getAddress());
    String baseDescription = getTypeString() + " alarm for point " + 
                            String(_source->getAddress()) + " (" + _source->getName() + ")";
    
    // Get current temperature and threshold for logging
    int16_t currentTemp = _source->getCurrentTemp();
    int16_t threshold = 0;
    
    switch (_type) {
        case AlarmType::HIGH_TEMPERATURE:
            threshold = _source->getHighAlarmThreshold();
            break;
        case AlarmType::LOW_TEMPERATURE:
            threshold = _source->getLowAlarmThreshold();
            break;
        case AlarmType::SENSOR_ERROR:
        case AlarmType::SENSOR_DISCONNECTED:
            threshold = 0; // Not applicable for these alarm types
            break;
    }
    
    switch (_stage) {
        case AlarmStage::NEW:
            if (conditionExists) {
                _stage = AlarmStage::ACTIVE;
                
                // LOG: NEW -> ACTIVE
                LoggerManager::error(source_, baseDescription + " activated");
                LoggerManager::logAlarmStateChange(_source->getAddress(), _source->getName(),
                                                 getTypeString(), _getPriorityString(),
                                                 "NEW", "ACTIVE", currentTemp, threshold);
                
                Serial.printf("Alarm %s: NEW -> ACTIVE\n", getTypeString().c_str());
            } else {
                resolve();
                
                // LOG: NEW -> RESOLVED
                LoggerManager::info(source_, baseDescription + " resolved before activation");
                LoggerManager::logAlarmStateChange(_source->getAddress(), _source->getName(),
                                                 getTypeString(), _getPriorityString(),
                                                 "NEW", "RESOLVED", currentTemp, threshold);
                
                Serial.printf("Alarm %s: NEW -> RESOLVED (condition cleared)\n", getTypeString().c_str());
            }
            break;
            
        case AlarmStage::ACTIVE:
            if (!conditionExists) {
                clear();
                
                // LOG: ACTIVE -> CLEARED
                LoggerManager::info(source_, baseDescription + " condition cleared");
                LoggerManager::logAlarmStateChange(_source->getAddress(), _source->getName(),
                                                 getTypeString(), _getPriorityString(),
                                                 "ACTIVE", "CLEARED", currentTemp, threshold);
                
                Serial.printf("Alarm %s: ACTIVE -> CLEARED (condition no longer exists)\n", getTypeString().c_str());
            }
            break;
            
        case AlarmStage::ACKNOWLEDGED:
            if (!conditionExists) {
                clear();
                
                // LOG: ACKNOWLEDGED -> CLEARED
                LoggerManager::info(source_, baseDescription + " condition cleared while acknowledged");
                LoggerManager::logAlarmStateChange(_source->getAddress(), _source->getName(),
                                                 getTypeString(), _getPriorityString(),
                                                 "ACKNOWLEDGED", "CLEARED", currentTemp, threshold);
                
                Serial.printf("Alarm %s: ACKNOWLEDGED -> CLEARED (condition no longer exists)\n", getTypeString().c_str());
            } else if (isAcknowledgedDelayElapsed()) {
                _stage = AlarmStage::ACTIVE;
                
                // LOG: ACKNOWLEDGED -> ACTIVE (timeout)
                LoggerManager::warning(source_, baseDescription + " acknowledgment timeout - returned to active");
                LoggerManager::logAlarmStateChange(_source->getAddress(), _source->getName(),
                                                 getTypeString(), _getPriorityString(),
                                                 "ACKNOWLEDGED", "ACTIVE", currentTemp, threshold);
                
                Serial.printf("Alarm %s: ACKNOWLEDGED -> ACTIVE (acknowledged delay elapsed)\n", getTypeString().c_str());
            }
            break;
            
        case AlarmStage::CLEARED:
            if (conditionExists) {
                _stage = AlarmStage::ACTIVE;
                _clearedTime = 0;
                
                // LOG: CLEARED -> ACTIVE (condition returned)
                LoggerManager::warning(source_, baseDescription + " condition returned");
                LoggerManager::logAlarmStateChange(_source->getAddress(), _source->getName(),
                                                 getTypeString(), _getPriorityString(),
                                                 "CLEARED", "ACTIVE", currentTemp, threshold);
                
                Serial.printf("Alarm %s: CLEARED -> ACTIVE (condition returned)\n", getTypeString().c_str());
            } else if (isDelayElapsed()) {
                resolve();
                
                // LOG: CLEARED -> RESOLVED (delay elapsed)
                LoggerManager::info(source_, baseDescription + " auto-resolved after delay");
                LoggerManager::logAlarmStateChange(_source->getAddress(), _source->getName(),
                                                 getTypeString(), _getPriorityString(),
                                                 "CLEARED", "RESOLVED", currentTemp, threshold);
                
                Serial.printf("Alarm %s: CLEARED -> RESOLVED (delay elapsed)\n", getTypeString().c_str());
            }
            break;
        
        case AlarmStage::RESOLVED:
            if (conditionExists) {
                _stage = AlarmStage::ACTIVE;
                _timestamp = millis();
                _acknowledgedTime = 0;
                _clearedTime = 0;
                
                // LOG: RESOLVED -> ACTIVE (condition returned)
                LoggerManager::error(source_, baseDescription + " reoccurred after resolution");
                LoggerManager::logAlarmStateChange(_source->getAddress(), _source->getName(),
                                                 getTypeString(), _getPriorityString(),
                                                 "RESOLVED", "ACTIVE", currentTemp, threshold);
                
                Serial.printf("Alarm %s: RESOLVED -> ACTIVE (condition returned)\n", getTypeString().c_str());
            }
            break;
    }
    
    if (oldStage != _stage) {
        _updateMessage();
    }
    
    return true;
}


// Add these new methods to Alarm.cpp
void Alarm::setAcknowledgedDelay(unsigned long delay) {
    _acknowledgedDelay = delay;
}

unsigned long Alarm::getAcknowledgedDelay() const {
    return _acknowledgedDelay;
}

bool Alarm::isAcknowledgedDelayElapsed() const {
    if (_stage != AlarmStage::ACKNOWLEDGED || _acknowledgedTime == 0) {
        return false;
    }
    return (millis() - _acknowledgedTime) >= _acknowledgedDelay;
}

unsigned long Alarm::getAcknowledgedTimeLeft() const {
    if (_stage != AlarmStage::ACKNOWLEDGED || _acknowledgedTime == 0) {
        return 0; // No time left if not acknowledged
    }
    
    unsigned long elapsed = millis() - _acknowledgedTime;
    if (elapsed >= _acknowledgedDelay) {
        return 0; // Time already elapsed
    }
    
    return _acknowledgedDelay - elapsed; // Time remaining in milliseconds
}


String Alarm::_getPriorityString(AlarmPriority priority) const {
    switch (priority) {
        case AlarmPriority::PRIORITY_LOW: return "LOW";
        case AlarmPriority::PRIORITY_MEDIUM: return "MEDIUM";
        case AlarmPriority::PRIORITY_HIGH: return "HIGH";
        case AlarmPriority::PRIORITY_CRITICAL: return "CRITICAL";
        default: return "UNKNOWN";
    }
}

-------- [ Separator ] ------

File Name: src/CSVConfigManager.cpp
Size: 12.31 KB
Code:
#include "CSVConfigManager.h"
#include <LittleFS.h>

CSVConfigManager::CSVConfigManager(TemperatureController& controller) 
    : _controller(controller), _lastError("") {
}

String CSVConfigManager::exportPointsWithAlarmsToCSV() {
    // Create header with bus number instead of chip select
    String csv = "PointAddress,PointName,PointType,CurrentTemp,MinTemp,MaxTemp,";
    csv += "LowTempThreshold,HighTempThreshold,SensorROM,SensorBusNumber,";
    csv += "HIGH_TEMPERATURE,LOW_TEMPERATURE,SENSOR_ERROR,SENSOR_DISCONNECTED\n";
    
    // Add sample line with point -1 showing all possible priorities
    csv += "-1,SAMPLE_POINT,SAMPLE,0,0,0,0,0,,";
    csv += ",CRITICAL,HIGH,MEDIUM,LOW\n";
    
    // Export DS18B20 points (0-49)
    for (int i = 0; i < 50; i++) {
        MeasurementPoint* point = _controller.getDS18B20Point(i);
        if (point) {
            _exportPointToCSV(csv, point, "DS18B20");
        }
    }
    
    // Export PT1000 points (50-59)
    for (int i = 0; i < 10; i++) {
        MeasurementPoint* point = _controller.getPT1000Point(i);
        if (point) {
            _exportPointToCSV(csv, point, "PT1000");
        }
    }
    
    return csv;
}

void CSVConfigManager::_exportPointToCSV(String& csv, MeasurementPoint* point, const String& pointType) {
    if (!point) return;
    
    // Get bound sensor info
    Sensor* sensor = point->getBoundSensor();
    String romString = "";
    String busNumber = "";
    
    if (sensor) {
        if (sensor->getType() == SensorType::DS18B20) {
            romString = sensor->getDS18B20RomString();
        } else if (sensor->getType() == SensorType::PT1000) {
            busNumber = String(_controller.getSensorBus(sensor)); // Changed from ChipSelectPin to BusNumber
        }
    }
    
    // Build the CSV row
    csv += String(point->getAddress()) + ",";
    csv += _escapeCSVField(point->getName()) + ",";
    csv += pointType + ",";
    csv += String(point->getCurrentTemp()) + ",";
    csv += String(point->getMinTemp()) + ",";
    csv += String(point->getMaxTemp()) + ",";
    csv += String(point->getLowAlarmThreshold()) + ",";
    csv += String(point->getHighAlarmThreshold()) + ",";
    csv += _escapeCSVField(romString) + ",";
    csv += busNumber + ","; // Changed variable name
    
    // Add alarm priorities for each type
    csv += _getAlarmPriorityForPoint(point->getAddress(), AlarmType::HIGH_TEMPERATURE) + ",";
    csv += _getAlarmPriorityForPoint(point->getAddress(), AlarmType::LOW_TEMPERATURE) + ",";
    csv += _getAlarmPriorityForPoint(point->getAddress(), AlarmType::SENSOR_ERROR) + ",";
    csv += _getAlarmPriorityForPoint(point->getAddress(), AlarmType::SENSOR_DISCONNECTED) + "\n";
}


bool CSVConfigManager::importPointsWithAlarmsFromCSV(const String& csvData) {
    if (!validatePointsCSV(csvData)) {
        return false;
    }
    
    int lineStart = 0;
    int lineEnd = csvData.indexOf('\n');
    
    // Skip header line
    if (lineEnd == -1) {
        _lastError = "Invalid CSV format";
        return false;
    }
    lineStart = lineEnd + 1;
    
    // Skip sample line (point -1)
    lineEnd = csvData.indexOf('\n', lineStart);
    if (lineEnd == -1) {
        _lastError = "Missing sample line";
        return false;
    }
    lineStart = lineEnd + 1;
    
    // Clear existing alarms
    _controller.clearConfiguredAlarms();
    
    // Parse each data line
    while (lineStart < csvData.length()) {
        lineEnd = csvData.indexOf('\n', lineStart);
        if (lineEnd == -1) lineEnd = csvData.length();
        
        String line = csvData.substring(lineStart, lineEnd);
        line.trim();
        
        if (line.length() > 0) {
            if (!_parseCSVLine(line)) {
                return false;
            }
        }
        
        lineStart = lineEnd + 1;
    }
    
    return true;
}


bool CSVConfigManager::_parseAlarmFromCSV(int pointAddress, const String& alarmType, 
                                         const String& priority, const String& enabled, 
                                         const String& hysteresis) {
    AlarmType type = _parseAlarmType(alarmType);
    AlarmPriority prio = _parsePriority(priority);
    bool isEnabled = (enabled.equalsIgnoreCase("true"));
    int16_t hyst = hysteresis.toInt();
    
    // Add alarm to controller
    if (_controller.addAlarm(type, pointAddress, prio)) {
        // Find the alarm we just added and configure it
        String configKey = "alarm_" + String(pointAddress) + "_" + String(static_cast<int>(type));
        Alarm* alarm = _controller.findAlarm(configKey);
        if (alarm) {
            alarm->setEnabled(isEnabled);
            alarm->setHysteresis(hyst);
            return true;
        }
    }
    
    return false;
}

String CSVConfigManager::_escapeCSVField(const String& field) {
    if (field.indexOf(',') >= 0 || field.indexOf('"') >= 0 || field.indexOf('\n') >= 0) {
        String escaped = "\"";
        for (int i = 0; i < field.length(); i++) {
            if (field.charAt(i) == '"') {
                escaped += "\"\"";
            } else {
                escaped += field.charAt(i);
            }
        }
        escaped += "\"";
        return escaped;
    }
    return field;
}

String CSVConfigManager::_unescapeCSVField(const String& field) {
    if (field.startsWith("\"") && field.endsWith("\"")) {
        String unescaped = field.substring(1, field.length() - 1);
        unescaped.replace("\"\"", "\"");
        return unescaped;
    }
    return field;
}

String CSVConfigManager::_getAlarmTypeString(AlarmType type) {
    switch (type) {
        case AlarmType::HIGH_TEMPERATURE: return "HIGH_TEMP";
        case AlarmType::LOW_TEMPERATURE: return "LOW_TEMP";
        case AlarmType::SENSOR_ERROR: return "SENSOR_ERROR";
        case AlarmType::SENSOR_DISCONNECTED: return "DISCONNECTED";
        default: return "UNKNOWN";
    }
}

AlarmType CSVConfigManager::_parseAlarmType(const String& typeStr) {
    if (typeStr == "HIGH_TEMP") return AlarmType::HIGH_TEMPERATURE;
    if (typeStr == "LOW_TEMP") return AlarmType::LOW_TEMPERATURE;
    if (typeStr == "SENSOR_ERROR") return AlarmType::SENSOR_ERROR;
    if (typeStr == "DISCONNECTED") return AlarmType::SENSOR_DISCONNECTED;
    return AlarmType::HIGH_TEMPERATURE; // Default
}

String CSVConfigManager::_getPriorityString(AlarmPriority priority) {
    switch (priority) {
        case AlarmPriority::PRIORITY_LOW: return "LOW";
        case AlarmPriority::PRIORITY_MEDIUM: return "MEDIUM";
        case AlarmPriority::PRIORITY_HIGH: return "HIGH";
        case AlarmPriority::PRIORITY_CRITICAL: return "CRITICAL";
        default: return "MEDIUM";
    }
}

AlarmPriority CSVConfigManager::_parsePriority(const String& priorityStr) {
    if (priorityStr == "LOW") return AlarmPriority::PRIORITY_LOW;
    if (priorityStr == "MEDIUM") return AlarmPriority::PRIORITY_MEDIUM;
    if (priorityStr == "HIGH") return AlarmPriority::PRIORITY_HIGH;
    if (priorityStr == "CRITICAL") return AlarmPriority::PRIORITY_CRITICAL;
    return AlarmPriority::PRIORITY_MEDIUM; // Default
}

bool CSVConfigManager::validatePointsCSV(const String& csvData) {
    if (csvData.length() == 0) {
        _lastError = "Empty CSV data";
        return false;
    }
    
    // Check for required headers
    String requiredHeaders[] = {
        "PointAddress", "PointName", "PointType", "CurrentTemp", "MinTemp", "MaxTemp",
        "LowTempThreshold", "HighTempThreshold", "SensorROM", "SensorBusNumber", // Changed header
        "HIGH_TEMPERATURE", "LOW_TEMPERATURE", "SENSOR_ERROR", "SENSOR_DISCONNECTED"
    };
    
    int headerLine = csvData.indexOf('\n');
    if (headerLine == -1) {
        _lastError = "No header line found";
        return false;
    }
    
    String header = csvData.substring(0, headerLine);
    for (const String& reqHeader : requiredHeaders) {
        if (header.indexOf(reqHeader) == -1) {
            _lastError = "Missing required header: " + reqHeader;
            return false;
        }
    }
    
    return true;
}



bool CSVConfigManager::saveCSVToFile(const String& filename, const String& csvData) {
    if (!LittleFS.begin()) {
        _lastError = "Failed to mount filesystem";
        return false;
    }
    
    File file = LittleFS.open(filename, "w");
    if (!file) {
        _lastError = "Failed to open file for writing: " + filename;
        return false;
    }
    
    size_t written = file.print(csvData);
    file.close();
    
    if (written != csvData.length()) {
        _lastError = "Failed to write complete data to file";
        return false;
    }
    
    return true;
}

String CSVConfigManager::loadCSVFromFile(const String& filename) {
    if (!LittleFS.begin()) {
        _lastError = "Failed to mount filesystem";
        return "";
    }
    
    File file = LittleFS.open(filename, "r");
    if (!file) {
        _lastError = "Failed to open file for reading: " + filename;
        return "";
    }
    
    String content = file.readString();
    file.close();
    
    return content;
}

// Placeholder implementations for sensor-specific methods
String CSVConfigManager::exportSensorsToCSV() {
    // Implementation for sensor export if needed
    return "";
}

bool CSVConfigManager::importSensorsFromCSV(const String& csvData) {
    // Implementation for sensor import if needed
    return false;
}


bool CSVConfigManager::_parseCSVLine(const String& line) {
    // Simple CSV parsing - split by commas
    int fieldIndex = 0;
    int startPos = 0;
    String fields[14]; // 14 fields in our CSV format
    
    for (int i = 0; i <= line.length(); i++) {
        if (i == line.length() || line.charAt(i) == ',') {
            if (fieldIndex < 14) {
                fields[fieldIndex] = line.substring(startPos, i);
                fields[fieldIndex].trim();
                // Remove quotes if present
                if (fields[fieldIndex].startsWith("\"") && fields[fieldIndex].endsWith("\"")) {
                    fields[fieldIndex] = fields[fieldIndex].substring(1, fields[fieldIndex].length() - 1);
                }
            }
            fieldIndex++;
            startPos = i + 1;
        }
    }
    
    if (fieldIndex < 14) {
        _lastError = "Insufficient fields in CSV line";
        return false;
    }
    
    // Parse fields
    int pointAddress = fields[0].toInt();
    
    // Skip sample line (point -1)
    if (pointAddress == -1) {
        return true;
    }
    
    String pointName = fields[1];
    String pointType = fields[2];
    int16_t lowThreshold = fields[6].toInt();
    int16_t highThreshold = fields[7].toInt();
    String romString = fields[8];
    String busNumberStr = fields[9]; // Changed from chipSelectStr
    
    // Update measurement point
    MeasurementPoint* point = _controller.getMeasurementPoint(pointAddress);
    if (point) {
        point->setName(pointName);
        point->setLowAlarmThreshold(lowThreshold);
        point->setHighAlarmThreshold(highThreshold);
        
        // Bind sensor if specified
        if (!romString.isEmpty()) {
            _controller.bindSensorToPointByRom(romString, pointAddress);
        } else if (!busNumberStr.isEmpty()) {
            int busNumber = busNumberStr.toInt();
            _controller.bindSensorToPointByBusNumber(busNumber, pointAddress); // Changed method name
        }
    }
    
    // Parse alarms for each type (rest remains the same)
    String alarmPriorities[4] = {fields[10], fields[11], fields[12], fields[13]};
    AlarmType alarmTypes[4] = {
        AlarmType::HIGH_TEMPERATURE,
        AlarmType::LOW_TEMPERATURE,
        AlarmType::SENSOR_ERROR,
        AlarmType::SENSOR_DISCONNECTED
    };
    
    for (int i = 0; i < 4; i++) {
        if (!alarmPriorities[i].isEmpty()) {
            AlarmPriority priority = _parsePriority(alarmPriorities[i]);
            if (!_controller.addAlarm(alarmTypes[i], pointAddress, priority)) {
                _lastError = "Failed to add alarm for point " + String(pointAddress);
                return false;
            }
        }
    }
    
    return true;
}


String CSVConfigManager::_getAlarmPriorityForPoint(int pointAddress, AlarmType alarmType) {
    // Find alarm of specific type for this point
    for (int i = 0; i < _controller.getAlarmCount(); i++) {
        Alarm* alarm = _controller.getAlarmByIndex(i);
        if (alarm && alarm->getPointAddress() == pointAddress && alarm->getType() == alarmType) {
            return _getPriorityString(alarm->getPriority());
        }
    }
    return ""; // No alarm of this type for this point
}

-------- [ Separator ] ------

File Name: src/ConfigManager.cpp
Size: 65.98 KB
Code:
#include "ConfigManager.h"
#include <ArduinoJson.h>


ConfigManager* ConfigManager::instance = nullptr;


// YAML configuration definition
const char* VARIABLES_DEF_YAML PROGMEM = R"~(
    Wifi settings:
      - st_ssid:
          label: WiFi SSID
          default: Beeline_2G_F13F37
      - st_pass:
          label: WiFi Password
          default: 1122334455667788
      - host_name:
          label: Device Hostname
          default: 'temp-monitor-{mac}'
    
    Device settings:
      - device_id:
          label: Device ID
          type: number
          min: 1
          max: 9999
          default: 1000
      - firmware_version:
          label: Firmware Version
          default: '1.0'
          readonly: true
      - measurement_period:
          label: Measurement Period (seconds)
          type: number
          min: 1
          max: 3600
          default: 10
    
    Alarm Acknowledged Delays:
      - ack_delay_critical:
          label: Critical Alarm Acknowledged Delay (minutes)
          type: number
          min: 1
          max: 1440
          default: 5
      - ack_delay_high:
          label: High Priority Alarm Acknowledged Delay (minutes)
          type: number
          min: 1
          max: 1440
          default: 10
      - ack_delay_medium:
          label: Medium Priority Alarm Acknowledged Delay (minutes)
          type: number
          min: 1
          max: 1440
          default: 15
      - ack_delay_low:
          label: Low Priority Alarm Acknowledged Delay (minutes)
          type: number
          min: 1
          max: 1440
          default: 30
    
    Modbus settings:
      - modbus_enabled:
          label: Enable Modbus RTU
          checked: true
      - modbus_address:
          label: Modbus Device Address
          type: number
          min: 1
          max: 247
          default: 1
      - modbus_baud_rate:
          label: Baud Rate
          options: '4800', '9600', '19200', '38400', '57600', '115200'
          default: '9600'
    )~";

ConfigManager::ConfigManager(TemperatureController& tempController)
    : conf("/config.ini", VARIABLES_DEF_YAML),
      controller(tempController), 
      csvManager(controller),
      settingsCSVManager(conf),
      portalActive(false) {
    
    instance = this;
    server = new WebServer(80);
    confHelper = new ConfigAssistHelper(conf);
}

ConfigManager::~ConfigManager() {
    if (server) {
        delete server;
    }
    
    if (confHelper) {
        delete confHelper;
    }
}

bool ConfigManager::begin() {
    // Initialize LittleFS
    if (!LittleFS.begin(true)) {
        Serial.println("LittleFS mount failed");
        return false;
    }
    
    // Set callback function for configuration changes
    conf.setRemotUpdateCallback(onConfigChanged);
    
    // IMPORTANT: Register custom routes BEFORE ConfigAssist setup

    if(server) {
        Serial.println("!!!!!!!!!!!!!SERVER STARTED!!!!!!!!!!!!");
    } else {
        Serial.println("!!!!!!!!!!!!!SERVER FAILED!!!!!!!!!!!!");
    }


    basicAPI();
    sensorAPI();
    csvImportExportAPI();
    pointsAPI();
    alarmsAPI();
    logsAPI();
    downloadAPI();
    

    

   




    

    

    
    

    





    


    
    

    


    

 // WiFi setup logging
 bool startAP = true;
 if (conf("st_ssid") != "" && conf("st_pass") != "") {
     LoggerManager::info("CONFIG", "Attempting WiFi connection to: " + String(conf("st_ssid")));
     if (connectWiFi(10000)) {
         startAP = false;
         LoggerManager::info("CONFIG", "WiFi connected successfully - IP: " + WiFi.localIP().toString());
     } else {
         LoggerManager::warning("CONFIG", "WiFi connection failed, starting AP mode");
     }
 } else {
     LoggerManager::info("CONFIG", "No WiFi credentials configured, starting AP mode");
 }
    
    // Setup WiFi
    // bool startAP = true;
    // if (conf("st_ssid") != "" && conf("st_pass") != "") {
    //     // Try to connect to WiFi if credentials are available
    //     if (connectWiFi(10000)) {
    //         startAP = false;
    //     }
    // }
    
    // Setup ConfigAssist with web server AFTER registering custom routes
    conf.setup(*server, startAP);
    
    // Start the web server
    server->begin();
    
    // Load sensor configuration
    //loadSensorConfig();
    loadPointsConfig();
    loadAlarmsConfig();
    Serial.println("CM.begin(): Sensor data loaded:");
    //Serial.println(controller.getSensorsJson());
    
    // Apply configuration to controller
    controller.setDeviceId(getDeviceId());
    LoggerManager::info("CONFIG", "Device ID set to: " + String(getDeviceId()));
    
    controller.setMeasurementPeriod(getMeasurementPeriod());
    LoggerManager::info("CONFIG", "Measurement period set to: " + String(getMeasurementPeriod()) + " seconds");

    // Load acknowledged delays
    controller.setAcknowledgedDelayCritical(getAcknowledgedDelayCritical() * 60 * 1000);
    controller.setAcknowledgedDelayHigh(getAcknowledgedDelayHigh() * 60 * 1000);
    controller.setAcknowledgedDelayMedium(getAcknowledgedDelayMedium() * 60 * 1000);
    controller.setAcknowledgedDelayLow(getAcknowledgedDelayLow() * 60 * 1000);
    LoggerManager::info("CONFIG", "Acknowledged delays configured");
    
    LoggerManager::info("CONFIG", "ConfigManager initialization completed successfully");
    
    return true;
}

void ConfigManager::update() {
    // Handle client requests
    server->handleClient();
}

bool ConfigManager::connectWiFi(int timeoutMs) {
    // Use ConfigAssistHelper to connect to WiFi
    bool connected = confHelper->connectToNetwork(timeoutMs, -1);
    
    if (connected) {
        Serial.print("Connected to WiFi. IP: ");
        Serial.println(WiFi.localIP().toString());
    } else {
        Serial.println("Failed to connect to WiFi");
    }
    
    return connected;
}

// Update the onConfigChanged method in ConfigManager.cpp
void ConfigManager::onConfigChanged(String key) {
    if (instance == nullptr) return;
    
    Serial.print("Config changed: ");
    Serial.print(key);
    Serial.print(" = ");
    Serial.println(instance->conf(key));
    
    if (key == "device_id") {
        instance->controller.setDeviceId(instance->conf(key).toInt());
    } else if (key == "measurement_period") {
        instance->controller.setMeasurementPeriod(instance->conf(key).toInt());
    } else if (key == "reset_min_max") {
        instance->resetMinMaxValues();
    } else if (key == "ack_delay_critical") {
        unsigned long delayMs = instance->conf(key).toInt() * 60 * 1000; // Convert minutes to milliseconds
        instance->controller.setAcknowledgedDelayCritical(delayMs);
        Serial.printf("Set critical acknowledged delay to %lu ms (%d minutes)\n", delayMs, instance->conf(key).toInt());
    } else if (key == "ack_delay_high") {
        unsigned long delayMs = instance->conf(key).toInt() * 60 * 1000;
        instance->controller.setAcknowledgedDelayHigh(delayMs);
        Serial.printf("Set high acknowledged delay to %lu ms (%d minutes)\n", delayMs, instance->conf(key).toInt());
    } else if (key == "ack_delay_medium") {
        unsigned long delayMs = instance->conf(key).toInt() * 60 * 1000;
        instance->controller.setAcknowledgedDelayMedium(delayMs);
        Serial.printf("Set medium acknowledged delay to %lu ms (%d minutes)\n", delayMs, instance->conf(key).toInt());
    } else if (key == "ack_delay_low") {
        unsigned long delayMs = instance->conf(key).toInt() * 60 * 1000;
        instance->controller.setAcknowledgedDelayLow(delayMs);
        Serial.printf("Set low acknowledged delay to %lu ms (%d minutes)\n", delayMs, instance->conf(key).toInt());
    }
}



void ConfigManager::resetMinMaxValues() {
    controller.resetMinMaxValues();
}



// Save all measurement points and their bindings
void ConfigManager::savePointsConfig() {
    LoggerManager::info("CONFIG_SAVE", "Saving points configuration to /points2.ini");
    Serial.println('Save points to config ....');
    ConfigAssist pointsConf("/points2.ini", false);

    // DS18B20 points
    for (uint8_t i = 0; i < 50; ++i) {
        MeasurementPoint* point = controller.getDS18B20Point(i);
        if (!point) continue;
        String key = "ds_" + String(point->getAddress());
        pointsConf[key + "_name"] = point->getName();
        pointsConf[key + "_low_alarm"] = String(point->getLowAlarmThreshold());
        pointsConf[key + "_high_alarm"] = String(point->getHighAlarmThreshold());

        Sensor* bound = point->getBoundSensor();
        if (bound && bound->getType() == SensorType::DS18B20) {
            pointsConf[key + "_sensor_rom"] = bound->getDS18B20RomString();
            pointsConf[key + "_sensor_bus"] = controller.getSensorBus(bound);
        } else {
            pointsConf[key + "_sensor_rom"] = "";
            pointsConf[key + "_sensor_bus"] = "";
        }
    }

    // PT1000 points
    for (uint8_t i = 0; i < 10; ++i) {
        MeasurementPoint* point = controller.getPT1000Point(i);
        if (!point) continue;
        String key = "pt_" + String(point->getAddress());
        pointsConf[key + "_name"] = point->getName();
        pointsConf[key + "_low_alarm"] = String(point->getLowAlarmThreshold());
        pointsConf[key + "_high_alarm"] = String(point->getHighAlarmThreshold());

        Sensor* bound = point->getBoundSensor();
        if (bound && bound->getType() == SensorType::PT1000) {
            pointsConf[key + "_sensor_cs"] = String(bound->getPT1000ChipSelectPin());
        } else {
            pointsConf[key + "_sensor_cs"] = "";
        }
    }
    pointsConf.saveConfigFile();
}

// // Load all measurement points and their bindings
// void ConfigManager::loadPointsConfig() {
//     ConfigAssist pointsConf("/points2.ini", false);

//     // DS18B20 points
//     for (uint8_t i = 0; i < 50; ++i) {
//         String key = "ds_" + String(i);
//         MeasurementPoint* point = controller.getDS18B20Point(i);
//         if (!point) continue;
//         point->setName(pointsConf(key + "_name"));
//         point->setLowAlarmThreshold(pointsConf(key + "_low_alarm").toInt());
//         point->setHighAlarmThreshold(pointsConf(key + "_high_alarm").toInt());
//         String rom = pointsConf(key + "_sensor_rom");
//         if (rom.length() == 16) {
//             Serial.println("ROM from file: " + rom);
//             controller.bindSensorToPointByRom(rom, i);
//         } else {
//             controller.unbindSensorFromPoint(i);
//         }
//     }

//     // PT1000 points
//     for (uint8_t i = 0; i < 10; ++i) {
//         uint8_t address = 50 + i;
//         String key = "pt_" + String(address);
//         MeasurementPoint* point = controller.getPT1000Point(i);
//         if (!point) continue;
//         point->setName(pointsConf(key + "_name"));
//         point->setLowAlarmThreshold(pointsConf(key + "_low_alarm").toInt());
//         point->setHighAlarmThreshold(pointsConf(key + "_high_alarm").toInt());
//         int cs = pointsConf(key + "_sensor_cs").toInt();
//         if (cs > 0) {
//             controller.bindSensorToPointByChipSelect(cs, address);
//         } else {
//             controller.unbindSensorFromPoint(address);
//         }
//     }
// }

void ConfigManager::loadPointsConfig() {
    ConfigAssist pointsConf("/points2.ini", false);
    LoggerManager::info("CONFIG_LOAD", "Loading points configuration from /points2.ini");

    // DS18B20 points
    for (uint8_t i = 0; i < 50; ++i) {
        String key = "ds_" + String(i);
        MeasurementPoint* point = controller.getDS18B20Point(i);
        if (!point) continue;
        point->setName(pointsConf(key + "_name"));
        point->setLowAlarmThreshold(pointsConf(key + "_low_alarm").toInt());
        point->setHighAlarmThreshold(pointsConf(key + "_high_alarm").toInt());
        uint8_t bus = pointsConf(key + "_sensor_bus").toInt();
        String rom = pointsConf(key + "_sensor_rom");
        if (rom.length() == 16) {
            // Ensure the sensor exists and is initialized before binding
            Sensor* sensor = controller.findSensorByRom(rom);
            if (!sensor) {
                uint8_t romArr[8];
                for (int j = 0; j < 8; ++j)
                    romArr[j] = strtol(rom.substring(j*2, j*2+2).c_str(), nullptr, 16);
                String sensorName = "DS18B20_" + rom;
                sensor = new Sensor(SensorType::DS18B20, 0, sensorName);
                sensor->setupDS18B20(controller.getOneWirePin(bus), romArr);
                if (!sensor->initialize()) {
                    //sensor->setErrorStatus(0x01); // Mark as error (not connected)
                }
                controller.addSensor(sensor);
            }
            
            controller.bindSensorToPointByRom(rom, i);
        } else {
            controller.unbindSensorFromPoint(i);
        }
    }

    // PT1000 points
    for (uint8_t i = 0; i < 10; ++i) {
        uint8_t address = 50 + i;
        String key = "pt_" + String(address);
        MeasurementPoint* point = controller.getPT1000Point(i);
        if (!point) continue;
        point->setName(pointsConf(key + "_name"));
        point->setLowAlarmThreshold(pointsConf(key + "_low_alarm").toInt());
        point->setHighAlarmThreshold(pointsConf(key + "_high_alarm").toInt());
        int cs = pointsConf(key + "_sensor_cs").toInt();
        if (cs > 0) {
            // Ensure the sensor exists and is initialized before binding
            Sensor* sensor = controller.findSensorByChipSelect(cs);
            if (!sensor) {
                String sensorName = "PT1000_CS" + String(cs);
                sensor = new Sensor(SensorType::PT1000, 0, sensorName);
                sensor->setupPT1000(cs, i);
                if (!sensor->initialize()) {
                    //sensor->setErrorStatus(0x01); // Mark as error (not connected)
                }
                controller.addSensor(sensor);
            }
            controller.bindSensorToPointByChipSelect(cs, address);
        } else {
            controller.unbindSensorFromPoint(address);
        }
    }
    controller.applyConfigToRegisterMap();
}


// Update a measurement point and its binding in config
bool ConfigManager::updatePointInConfig(uint8_t address, const String& name, int16_t lowAlarm, int16_t highAlarm,
                                        const String& ds18b20RomString, int pt1000ChipSelect) {
    MeasurementPoint* point = controller.getMeasurementPoint(address);
    if (!point) return false;
    point->setName(name);
    point->setLowAlarmThreshold(lowAlarm);
    point->setHighAlarmThreshold(highAlarm);
    if (!ds18b20RomString.isEmpty()) {
        controller.bindSensorToPointByRom(ds18b20RomString, address);
    } else if (pt1000ChipSelect >= 0) {
        controller.bindSensorToPointByChipSelect(pt1000ChipSelect, address);
    } else {
        controller.unbindSensorFromPoint(address);
    }
    savePointsConfig();
    return true;
}


void ConfigManager::saveAlarmsConfig() {
    Serial.println("Save alarms to config....");
    ConfigAssist alarmsConf("/alarms.ini", false);
    
    // Clear existing entries by setting them to empty strings
    // ConfigAssist will treat empty strings as non-existent
    for (int i = 0; i < 1000; i++) { // Check reasonable number of possible alarms
        String alarmKey = "alarm" + String(i);
        if (alarmsConf.exists(alarmKey + "_type")) {
            alarmsConf[alarmKey + "_type"] = "";
            alarmsConf[alarmKey + "_priority"] = "";
            alarmsConf[alarmKey + "_point"] = "";
            alarmsConf[alarmKey + "_enabled"] = "";
        } else {
            break; // No more entries to clear
        }
    }
    
    // Save current alarms
    int alarmIndex = 0;
    for (int i = 0; i < controller.getAlarmCount(); ++i) {
        Alarm* alarm = controller.getAlarmByIndex(i);
        if (!alarm) continue;
        
        String alarmKey = "alarm" + String(alarmIndex++);
        alarmsConf[alarmKey + "_type"] = String(static_cast<int>(alarm->getType()));
        alarmsConf[alarmKey + "_priority"] = String(static_cast<int>(alarm->getPriority()));
        alarmsConf[alarmKey + "_point"] = String(alarm->getPointAddress());
        alarmsConf[alarmKey + "_enabled"] = alarm->isEnabled() ? "1" : "0";
        alarmsConf[alarmKey + "_hysteresis"] = String(alarm->getHysteresis());
    }
    
    alarmsConf.saveConfigFile();
    Serial.printf("Saved %d alarms to config\n", alarmIndex);
}




void ConfigManager::loadAlarmsConfig() {
    Serial.println("Loading alarms configuration...");
    ConfigAssist alarmsConf("/alarms.ini", false);
    
    // Clear existing configured alarms first
    for (auto alarm : controller.getConfiguredAlarms()) {
        delete alarm;
    }
    controller.clearConfiguredAlarms();
    
    int loadedCount = 0;
    int alarmIndex = 0;
    
    // Load alarms sequentially
    while (true) {
        String alarmKey = "alarm" + String(alarmIndex++);
        
        // Check if all required keys exist
        String typeKey = alarmKey + "_type";
        String priorityKey = alarmKey + "_priority";
        String pointKey = alarmKey + "_point";
        String enabledKey = alarmKey + "_enabled";
        int16_t hysteresis = alarmsConf(alarmKey + "_hysteresis").toInt();
        if (hysteresis == 0) hysteresis = 1; // Default to 1 if not set
        
        
        if (!alarmsConf.exists(typeKey)) {
            break; // No more alarms to load
        }
        
        // Get values and validate they're not empty
        String typeStr = alarmsConf(typeKey);
        String priorityStr = alarmsConf(priorityKey);
        String pointStr = alarmsConf(pointKey);
        String enabledStr = alarmsConf(enabledKey);
        
        // Skip empty entries (these were cleared)
        if (typeStr.isEmpty() || priorityStr.isEmpty() || 
            pointStr.isEmpty() || enabledStr.isEmpty()) {
            Serial.printf("Skipping empty alarm entry at index %d\n", alarmIndex - 1);
            continue;
        }
        
        // Convert and validate values
        int type = typeStr.toInt();
        int priority = priorityStr.toInt();
        int pointAddress = pointStr.toInt();
        bool enabled = (enabledStr == "1");
        
        // Validate enum ranges
        if (type < 0 || type > 3 || priority < 0 || priority > 3) {
            Serial.printf("Skipping alarm %d: invalid type (%d) or priority (%d)\n", 
                         alarmIndex - 1, type, priority);
            continue;
        }
        
        // Validate point address
        if (pointAddress < 0 || pointAddress >= 60) {
            Serial.printf("Skipping alarm %d: invalid point address (%d)\n", 
                         alarmIndex - 1, pointAddress);
            continue;
        }
        
        // Create alarm
        bool success = controller.addAlarm(
            static_cast<AlarmType>(type),
            pointAddress,
            static_cast<AlarmPriority>(priority)
        );
        
        if (success) {
            // Set enabled state
            Alarm* alarm = controller.findAlarm("alarm_" + String(pointAddress) + "_" + String(type));
            if (alarm) {
                alarm->setEnabled(enabled);
                alarm->setHysteresis(hysteresis);
                loadedCount++;
                Serial.printf("Loaded alarm: type=%d, priority=%d, point=%d, enabled=%s, hyst=%d\n",
                             type, priority, pointAddress, enabled ? "true" : "false", hysteresis);
            }
        }
    }
    
    Serial.printf("Loaded %d valid alarm configurations\n", loadedCount);
}

void ConfigManager::basicAPI(){

    // Add route for the main page
    server->on("/dashboard.html", HTTP_GET, [this]() {
        if (LittleFS.exists("/dashboard.html")) {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->sendHeader("Cache-Control", "max-age=3600");
            File file = LittleFS.open("/dashboard.html", "r");
            server->streamFile(file, "text/html");
            file.close();
            Serial.println("SERVER: /dashboard.html");
        } else {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->send(200, "text/html", "<html><body><h1>Temperature Monitoring System</h1><p><a href='/cfg'>Configuration</a></p><p><a href='/sensors.html'>Sensors</a></p></body></html>");
        }
    });
    
    // Add route for the sensors page
    server->on("/sensors.html", HTTP_GET, [this]() {
        if (LittleFS.exists("/sensors.html")) {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->sendHeader("Cache-Control", "max-age=3600");
            File file = LittleFS.open("/sensors.html", "r");
            server->streamFile(file, "text/html");
            file.close();
            Serial.println("SERVER: /sensors.html");
        } else {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/plain");
            server->sendHeader("Connection", "close");
            server->send(404, "text/plain", "Sensors page not found");
        }
    });
    server->on("/points.html", HTTP_GET, [this]() {
        if (LittleFS.exists("/points.html")) {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->sendHeader("Cache-Control", "max-age=3600");
            File file = LittleFS.open("/points.html", "r");
            server->streamFile(file, "text/html");
            Serial.println("SERVER: /points.html");
            file.close();
        } else {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/plain");
            server->sendHeader("Connection", "close");
            server->send(404, "text/plain", "Points page not found");
        }
    });




    server->on("/alarms.html", HTTP_GET, [this]() {
        if (LittleFS.exists("/alarms.html")) {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->sendHeader("Cache-Control", "max-age=3600");
            File file = LittleFS.open("/alarms.html", "r");
            server->streamFile(file, "text/html");
            file.close();
            Serial.println("SERVER: /alarms.html");
        } else {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->send(200, "text/html", "<html><body><h1>Temperature Monitoring System</h1><p><a href='/cfg'>Configuration</a></p><p><a href='/sensors.html'>Sensors</a></p></body></html>");
        }
    });

    server->on("/alarm-history.html", HTTP_GET, [this]() {
        if (LittleFS.exists("/alarm-history.html")) {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->sendHeader("Cache-Control", "max-age=3600");
            File file = LittleFS.open("/alarm-history.html", "r");
            server->streamFile(file, "text/html");
            file.close();
            Serial.println("SERVER: /alarm-history.html");
        } else {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->send(200, "text/html", "<html><body><h1>Temperature Monitoring System</h1><p><a href='/cfg'>Configuration</a></p><p><a href='/sensors.html'>Sensors</a></p></body></html>");
        }
    });

    server->on("/event-logs.html", HTTP_GET, [this]() {
        if (LittleFS.exists("/event-logs.html")) {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->sendHeader("Cache-Control", "max-age=3600");
            File file = LittleFS.open("/event-logs.html", "r");
            server->streamFile(file, "text/html");
            Serial.println("SERVER: /event-logs.html");
            file.close();
        } else {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/plain");
            server->sendHeader("Connection", "close");
            server->send(404, "text/plain", "event-logs page not found");
        }
    });

    server->on("/download-logs.html", HTTP_GET, [this]() {
        if (LittleFS.exists("/download-logs.html")) {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->sendHeader("Cache-Control", "max-age=3600");
            File file = LittleFS.open("/download-logs.html", "r");
            server->streamFile(file, "text/html");
            Serial.println("SERVER: /download-logs.html");
            file.close();
        } else {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/plain");
            server->sendHeader("Connection", "close");
            server->send(404, "text/plain", "download-logs page not found");
        }
    });

    

    // Add CORS support for OPTIONS requests
    server->on("/api/sensors", HTTP_OPTIONS, [this]() {
        server->sendHeader("HTTP/1.1 204 No Content", "");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->sendHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
        server->sendHeader("Access-Control-Allow-Headers", "Content-Type");
        server->send(204);
    });

};
void ConfigManager::sensorAPI(){
    // API endpoints for sensor data
    server->on("/api/sensors", HTTP_GET, [this]() {
        server->sendHeader("HTTP/1.1 200 OK", "");
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Connection", "close");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->sendHeader("Cache-Control", "no-store");
        server->send(200, "application/json", controller.getSensorsJson());
    });
    
    server->on("/api/status", HTTP_GET, [this]() {
        server->sendHeader("HTTP/1.1 200 OK", "");
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Connection", "close");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->sendHeader("Cache-Control", "no-store");
        server->send(200, "application/json", controller.getSystemStatusJson());
    });
    
    server->on("/api/reset-minmax", HTTP_POST, [this]() {
        controller.resetMinMaxValues();
        server->sendHeader("HTTP/1.1 200 OK", "");
        server->sendHeader("Content-Type", "text/plain");
        server->sendHeader("Connection", "close");
        server->send(200, "text/plain", "Min/Max values reset");
    });
    
    // API endpoint for sensor discovery
    server->on("/api/discover", HTTP_POST, [this]() {
        bool discoveredDS = controller.discoverDS18B20Sensors();
        bool discoveredPT = controller.discoverPTSensors();
        bool discovered = discoveredDS || discoveredPT;
        
        if (discovered) {

            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/plain");
            server->sendHeader("Connection", "close");
            server->send(200, "text/plain", "Sensors discovered");
        } else {
            server->sendHeader("HTTP/1.1 404 Not Found", "");
            server->sendHeader("Content-Type", "text/plain");
            server->sendHeader("Connection", "close");
            server->send(404, "text/plain", "No sensors found");
        }
    });

    // POST /api/sensor-bind
    server->on("/api/sensor-bind", HTTP_POST, [this]() {
        if (server->hasArg("plain")) {
            DynamicJsonDocument doc(256);
            
            DeserializationError err = deserializeJson(doc, server->arg("plain"));
            
            if (!err) {
                uint8_t pointAddress = doc["pointAddress"];
                if (doc.containsKey("romString")) {
                    Serial.println("ROM:\n" + doc.as<String>());
                    String rom = doc["romString"].as<String>();
                    if (controller.bindSensorToPointByRom(rom, pointAddress)) {
                        //Serial.println("Save points to config ROM\n");
                        savePointsConfig();
                        server->send(200, "text/plain", "Bound");
                        return;
                    }
                } else if (doc.containsKey("chipSelect")) {
                    int cs = doc["chipSelect"];
                    Serial.println("CS:\n" + doc.as<String>());
                    if (controller.bindSensorToPointByChipSelect(cs, pointAddress)) {
                        //Serial.println("Save points to config ROM\n");
                        savePointsConfig();
                        server->send(200, "text/plain", "Bound");
                        return;
                    }
                }
            }
        }
        server->send(400, "text/plain", "Bad Request");
    });

    // POST /api/sensor-unbind
    server->on("/api/sensor-unbind", HTTP_POST, [this]() {
        if (server->hasArg("plain")) {
            DynamicJsonDocument doc(128);
            DeserializationError err = deserializeJson(doc, server->arg("plain"));
            if (!err) {
                if (doc.containsKey("romString")) {
                    String rom = doc["romString"].as<String>();
                    // Find point bound to this ROM and unbind
                    for (uint8_t i = 0; i < 50; ++i) {
                        Sensor* bound = controller.getDS18B20Point(i)->getBoundSensor();
                        if (bound && bound->getDS18B20RomString() == rom) {
                            if(controller.unbindSensorFromPoint(i)){
                                savePointsConfig();
                            server->send(200, "text/plain", "Unbound");
                            return;

                            };
                            
                        }
                    }
                } else if (doc.containsKey("chipSelect")) {
                    int cs = doc["chipSelect"];
                    for (uint8_t i = 0; i < 10; ++i) {
                        Sensor* bound = controller.getPT1000Point(i)->getBoundSensor();
                        if (bound && bound->getPT1000ChipSelectPin() == cs) {
                            if(controller.unbindSensorFromPoint(50 + i)){
                                savePointsConfig();
                                server->send(200, "text/plain", "Unbound");
                                return;
                            };

                        }
                    }
                }
            }
        }
        server->send(400, "text/plain", "Bad Request");
    });



};
void ConfigManager::csvImportExportAPI(){

     // Combined points and alarms export
     server->on("/api/export/config", HTTP_GET, [this]() {
        String csv = csvManager.exportPointsWithAlarmsToCSV();
        server->sendHeader("Content-Type", "text/csv");
        server->sendHeader("Content-Disposition", "attachment; filename=config.csv");
        server->send(200, "text/csv", csv);
    });

    // Combined points and alarms import
    server->on("/api/import/config", HTTP_POST, [this]() {
        if (!server->hasArg("plain")) {
            server->send(400, "application/json", "{\"error\":\"No CSV data provided\"}");
            return;
        }
        
        bool success = csvManager.importPointsWithAlarmsFromCSV(server->arg("plain"));
        if (success) {
            savePointsConfig();
            saveAlarmsConfig();
            server->send(200, "application/json", "{\"status\":\"success\",\"message\":\"Configuration imported successfully\"}");
        } else {
            String error = csvManager.getLastError();
            server->send(400, "application/json", "{\"status\":\"error\",\"message\":\"" + error + "\"}");
        }
    });


    // Add these to your ConfigManager::begin() method after existing API endpoints

    // CSV Export endpoint
    server->on("/api/csv/export", HTTP_GET, [this]() {
        CSVConfigManager csvManager(controller);
        String csvData = csvManager.exportPointsWithAlarmsToCSV();
        
        if (csvData.length() > 0) {
            String filename = "temperature_config_" + String(millis()) + ".csv";
            server->sendHeader("Content-Type", "text/csv");
            server->sendHeader("Content-Disposition", "attachment; filename=\"" + filename + "\"");
            server->send(200, "text/csv", csvData);
        } else {
            server->send(500, "application/json", "{\"error\":\"Failed to generate CSV\"}");
        }
    });

    // CSV Import endpoint
   // In ConfigManager.cpp, update the CSV import endpoint:
    server->on("/api/csv/import", HTTP_POST, [this]() {
        // This will be called after file upload is complete
    }, [this]() {
        // Handle file upload
        HTTPUpload& upload = server->upload();
        static String csvContent;
        
        if (upload.status == UPLOAD_FILE_START) {
            csvContent = "";
            LoggerManager::info("CONFIG_IMPORT", 
                "CSV upload started - filename: " + String(upload.filename.c_str()));
            Serial.printf("Upload Start: %s\n", upload.filename.c_str());
        } else if (upload.status == UPLOAD_FILE_WRITE) {
            csvContent += String((char*)upload.buf, upload.currentSize);
        } else if (upload.status == UPLOAD_FILE_END) {
            Serial.printf("Upload End: %s (%u bytes)\n", upload.filename.c_str(), upload.totalSize);
            LoggerManager::info("CONFIG_IMPORT", 
                "CSV upload completed - size: " + String(upload.totalSize) + " bytes");
            
            // Process the uploaded CSV
            if (csvManager.importPointsWithAlarmsFromCSV(csvContent)) {
                saveAlarmsConfig();
                savePointsConfig();
                LoggerManager::info("CONFIG_IMPORT", "CSV import successful");
                server->send(200, "application/json", "{\"success\":true}");
            } else {
                String error = csvManager.getLastError();
                LoggerManager::error("CONFIG_IMPORT", "CSV import failed: " + error);
                server->send(400, "application/json", "{\"success\":false,\"error\":\"" + error + "\"}");
            }
            csvContent = "";
        }
    });
    // Settings CSV Export endpoint
    server->on("/api/settings/export", HTTP_GET, [this]() {
        String csvData = settingsCSVManager.exportSettingsToCSV();
        
        if (csvData.length() > 0) {
            String filename = "device_settings_" + String(millis()) + ".csv";
            server->sendHeader("Content-Type", "text/csv");
            server->sendHeader("Content-Disposition", "attachment; filename=\"" + filename + "\"");
            server->send(200, "text/csv", csvData);
        } else {
            server->send(500, "application/json", "{\"error\":\"Failed to generate settings CSV\"}");
        }
    });

    // Settings CSV Import endpoint
    server->on("/api/settings/import", HTTP_POST, [this]() {
        // This will be called after file upload is complete
    }, [this]() {
        // Handle file upload
        HTTPUpload& upload = server->upload();
        static String csvContent;
        
        if (upload.status == UPLOAD_FILE_START) {
            csvContent = "";
            Serial.printf("Settings Upload Start: %s\n", upload.filename.c_str());
        } else if (upload.status == UPLOAD_FILE_WRITE) {
            csvContent += String((char*)upload.buf, upload.currentSize);
        } else if (upload.status == UPLOAD_FILE_END) {
            Serial.printf("Settings Upload End: %s (%u bytes)\n", upload.filename.c_str(), upload.totalSize);
            
            // Process the uploaded CSV
            if (settingsCSVManager.importSettingsFromCSV(csvContent)) {
                // Save configuration after successful import
                conf.saveConfigFile();
                server->send(200, "application/json", "{\"success\":true,\"message\":\"Settings imported successfully. Device will restart.\"}");
                
                // Restart device to apply new settings
                delay(1000);
                ESP.restart();
            } else {
                String error = settingsCSVManager.getLastError();
                server->send(400, "application/json", "{\"success\":false,\"error\":\"" + error + "\"}");
            }
            csvContent = "";
        }
    });

};
void ConfigManager::pointsAPI(){
    // GET points
    server->on("/api/points", HTTP_GET, [this]() {
        server->sendHeader("Content-Type", "application/json");
        server->send(200, "application/json", controller.getPointsJson());
    });

    // PUT point update
    server->on("/api/points", HTTP_PUT, [this]() {
        if (!server->hasArg("plain")) {
            server->send(400, "application/json", "{\"error\":\"No data\"}");
            return;
        }
        DynamicJsonDocument doc(512);
        DeserializationError err = deserializeJson(doc, server->arg("plain"));
        if (err) {
            server->send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
            return;
        }
        Serial.println("/api/points HTTP_PUT:" + doc.as<String>());
        uint8_t address = doc["address"];
        String name = doc["name"].as<String>();
        int16_t low = doc["lowAlarmThreshold"];
        int16_t high = doc["highAlarmThreshold"];


        MeasurementPoint* point = controller.getMeasurementPoint(address);
        if (!point) {
            server->send(404, "application/json", "{\"error\":\"Point not found\"}");
            return;
        }
        point->setName(name);
        point->setLowAlarmThreshold(low);
        point->setHighAlarmThreshold(high);
        Serial.printf("Point: %s. LAS: %d, HAS: %d\n Delay....\n", point->getName(), point->getLowAlarmThreshold(), point->getHighAlarmThreshold());
        delay(5000);
        controller.applyConfigToRegisterMap();
        // Save to config if needed
        savePointsConfig(); // implement this to persist changes

        server->send(200, "application/json", "{\"success\":true}");
    });

};
void ConfigManager::alarmsAPI(){

    // Get alarms configuration
    server->on("/api/alarms", HTTP_GET, [this]() {
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", controller.getAlarmsJson());
    });

    // Add/Update alarm configuration
    server->on("/api/alarms", HTTP_POST, [this]() {
        if (!server->hasArg("plain")) {
            server->send(400, "application/json", "{\"error\":\"No data\"}");
            return;
        }
        
        DynamicJsonDocument doc(512);
        DeserializationError err = deserializeJson(doc, server->arg("plain"));
        if (err) {
            server->send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
            return;
        }
        
        AlarmType type = static_cast<AlarmType>(doc["type"].as<int>());
        uint8_t pointAddress = doc["pointAddress"].as<int>();
        AlarmPriority priority = static_cast<AlarmPriority>(doc["priority"].as<int>());
        
        bool success = controller.addAlarm(type, pointAddress, priority);
        if (success) {
            saveAlarmsConfig();
            server->send(200, "application/json", "{\"status\":\"success\"}");
        } else {
            server->send(400, "application/json", "{\"error\":\"Failed to add alarm\"}");
        }
    });

    // Delete alarm configuration
    server->on("/api/alarms", HTTP_DELETE, [this]() {
        if (!server->hasArg("configKey")) {
            server->send(400, "application/json", "{\"error\":\"No configKey provided\"}");
            return;
        }
        
        String configKey = server->arg("configKey");
        bool success = controller.removeAlarm(configKey);
        if (success) {
            saveAlarmsConfig();
            server->send(200, "application/json", "{\"status\":\"deleted\"}");
        } else {
            server->send(404, "application/json", "{\"error\":\"Alarm not found\"}");
        }
    });

    // Add these endpoints to your setupWebServer() method in ConfigManager.cpp

    // Get alarms configuration
    server->on("/api/alarms", HTTP_GET, [this]() {
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", controller.getAlarmsJson());
    });

    // Add/Update alarm configuration
    server->on("/api/alarms", HTTP_POST, [this]() {
        if (!server->hasArg("plain")) {
            server->send(400, "application/json", "{\"error\":\"No data\"}");
            return;
        }
        
        DynamicJsonDocument doc(512);
        DeserializationError err = deserializeJson(doc, server->arg("plain"));
        if (err) {
            server->send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
            return;
        }
        
        AlarmType type = static_cast<AlarmType>(doc["type"].as<int>());
        uint8_t pointAddress = doc["pointAddress"].as<int>();
        AlarmPriority priority = static_cast<AlarmPriority>(doc["priority"].as<int>());
        
        bool success = controller.addAlarm(type, pointAddress, priority);
        if (success) {
            saveAlarmsConfig();
            server->send(200, "application/json", "{\"status\":\"success\"}");
        } else {
            server->send(400, "application/json", "{\"error\":\"Failed to add alarm\"}");
        }
    });

    // Update alarm configuration
    server->on("/api/alarms", HTTP_PUT, [this]() {
        if (!server->hasArg("plain")) {
            server->send(400, "application/json", "{\"error\":\"No data\"}");
            return;
        }
        
        DynamicJsonDocument doc(512);
        DeserializationError err = deserializeJson(doc, server->arg("plain"));
        if (err) {
            server->send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
            return;
        }
        
        String configKey = doc["configKey"].as<String>();
        AlarmPriority priority = static_cast<AlarmPriority>(doc["priority"].as<int>());
        bool enabled = doc["enabled"].as<bool>();
        
        bool success = controller.updateAlarm(configKey, priority, enabled);
        if (success) {
            saveAlarmsConfig();
            server->send(200, "application/json", "{\"status\":\"updated\"}");
        } else {
            server->send(404, "application/json", "{\"error\":\"Alarm not found\"}");
        }
    });

    // Delete alarm configuration
    server->on("/api/alarms", HTTP_DELETE, [this]() {
        if (!server->hasArg("configKey")) {
            server->send(400, "application/json", "{\"error\":\"No configKey provided\"}");
            return;
        }
        
        String configKey = server->arg("configKey");
        bool success = controller.removeAlarm(configKey);
        if (success) {
            saveAlarmsConfig();
            server->send(200, "application/json", "{\"status\":\"deleted\"}");
        } else {
            server->send(404, "application/json", "{\"error\":\"Alarm not found\"}");
        }
    });

    // Acknowledge specific alarm
    server->on("/api/alarms/acknowledge", HTTP_POST, [this]() {
        if (!server->hasArg("plain")) {
            server->send(400, "application/json", "{\"error\":\"No data\"}");
            return;
        }

        DynamicJsonDocument doc(512);
        DeserializationError err = deserializeJson(doc, server->arg("plain"));
        if (err) {
            server->send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
            return;
        }

        String configKey = doc["configKey"].as<String>();
        
        // Find alarm in configured alarms
        Alarm* alarm = controller.findAlarm(configKey);
        if (!alarm) {
            server->send(404, "application/json", "{\"error\":\"Alarm not found\"}");
            return;
        }

        // Find corresponding active alarm and acknowledge it
        bool acknowledged = false;
        for (auto activeAlarm : controller.getActiveAlarms()) {
            if (activeAlarm->getSource() == alarm->getSource() && 
                activeAlarm->getType() == alarm->getType()) {
                activeAlarm->acknowledge();
                acknowledged = true;
                Serial.printf("Acknowledged alarm: %s for point %d\n", 
                            activeAlarm->getTypeString().c_str(),
                            activeAlarm->getSource()->getAddress());
                break;
            }
        }

        if (acknowledged) {
            server->send(200, "application/json", "{\"status\":\"acknowledged\"}");
        } else {
            server->send(404, "application/json", "{\"error\":\"No active alarm found to acknowledge\"}");
        }
    });

    // Acknowledge all active alarms
    server->on("/api/alarms/acknowledge-all", HTTP_POST, [this]() {
        std::vector<Alarm*> activeAlarms = controller.getActiveAlarms();
        int acknowledgedCount = 0;
        
        for (auto alarm : activeAlarms) {
            if (!alarm->isAcknowledged()) {
                alarm->acknowledge();
                acknowledgedCount++;
                Serial.printf("Acknowledged alarm: %s for point %d\n", 
                            alarm->getTypeString().c_str(),
                            alarm->getSource() ? alarm->getSource()->getAddress() : -1);
            }
        }
        
        DynamicJsonDocument response(256);
        response["status"] = "success";
        response["acknowledgedCount"] = acknowledgedCount;
        response["message"] = String(acknowledgedCount) + " alarms acknowledged";
        
        String output;
        serializeJson(response, output);
        server->send(200, "application/json", output);
    });

    // Clear resolved alarms
    server->on("/api/alarms/clear-resolved", HTTP_POST, [this]() {
        std::vector<Alarm*> configuredAlarms = controller.getConfiguredAlarms();
        int clearedCount = 0;
        
        // Remove resolved alarms from configured alarms
        for (auto it = configuredAlarms.begin(); it != configuredAlarms.end();) {
            if ((*it)->isResolved()) {
                String configKey = (*it)->getConfigKey();
                bool removed = controller.removeAlarm(configKey);
                if (removed) {
                    clearedCount++;
                    Serial.printf("Cleared resolved alarm: %s\n", configKey.c_str());
                }
                // Note: iterator is handled by removeAlarm method
                it = configuredAlarms.begin(); // Restart iteration after removal
            } else {
                ++it;
            }
        }
        
        // Save configuration after clearing
        if (clearedCount > 0) {
            saveAlarmsConfig();
        }
        
        DynamicJsonDocument response(256);
        response["status"] = "success";
        response["clearedCount"] = clearedCount;
        response["message"] = String(clearedCount) + " resolved alarms cleared";
        
        String output;
        serializeJson(response, output);
        server->send(200, "application/json", output);
    });

    // Get active alarms only (for dashboard/monitoring)
    server->on("/api/alarms/active", HTTP_GET, [this]() {
        DynamicJsonDocument doc(4096);
        JsonArray alarmArray = doc.createNestedArray("alarms");
        
        for (auto alarm : controller.getActiveAlarms()) {
            JsonObject obj = alarmArray.createNestedObject();
            obj["type"] = static_cast<int>(alarm->getType());
            obj["stage"] = static_cast<int>(alarm->getStage());
            obj["priority"] = static_cast<int>(alarm->getPriority());
            obj["timestamp"] = alarm->getTimestamp();
            obj["acknowledgedTime"] = alarm->getAcknowledgedTime();
            obj["message"] = alarm->getMessage();
            obj["isActive"] = alarm->isActive();
            obj["isAcknowledged"] = alarm->isAcknowledged();
            
            if (alarm->getSource()) {
                obj["pointAddress"] = alarm->getSource()->getAddress();
                obj["pointName"] = alarm->getSource()->getName();
                obj["currentTemp"] = alarm->getSource()->getCurrentTemp();
            }
        }
        
        String output;
        serializeJson(doc, output);
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", output);
    });

    // Get alarm statistics
    server->on("/api/alarms/stats", HTTP_GET, [this]() {
        std::vector<Alarm*> activeAlarms = controller.getActiveAlarms();
        
        int criticalCount = 0, highCount = 0, mediumCount = 0, lowCount = 0;
        int newCount = 0, activeCount = 0, acknowledgedCount = 0;
        
        for (auto alarm : activeAlarms) {
            // Count by priority
            switch (alarm->getPriority()) {
                case AlarmPriority::PRIORITY_CRITICAL: criticalCount++; break;
                case AlarmPriority::PRIORITY_HIGH: highCount++; break;
                case AlarmPriority::PRIORITY_MEDIUM: mediumCount++; break;
                case AlarmPriority::PRIORITY_LOW: lowCount++; break;
            }
            
            // Count by stage
            switch (alarm->getStage()) {
                case AlarmStage::NEW: newCount++; break;
                case AlarmStage::ACTIVE: activeCount++; break;
                case AlarmStage::ACKNOWLEDGED: acknowledgedCount++; break;
                default: break;
            }
        }
        
        DynamicJsonDocument doc(512);
        doc["totalActive"] = activeAlarms.size();
        doc["totalConfigured"] = controller.getAlarmCount();
        
        JsonObject byPriority = doc.createNestedObject("byPriority");
        byPriority["critical"] = criticalCount;
        byPriority["high"] = highCount;
        byPriority["medium"] = mediumCount;
        byPriority["low"] = lowCount;
        
        JsonObject byStage = doc.createNestedObject("byStage");
        byStage["new"] = newCount;
        byStage["active"] = activeCount;
        byStage["acknowledged"] = acknowledgedCount;
        
        String output;
        serializeJson(doc, output);
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", output);
    });

    // Get acknowledged delays
    server->on("/api/alarms/delays", HTTP_GET, [this]() {
        DynamicJsonDocument doc(512);
        doc["critical"] = getAcknowledgedDelayCritical();
        doc["high"] = getAcknowledgedDelayHigh();
        doc["medium"] = getAcknowledgedDelayMedium();
        doc["low"] = getAcknowledgedDelayLow();
        
        String output;
        serializeJson(doc, output);
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", output);
    });

    // Update acknowledged delays
    server->on("/api/alarms/delays", HTTP_PUT, [this]() {
        if (!server->hasArg("plain")) {
            server->send(400, "application/json", "{\"error\":\"No data\"}");
            return;
        }
        
        DynamicJsonDocument doc(512);
        DeserializationError err = deserializeJson(doc, server->arg("plain"));
        if (err) {
            server->send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
            return;
        }
        
        bool updated = false;
        
        if (doc.containsKey("critical")) {
            int minutes = doc["critical"].as<int>();
            if (minutes >= 1 && minutes <= 1440) {
                conf["ack_delay_critical"] = String(minutes);
                controller.setAcknowledgedDelayCritical(minutes * 60 * 1000);
                updated = true;
            }
        }
        
        if (doc.containsKey("high")) {
            int minutes = doc["high"].as<int>();
            if (minutes >= 1 && minutes <= 1440) {
                conf["ack_delay_high"] = String(minutes);
                controller.setAcknowledgedDelayHigh(minutes * 60 * 1000);
                updated = true;
            }
        }
        
        if (doc.containsKey("medium")) {
            int minutes = doc["medium"].as<int>();
            if (minutes >= 1 && minutes <= 1440) {
                conf["ack_delay_medium"] = String(minutes);
                controller.setAcknowledgedDelayMedium(minutes * 60 * 1000);
                updated = true;
            }
        }
        
        if (doc.containsKey("low")) {
            int minutes = doc["low"].as<int>();
            if (minutes >= 1 && minutes <= 1440) {
                conf["ack_delay_low"] = String(minutes);
                controller.setAcknowledgedDelayLow(minutes * 60 * 1000);
                updated = true;
            }
        }
        
        if (updated) {
            conf.saveConfigFile();
            server->send(200, "application/json", "{\"status\":\"updated\"}");
        } else {
            server->send(400, "application/json", "{\"error\":\"No valid delays provided\"}");
        }
    });

};

// Add these methods to your ConfigManager.cpp file in the logsAPI() function

void ConfigManager::logsAPI() {
    // Get alarm history
    server->on("/api/alarm-history", HTTP_GET, [this]() {
        String startDate = server->arg("start");
        String endDate = server->arg("end");
        
        if (startDate.isEmpty() || endDate.isEmpty()) {
            server->send(400, "application/json", "{\"success\":false,\"error\":\"Missing date parameters\"}");
            return;
        }
        
        // Use static method
        String historyJson = LoggerManager::getAlarmHistoryJson(startDate, endDate);
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", historyJson);
    });
    
    // Export alarm history as CSV
    server->on("/api/alarm-history/export", HTTP_GET, [this]() {
        String startDate = server->arg("start");
        String endDate = server->arg("end");
        
        if (startDate.isEmpty() || endDate.isEmpty()) {
            server->send(400, "application/json", "{\"success\":false,\"error\":\"Missing date parameters\"}");
            return;
        }
        
        // Use static method
        String csvData = LoggerManager::getAlarmHistoryCsv(startDate, endDate);
        
        if (csvData.length() > 0) {
            String filename = "alarm_history_" + startDate + "_to_" + endDate + ".csv";
            server->sendHeader("Content-Type", "text/csv");
            server->sendHeader("Content-Disposition", "attachment; filename=\"" + filename + "\"");
            server->send(200, "text/csv", csvData);
        } else {
            server->send(404, "application/json", "{\"success\":false,\"error\":\"No alarm history found\"}");
        }
    });
    
    // Get available alarm log files
    server->on("/api/alarm-history/files", HTTP_GET, [this]() {
        DynamicJsonDocument doc(2048);
        JsonArray filesArray = doc.createNestedArray("files");
        
        std::vector<String> files = LoggerManager::getAlarmStateLogFiles();
        for (const String& file : files) {
            filesArray.add(file);
        }
        
        String output;
        serializeJson(doc, output);
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", output);
    });

    // NEW EVENT LOG ENDPOINTS
    
    // Get event logs
    server->on("/api/event-logs", HTTP_GET, [this]() {
        String startDate = server->arg("start");
        String endDate = server->arg("end");
        
        if (startDate.isEmpty() || endDate.isEmpty()) {
            server->send(400, "application/json", "{\"success\":false,\"error\":\"Missing date parameters\"}");
            return;
        }
        
        String eventLogsJson = LoggerManager::getEventLogsJson(startDate, endDate);
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", eventLogsJson);
    });
    
    // Export event logs as CSV
    server->on("/api/event-logs/export", HTTP_GET, [this]() {
        String startDate = server->arg("start");
        String endDate = server->arg("end");
        
        if (startDate.isEmpty() || endDate.isEmpty()) {
            server->send(400, "application/json", "{\"success\":false,\"error\":\"Missing date parameters\"}");
            return;
        }
        
        String csvData = LoggerManager::getEventLogsCsv(startDate, endDate);
        
        if (csvData.length() > 0) {
            String filename = "event_logs_" + startDate + "_to_" + endDate + ".csv";
            server->sendHeader("Content-Type", "text/csv");
            server->sendHeader("Content-Disposition", "attachment; filename=\"" + filename + "\"");
            server->send(200, "text/csv", csvData);
        } else {
            server->send(404, "application/json", "{\"success\":false,\"error\":\"No event logs found\"}");
        }
    });
    
    // Get available event log files
    server->on("/api/event-logs/files", HTTP_GET, [this]() {
        DynamicJsonDocument doc(2048);
        JsonArray filesArray = doc.createNestedArray("files");
        
        std::vector<String> files = LoggerManager::getEventLogFilesStatic();
        for (const String& file : files) {
            filesArray.add(file);
        }
        
        String output;
        serializeJson(doc, output);
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", output);
    });
    
    // Get event log statistics
    server->on("/api/event-logs/stats", HTTP_GET, [this]() {
        String startDate = server->arg("start");
        String endDate = server->arg("end");
        
        if (startDate.isEmpty() || endDate.isEmpty()) {
            server->send(400, "application/json", "{\"success\":false,\"error\":\"Missing date parameters\"}");
            return;
        }
        
        String statsJson = LoggerManager::getEventLogStatsJson(startDate, endDate);
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", statsJson);
    });
}

void ConfigManager::downloadAPI() {
    // API endpoint to list all data log files
    server->on("/api/data-log-files", HTTP_GET, [this]() {
        DynamicJsonDocument doc(4096);
        doc["success"] = true;
        JsonArray filesArray = doc.createNestedArray("files");
        
        // Get list of temperature data log files
        std::vector<String> files = LoggerManager::getLogFiles();
        for (const String& filename : files) {
            JsonObject fileObj = filesArray.createNestedObject();
            fileObj["filename"] = filename;
            
            // Get file info using static method
            size_t fileSize;
            String date;
            if (LoggerManager::getFileInfo(filename, "data", fileSize, date)) {
                fileObj["size"] = fileSize;
                fileObj["date"] = date;
            } else {
                fileObj["size"] = 0;
                fileObj["date"] = "";
            }
        }
        
        String output;
        serializeJson(doc, output);
        
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->sendHeader("Cache-Control", "no-store");
        server->send(200, "application/json", output);
    });

    // API endpoint to list event log files
    server->on("/api/event-log-files", HTTP_GET, [this]() {
        DynamicJsonDocument doc(4096);
        doc["success"] = true;
        JsonArray filesArray = doc.createNestedArray("files");
        
        // Get list of event log files
        std::vector<String> files = LoggerManager::getEventLogFilesStatic();
        for (const String& filename : files) {
            JsonObject fileObj = filesArray.createNestedObject();
            fileObj["filename"] = filename;
            
            // Get file info using static method
            size_t fileSize;
            String date;
            if (LoggerManager::getFileInfo(filename, "event", fileSize, date)) {
                fileObj["size"] = fileSize;
                fileObj["date"] = date;
            } else {
                fileObj["size"] = 0;
                fileObj["date"] = "";
            }
        }
        
        String output;
        serializeJson(doc, output);
        
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->sendHeader("Cache-Control", "no-store");
        server->send(200, "application/json", output);
    });

    // API endpoint to list alarm log files
    server->on("/api/alarm-log-files", HTTP_GET, [this]() {
        DynamicJsonDocument doc(4096);
        doc["success"] = true;
        JsonArray filesArray = doc.createNestedArray("files");
        
        // Get list of alarm state log files
        std::vector<String> files = LoggerManager::getAlarmStateLogFiles();
        for (const String& filename : files) {
            JsonObject fileObj = filesArray.createNestedObject();
            fileObj["filename"] = filename;
            
            // Get file info using static method
            size_t fileSize;
            String date;
            if (LoggerManager::getFileInfo(filename, "alarm", fileSize, date)) {
                fileObj["size"] = fileSize;
                fileObj["date"] = date;
            } else {
                fileObj["size"] = 0;
                fileObj["date"] = "";
            }
        }
        
        String output;
        serializeJson(doc, output);
        
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->sendHeader("Cache-Control", "no-store");
        server->send(200, "application/json", output);
    });

    // API endpoint to download temperature data log files
    server->on("/api/data-log-download", HTTP_GET, [this]() {
        String filename = server->arg("file");
        
        if (filename.isEmpty()) {
            server->send(400, "text/plain", "Missing file parameter");
            return;
        }
        
        // Security check - only allow files that start with "temp_log_" and end with ".csv"
        if (!filename.startsWith("temp_log_") || !filename.endsWith(".csv")) {
            server->send(403, "text/plain", "Invalid file type");
            return;
        }
        
        // Open file using static method
        File file = LoggerManager::openLogFile(filename, "data");
        if (!file) {
            server->send(404, "text/plain", "File not found");
            return;
        }
        
        // Set headers for file download
        server->sendHeader("Content-Type", "text/csv");
        server->sendHeader("Content-Disposition", "attachment; filename=" + filename);
        server->sendHeader("Access-Control-Allow-Origin", "*");
        
        // Stream the file directly
        server->streamFile(file, "text/csv");
        file.close();
        
        Serial.printf("Downloaded data log file: %s\n", filename.c_str());
    });

    // API endpoint to download event log files
    server->on("/api/event-log-download", HTTP_GET, [this]() {
        String filename = server->arg("file");
        
        if (filename.isEmpty()) {
            server->send(400, "text/plain", "Missing file parameter");
            return;
        }
        
        // Security check - only allow files that start with "events_" and end with ".csv"
        if (!filename.startsWith("events_") || !filename.endsWith(".csv")) {
            server->send(403, "text/plain", "Invalid file type");
            return;
        }
        
        // Open file using static method
        File file = LoggerManager::openLogFile(filename, "event");
        if (!file) {
            server->send(404, "text/plain", "File not found");
            return;
        }
        
        // Set headers for file download
        server->sendHeader("Content-Type", "text/csv");
        server->sendHeader("Content-Disposition", "attachment; filename=" + filename);
        server->sendHeader("Access-Control-Allow-Origin", "*");
        
        // Stream the file directly
        server->streamFile(file, "text/csv");
        file.close();
        
        Serial.printf("Downloaded event log file: %s\n", filename.c_str());
    });

    // API endpoint to download alarm state log files
    server->on("/api/alarm-log-download", HTTP_GET, [this]() {
        String filename = server->arg("file");
        
        if (filename.isEmpty()) {
            server->send(400, "text/plain", "Missing file parameter");
            return;
        }
        
        // Security check - only allow files that start with "alarm_states_" and end with ".csv"
        if (!filename.startsWith("alarm_states_") || !filename.endsWith(".csv")) {
            server->send(403, "text/plain", "Invalid file type");
            return;
        }
        
        // Open file using static method
        File file = LoggerManager::openLogFile(filename, "alarm");
        if (!file) {
            server->send(404, "text/plain", "File not found");
            return;
        }
        
        // Set headers for file download
        server->sendHeader("Content-Type", "text/csv");
        server->sendHeader("Content-Disposition", "attachment; filename=" + filename);
        server->sendHeader("Access-Control-Allow-Origin", "*");
        
        // Stream the file directly
        server->streamFile(file, "text/csv");
        file.close();
        
        Serial.printf("Downloaded alarm state log file: %s\n", filename.c_str());
    });
}

-------- [ Separator ] ------

File Name: src/IndicatorInterface.cpp
Size: 29.11 KB
Code:
#include "IndicatorInterface.h"


// Static instance for interrupt handling
IndicatorInterface* IndicatorInterface::_instance = nullptr;

IndicatorInterface::IndicatorInterface(TwoWire& i2cBus, uint8_t pcf_i2cAddress, int intPin)
    : _i2cBus(&i2cBus), _pcf_i2cAddress(pcf_i2cAddress), _intPin(intPin), _pcf8575(pcf_i2cAddress),
      _directionMask(0x0000), _modeMask(0x0000), _currentState(0xFFFF), _lastState(0xFFFF),
      _lastReadTime(0), _pollInterval(50), _interruptFlag(false), _useInterrupts(false),
      _interruptCallback(nullptr),
      _oledSleepDelay(30000), _oledLines(3), _textBufferSize(0), _oledOn(true),
      _oledBlink(false), _blinkTimeOn(500), _blinkTimeOff(500), _lastBlinkTime(0),
      _blinkState(true), _lastActivityTime(0), _oledSleeping(false),
      _lastScrollTime(0), _scrollDelay(200), _charWidth(6), _lineHeight(12),
      _maxCharsPerLine(21),
      _savedTextBufferSize(0), _savedOledLines(3), _isBlinkingOK(false), 
      _isBlinkingCross(false), _blinkDelayTime(500), _lastBlinkToggle(0), _blinkShowSpecial(true)  {
    
    // Set static instance for interrupt handling
    _instance = this;
    
    // Configure interrupt usage
    _useInterrupts = (intPin >= 0);

    // Initialize scroll offsets
    for (int i = 0; i < 5; i++) {
        _scrollOffset[i] = 0;
    }
    
}

U8G2_SH1106_128X64_NONAME_F_HW_I2C IndicatorInterface::u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);

IndicatorInterface::~IndicatorInterface() {
    if (_useInterrupts && _intPin >= 0) {
        detachInterrupt(digitalPinToInterrupt(_intPin));
    }
    _instance = nullptr;
}

bool IndicatorInterface::begin() {
    // Initialize I2C if not already done
    if (!_i2cBus) {
        return false;
    }
    
    // Initialize PCF8575
    if (!_pcf8575.begin()) {
        return false;
    }
    
    // Configure interrupt pin if specified
    if (_useInterrupts) {
        _configureInterruptPin();
    }
    
    // Initialize all pins as inputs (HIGH state)
    _pcf8575.write16(0xFFFF);
    delay(100);
    _clearInterrupt();
    
    // Read initial state
    _currentState = _readPCF();
    _lastState = _currentState;
    _lastReadTime = millis();

    //OLED INIT
    u8g2.begin();
    _initOLED();
    
    return true;
}

void IndicatorInterface::_configureInterruptPin() {
    if (_intPin < 0) return;
    
    // Configure pin based on ESP32 capabilities
    if (_intPin == 34 || _intPin == 35 || _intPin == 36 || _intPin == 39) {
        // Input-only pins without internal pull-up
        pinMode(_intPin, INPUT);
        // Note: External pull-up resistor (4.7kŒ©) required!
    } else {
        // Regular GPIO pins with internal pull-up
        pinMode(_intPin, INPUT_PULLUP);
    }
    
    // Attach interrupt
    attachInterrupt(digitalPinToInterrupt(_intPin), _staticInterruptHandler, FALLING);
}

void IndicatorInterface::setDirection(uint16_t directionMask) {
    _directionMask = directionMask;
    
    // Update PCF8575 state to reflect direction changes
    uint16_t newState = _currentState;
    
    // Set input pins HIGH (input mode for PCF8575)
    for (int i = 0; i < 16; i++) {
        if (!isOutput(i)) {
            newState |= (1 << i);
        }
    }
    
    _writePCF(newState);
}

void IndicatorInterface::setMode(uint16_t modeMask) {
    _modeMask = modeMask;
}

void IndicatorInterface::setPortNames(const std::map<std::string, uint8_t>& portNames) {
    _portNames = portNames;
    
    // Build reverse mapping
    _portNumbers.clear();
    for (const auto& pair : _portNames) {
        _portNumbers[pair.second] = pair.first;
    }
}

void IndicatorInterface::setPortName(const std::string& name, uint8_t portNumber) {
    if (portNumber > 15) return;
    
    _portNames[name] = portNumber;
    _portNumbers[portNumber] = name;
}

bool IndicatorInterface::writePort(const std::string& portName, bool state) {
    auto it = _portNames.find(portName);
    if (it == _portNames.end()) {
        return false;
    }
    return writePort(it->second, state);
}

bool IndicatorInterface::writePort(uint8_t portNumber, bool state) {
    if (portNumber > 15 || !isOutput(portNumber)) {
        return false;
    }
    
    // Apply mode logic (inversion if needed)
    bool actualState = _applyModeLogic(portNumber, state);
    
    // Update current state
    uint16_t newState = _currentState;
    
    // Always keep input pins HIGH
    for (int i = 0; i < 16; i++) {
        if (!isOutput(i)) {
            newState |= (1 << i);
        }
    }
    
    // Set the specific output pin
    if (actualState) {
        newState |= (1 << portNumber);
    } else {
        newState &= ~(1 << portNumber);
    }
    
    _writePCF(newState);
    return true;
}

void IndicatorInterface::writePorts(uint16_t portMask) {
    uint16_t newState = _currentState;
    
    // Apply direction mask - only write to outputs
    for (int i = 0; i < 16; i++) {
        if (isOutput(i)) {
            bool state = (portMask >> i) & 0x01;
            bool actualState = _applyModeLogic(i, state);
            
            if (actualState) {
                newState |= (1 << i);
            } else {
                newState &= ~(1 << i);
            }
        } else {
            // Keep input pins HIGH
            newState |= (1 << i);
        }
    }
    
    _writePCF(newState);
}

void IndicatorInterface::setAllOutputs(bool state) {
    uint16_t newState = _currentState;
    
    for (int i = 0; i < 16; i++) {
        if (isOutput(i)) {
            bool actualState = _applyModeLogic(i, state);
            
            if (actualState) {
                newState |= (1 << i);
            } else {
                newState &= ~(1 << i);
            }
        } else {
            // Keep input pins HIGH
            newState |= (1 << i);
        }
    }
    
    _writePCF(newState);
}

void IndicatorInterface::setAllOutputsHigh() {
    setAllOutputs(true);
}

void IndicatorInterface::setAllOutputsLow() {
    setAllOutputs(false);
}

uint16_t IndicatorInterface::getCurrentState() {
    if (_useInterrupts) {
        // In interrupt mode, state is updated automatically
        return _currentState;
    } else {
        // In polling mode, read current state
        if (millis() - _lastReadTime >= _pollInterval) {
            _updateState();
        }
        return _currentState;
    }
}

bool IndicatorInterface::readPort(const std::string& portName) {
    auto it = _portNames.find(portName);
    if (it == _portNames.end()) {
        return false;
    }
    return readPort(it->second);
}

bool IndicatorInterface::readPort(uint8_t portNumber) {
    if (portNumber > 15) {
        return false;
    }
    
    uint16_t currentState = getCurrentState();
    bool rawState = (currentState >> portNumber) & 0x01;
    
    // Apply mode logic (reverse inversion for reading)
    return _reverseModeLogic(portNumber, rawState);
}

bool IndicatorInterface::isOutput(uint8_t portNumber) {
    return (_directionMask >> portNumber) & 0x01;
}

bool IndicatorInterface::isInput(uint8_t portNumber) {
    return !isOutput(portNumber);
}

bool IndicatorInterface::isInverted(uint8_t portNumber) {
    return (_modeMask >> portNumber) & 0x01;
}

uint8_t IndicatorInterface::getPortNumber(const std::string& portName) {
    auto it = _portNames.find(portName);
    return (it != _portNames.end()) ? it->second : 255;
}

std::string IndicatorInterface::getPortName(uint8_t portNumber) {
    auto it = _portNumbers.find(portNumber);
    return (it != _portNumbers.end()) ? it->second : "";
}

// void IndicatorInterface::handleInterrupt() {
//     if (_interruptFlag) {
//         _interruptFlag = false;
//         _updateState();
//     }
// }

void IndicatorInterface::setInterruptCallback(void (*callback)(uint16_t currentState, uint16_t changedPins)) {
    _interruptCallback = callback;
}

void IndicatorInterface::printPortStates() {
    uint16_t state = getCurrentState();
    
    Serial.println("=== Port States ===");
    Serial.print("Raw state: 0x");
    Serial.println(state, HEX);
    
    for (int i = 15; i >= 0; i--) {
        bool rawState = (state >> i) & 0x01;
        bool logicalState = _reverseModeLogic(i, rawState);
        
        Serial.print("P");
        Serial.print(i);
        Serial.print(": ");
        Serial.print(rawState ? "HIGH" : "LOW");
        Serial.print(" (");
        Serial.print(isOutput(i) ? "OUT" : "IN");
        if (isInverted(i)) Serial.print(",INV");
        Serial.print(") = ");
        Serial.print(logicalState ? "TRUE" : "FALSE");
        
        std::string name = getPortName(i);
        if (!name.empty()) {
            Serial.print(" [");
            Serial.print(name.c_str());
            Serial.print("]");
        }
        Serial.println();
    }
}

void IndicatorInterface::printConfiguration() {
    Serial.println("=== Configuration ===");
    Serial.print("I2C Address: 0x");
    Serial.println(_pcf_i2cAddress, HEX);
    Serial.print("INT Pin: ");
    Serial.println(_intPin);
    Serial.print("Use Interrupts: ");
    Serial.println(_useInterrupts ? "YES" : "NO");
    Serial.print("Direction Mask: 0x");
    Serial.println(_directionMask, HEX);
    Serial.print("Mode Mask: 0x");
    Serial.println(_modeMask, HEX);
    
    Serial.println("Port Names:");
    for (const auto& pair : _portNames) {
        Serial.print("  ");
        Serial.print(pair.first.c_str());
        Serial.print(" = P");
        Serial.println(pair.second);
    }
}

// Private methods
void IndicatorInterface::_updateState() {
    uint16_t newState = _readPCF();
    uint16_t changedPins = _currentState ^ newState;
    
    _lastState = _currentState;
    _currentState = newState;
    _lastReadTime = millis();
    
    // Call interrupt callback if pins changed
    if (changedPins != 0 && _interruptCallback) {
        _interruptCallback(_currentState, changedPins);
    }
}

void IndicatorInterface::_clearInterrupt() {
    _pcf8575.read16();
    delay(1);
    _pcf8575.read16();
}

uint16_t IndicatorInterface::_readPCF() {
    return _pcf8575.read16();
}

void IndicatorInterface::_writePCF(uint16_t state) {
    _pcf8575.write16(state);
    delay(5);
    _clearInterrupt();
    _currentState = state;
}

bool IndicatorInterface::_applyModeLogic(uint8_t portNumber, bool state) {
    // Fixed: Normal mode = no inversion, Inverted mode = invert
    return isInverted(portNumber) ? !state : state;
}

bool IndicatorInterface::_reverseModeLogic(uint8_t portNumber, bool state) {
    // Fixed: For reading, apply same logic as writing
    return isInverted(portNumber) ? !state : state;
}

void IRAM_ATTR IndicatorInterface::_staticInterruptHandler() {
    if (_instance) {
        _instance->_interruptFlag = true;
    }
}


void IndicatorInterface::setPortInverted(const std::string& portName, bool inverted) {
    auto it = _portNames.find(portName);
    if (it != _portNames.end()) {
        setPortInverted(it->second, inverted);
    }
}

void IndicatorInterface::setPortInverted(uint8_t portNumber, bool inverted) {
    if (portNumber > 15) return;
    
    if (inverted) {
        _modeMask |= (1 << portNumber);   // Set bit to 1 for inverted
    } else {
        _modeMask &= ~(1 << portNumber);  // Set bit to 0 for normal
    }
}


void IndicatorInterface::_initOLED() {
    u8g2.enableUTF8Print();
    u8g2.clearBuffer();
    _calculateDisplayParams();
    u8g2.sendBuffer();
    _lastActivityTime = millis();
}

void IndicatorInterface::setOledSleepDelay(long sleepDelay) {
    _oledSleepDelay = sleepDelay;
    _wakeOLED();
}

void IndicatorInterface::setOledMode(int lines) {
    if (lines < 1) lines = 1;
    if (lines > 5) lines = 5;
    
    _oledLines = lines;
    _calculateDisplayParams();
    _wakeOLED();
}

void IndicatorInterface::printText(String buffer[], int bufferSize) {
    _textBufferSize = min(bufferSize, 5);
    
    for (int i = 0; i < _textBufferSize; i++) {
        // Only reset scroll offset if the text actually changed
        if (_textBuffer[i] != buffer[i]) {
            _textBuffer[i] = buffer[i];
            _scrollOffset[i] = 0; // Reset only when text changes
        }
    }
    
    // Clear unused lines
    for (int i = _textBufferSize; i < 5; i++) {
        _textBuffer[i] = "";
        _scrollOffset[i] = 0;
    }
    
    _lastActivityTime = millis();
    _wakeOLED();
    _updateOLEDDisplay();
}


void IndicatorInterface::setOLEDblink(int timeOn, int timeOff, bool blinkOn) {
    _oledBlink = blinkOn;
    _blinkTimeOn = timeOn;
    _blinkTimeOff = timeOff;
    _lastBlinkTime = millis();
    _blinkState = true;
    
    if (blinkOn) {
        _wakeOLED();
    }
}

void IndicatorInterface::setOLEDOff() {
    _oledOn = false;
    _oledBlink = false;
    u8g2.setPowerSave(1);
}

void IndicatorInterface::setOLEDOn() {
    _oledOn = true;
    _oledSleeping = false;
    u8g2.setPowerSave(0);
    _updateOLEDDisplay();
    _wakeOLED();
}

void IndicatorInterface::updateOLED() {
    if (!_oledOn) return;
    
    _handleOLEDSleep();
    if (_oledSleeping) return;
    
    // Handle special blinking first - if active, skip other operations
    if (_isBlinkingOK || _isBlinkingCross) {
        _handleSpecialBlink();
        return;  // Don't handle regular blink/scroll when special blinking
    }
    
    _handleOLEDBlink();
    _handleScrolling();
}

void IndicatorInterface::update() {
    updateBlinking();
    updateOLED();
}


// void IndicatorInterface::updateOLED() {
//     if (!_oledOn) return;
    
//     _handleOLEDSleep();
//     if (_oledSleeping) return;
    
//     _handleOLEDBlink();
//     _handleSpecialBlink();  // Add this line
//     _handleScrolling();
// }



void IndicatorInterface::_calculateDisplayParams() {
    int displayHeight = u8g2.getDisplayHeight(); // 64 pixels
    
    // Calculate optimal line height for each mode to use full display height
    switch (_oledLines) {
        case 1:
            // Use largest font and center it
            u8g2.setFont(u8g2_font_10x20_t_cyrillic);
            _lineHeight = displayHeight; // Full height for single line
            _charWidth = 10;
            _maxCharsPerLine = 12;
            break;
            
        case 2:
            // Use medium-large font
            //u8g2.setFont(u8g2_font_9x15_t_cyrillic);
            u8g2.setFont(u8g2_font_10x20_t_cyrillic);
            _lineHeight = displayHeight / 2; // 32px per line
            _charWidth = 9;
            _maxCharsPerLine = 14;
            break;
            
        case 3:
            // Use medium font
            //u8g2.setFont(u8g2_font_7x13_t_cyrillic);
            // u8g2.setFont(u8g2_font_9x15_t_cyrillic);
            u8g2.setFont(u8g2_font_10x20_t_cyrillic);
            _lineHeight = displayHeight / 3; // ~21px per line
            _charWidth = 7;
            _maxCharsPerLine = 18;
            break;
            
        case 4:
            // Use smaller font
            //u8g2.setFont(u8g2_font_5x7_t_cyrillic);
            u8g2.setFont(u8g2_font_9x15_t_cyrillic);
            _lineHeight = displayHeight / 4; // 16px per line
            _charWidth = 5;
            _maxCharsPerLine = 25;
            break;
            
        case 5:
        default:
            // Use smallest font
            u8g2.setFont(u8g2_font_9x15_t_cyrillic);
            // u8g2.setFont(u8g2_font_4x6_t_cyrillic);
            _lineHeight = displayHeight / 5; // ~12px per line
            _charWidth = 4;
            _maxCharsPerLine = 32;
            break;
    }
}


// void IndicatorInterface::_calculateDisplayParams() {
//     // Set font based on number of lines
//     switch (_oledLines) {
//         case 1:
//             u8g2.setFont(u8g2_font_10x20_t_cyrillic);
//             _lineHeight = 24;
//             _charWidth = 10;
//             _maxCharsPerLine = 12;
//             break;
//         case 2:
//             u8g2.setFont(u8g2_font_9x15_t_cyrillic);
//             _lineHeight = 20;
//             _charWidth = 9;
//             _maxCharsPerLine = 14;
//             break;
//         case 3:
//             u8g2.setFont(u8g2_font_7x13_t_cyrillic);
//             _lineHeight = 16;
//             _charWidth = 7;
//             _maxCharsPerLine = 18;
//             break;
//         case 4:
//             u8g2.setFont(u8g2_font_5x7_t_cyrillic);
//             _lineHeight = 12;
//             _charWidth = 6;
//             _maxCharsPerLine = 21;
//             break;
//         case 5:
//         default:
//             u8g2.setFont(u8g2_font_4x6_t_cyrillic);
//             _lineHeight = 10;
//             _charWidth = 5;
//             _maxCharsPerLine = 25;
//             break;
//     }
// }

void IndicatorInterface::_updateOLEDDisplay() {
    if (!_oledOn || _oledSleeping) return;
    
    u8g2.clearBuffer();
    _calculateDisplayParams();
    
    // Set font position to top for consistent positioning
    u8g2.setFontPosTop();
    
    int displayHeight = u8g2.getDisplayHeight(); // 64 pixels
    
    for (int i = 0; i < _oledLines && i < _textBufferSize; i++) {
        int yPos;
        
        if (_oledLines == 1) {
            // Center single line vertically
            int fontHeight = u8g2.getFontAscent() - u8g2.getFontDescent();
            yPos = (displayHeight - fontHeight) / 2;
        } else {
            // Distribute lines evenly across display height
            yPos = (i * displayHeight) / _oledLines;
        }
        
        _drawTextLine(i, yPos);
    }
    
    u8g2.sendBuffer();
}


void IndicatorInterface::_drawTextLine(int lineIndex, int yPos) {
    if (lineIndex >= _textBufferSize) return;
    
    String text = _textBuffer[lineIndex];
    int textLength = text.length();
    
    if (textLength <= _maxCharsPerLine) {
        // Short text - display normally
        u8g2.drawStr(0, yPos, text.c_str());
    } else {
        // Long text - apply scrolling
        int offset = _scrollOffset[lineIndex];
        String displayText;
        
        if (offset < 0) {
            // Smooth entry from left with spaces
            int spaceCount = -offset;
            displayText = String(' ', spaceCount) + text;
            displayText = displayText.substring(0, _maxCharsPerLine);
        } else if (offset <= textLength - _maxCharsPerLine) {
            // Normal scrolling within text
            displayText = text.substring(offset, offset + _maxCharsPerLine);
        } else {
            // Smooth exit with trailing spaces
            int spaceCount = offset - (textLength - _maxCharsPerLine);
            displayText = text.substring(textLength - _maxCharsPerLine);
            displayText += String(' ', min(spaceCount, _maxCharsPerLine));
            displayText = displayText.substring(0, _maxCharsPerLine);
        }
        
        u8g2.drawStr(0, yPos, displayText.c_str());
    }
}





void IndicatorInterface::_handleOLEDSleep() {
    if (_oledSleepDelay < 0) return;  // Never sleep
    
    if (!_oledSleeping && (millis() - _lastActivityTime) > _oledSleepDelay) {
        _oledSleeping = true;
        u8g2.setPowerSave(1);
    }
}

void IndicatorInterface::_handleOLEDBlink() {
    if (!_oledBlink || _oledSleeping) return;
    
    unsigned long currentTime = millis();
    unsigned long elapsed = currentTime - _lastBlinkTime;
    
    if (_blinkState && elapsed > _blinkTimeOn) {
        // Turn off
        u8g2.setPowerSave(1);
        _blinkState = false;
        _lastBlinkTime = currentTime;
    } else if (!_blinkState && elapsed > _blinkTimeOff) {
        // Turn on
        u8g2.setPowerSave(0);
        _updateOLEDDisplay();
        _blinkState = true;
        _lastBlinkTime = currentTime;
    }
}

void IndicatorInterface::_handleScrolling() {
    if (millis() - _lastScrollTime < _scrollDelay) return;
    
    bool needsUpdate = false;
    
    for (int i = 0; i < _textBufferSize; i++) {
        int textLength = _textBuffer[i].length();
        
        if (textLength > _maxCharsPerLine) {
            _scrollOffset[i]++;
            
            // Add pause at the end before wrapping - this prevents immediate reset
            int maxScroll = textLength - _maxCharsPerLine + 5; // +5 for pause at end
            
            if (_scrollOffset[i] > maxScroll) {
                _scrollOffset[i] = 0; // Start from negative for smooth entry
            }
            needsUpdate = true;
        } else {
            // Only reset offset for short lines
            _scrollOffset[i] = 0;
        }
    }
    
    if (needsUpdate) {
        _lastScrollTime = millis();
        _updateOLEDDisplay();
    }
}



void IndicatorInterface::_wakeOLED() {
    if (_oledOn) {
        _lastActivityTime = millis();
        _oledSleeping = false;
        u8g2.setPowerSave(0);
    }
}

// Modify existing handleInterrupt() method to wake OLED:
void IndicatorInterface::handleInterrupt() {
    if (_interruptFlag) {
        _interruptFlag = false;
        _updateState();
        _wakeOLED();  // Wake OLED on any interrupt
    }
}

// Add this method to IndicatorInterface.cpp
// void IndicatorInterface::_fixSH1106Offset() {
//     // Set column start address to 2 for SH1106
//     u8g2.sendF("ca", 0x10 | 0, 0x10 | 2);  // Set lower and higher column start address
// }

void IndicatorInterface::pushLine(String newLine) {
    // Shift all lines down
    for (int i = 4; i > 0; i--) {
        _textBuffer[i] = _textBuffer[i-1];
    }
    
    // Add new line at the top
    _textBuffer[0] = newLine;
    
    // Ensure we have the right number of lines
    if (_textBufferSize < _oledLines) {
        _textBufferSize++;
    } else {
        _textBufferSize = _oledLines;
    }
    
    // Reset scroll offsets
    for (int i = 0; i < 5; i++) {
        _scrollOffset[i] = 0;
    }
    
    _updateOLEDDisplay();
    _wakeOLED();
}

void IndicatorInterface::displayOK() {
    // Remove this line: stopBlinking(); // Stop any current blinking
    
    u8g2.clearBuffer();
    
    // Use the largest available font for OK
    u8g2.setFont(u8g2_font_logisoso42_tf);
    u8g2.setFontPosCenter();
    
    // Calculate center position
    int displayWidth = u8g2.getDisplayWidth();
    int displayHeight = u8g2.getDisplayHeight();
    
    String okText = "OK";
    int textWidth = u8g2.getUTF8Width(okText.c_str());
    
    int x = (displayWidth - textWidth) / 2;
    int y = displayHeight / 2;
    
    // Draw OK in center
    u8g2.drawUTF8(x, y + 5, okText.c_str());
    
    // Add a border around OK
    u8g2.drawFrame(x - 5, y - u8g2.getFontAscent() / 2 - 5, 
                   textWidth + 10, u8g2.getFontAscent() + u8g2.getFontDescent() + 20);
    
    u8g2.sendBuffer();
    _wakeOLED();
}

void IndicatorInterface::displayCross() {
    u8g2.clearBuffer();
    
    int displayWidth = u8g2.getDisplayWidth();
    int displayHeight = u8g2.getDisplayHeight();
    
    // Calculate center and radius for circle
    int centerX = displayWidth / 2;
    int centerY = displayHeight / 2;
    int radius = min(displayWidth, displayHeight) / 2 - 4;
    
    // Draw thicker circle by drawing multiple concentric circles
    for (int r = radius; r > radius - 3; r--) {
        u8g2.drawCircle(centerX, centerY, r);
    }
    
    // Cross parameters - made smaller
    int crossSize = (radius * 5) / 10;  // Reduced from 70% to 50% of radius
    int thickness = 4;  // Cross arm thickness
    int halfThickness = thickness / 2;
    
    // Draw main diagonal (top-left to bottom-right)
    for (int i = -crossSize; i <= crossSize; i++) {
        int x1 = centerX + i - halfThickness;
        int y1 = centerY + i - halfThickness;
        
        // Draw small filled rectangles along the diagonal
        u8g2.drawBox(x1, y1, thickness, thickness);
    }
    
    // Draw anti-diagonal (top-right to bottom-left)
    for (int i = -crossSize; i <= crossSize; i++) {
        int x1 = centerX + i - halfThickness;
        int y1 = centerY - i - halfThickness;
        
        // Draw small filled rectangles along the anti-diagonal
        u8g2.drawBox(x1, y1, thickness, thickness);
    }
    
    u8g2.sendBuffer();
    _wakeOLED();
}

// void IndicatorInterface::displayCross() {
//     // Remove this line: stopBlinking(); // Stop any current blinking
    
//     u8g2.clearBuffer();
    
//     int displayWidth = u8g2.getDisplayWidth();
//     int displayHeight = u8g2.getDisplayHeight();
    
//     // Calculate center and radius for circle
//     int centerX = displayWidth / 2;
//     int centerY = displayHeight / 2;
//     int radius = min(displayWidth, displayHeight) / 2 - 4;
    
//     // Draw circle
//     u8g2.drawCircle(centerX, centerY, radius);
    
//     // Draw cross inside circle
//     int crossSize = radius - 8;
    
//     // Draw X (cross) - make it thicker
//     for (int offset = -1; offset <= 1; offset++) {
//         u8g2.drawLine(centerX - crossSize + offset, centerY - crossSize, 
//                       centerX + crossSize + offset, centerY + crossSize);
//         u8g2.drawLine(centerX + crossSize + offset, centerY - crossSize, 
//                       centerX - crossSize + offset, centerY + crossSize);
//         u8g2.drawLine(centerX - crossSize, centerY - crossSize + offset, 
//                       centerX + crossSize, centerY + crossSize + offset);
//         u8g2.drawLine(centerX + crossSize, centerY - crossSize + offset, 
//                       centerX - crossSize, centerY + crossSize + offset);
//     }
    
//     u8g2.sendBuffer();
//     _wakeOLED();
// }


void IndicatorInterface::blinkOK(int blinkDelay) {
    // Stop any regular OLED blinking first
    _oledBlink = false;
    
    _saveCurrentText();
    _isBlinkingOK = true;
    _isBlinkingCross = false;
    _blinkDelayTime = blinkDelay;
    _lastBlinkToggle = millis();
    _blinkShowSpecial = true;
    
    displayOK();  // Start with OK showing
}

void IndicatorInterface::blinkCross(int blinkDelay) {
    // Stop any regular OLED blinking first
    _oledBlink = false;
    
    _saveCurrentText();
    _isBlinkingOK = false;
    _isBlinkingCross = true;
    _blinkDelayTime = blinkDelay;
    _lastBlinkToggle = millis();
    _blinkShowSpecial = true;
    
    displayCross();  // Start with cross showing
}


void IndicatorInterface::stopBlinking() {
    _isBlinkingOK = false;
    _isBlinkingCross = false;
    _restoreCurrentText();
}

void IndicatorInterface::_saveCurrentText() {
    // Save current text buffer
    for (int i = 0; i < 5; i++) {
        _savedTextBuffer[i] = _textBuffer[i];
    }
    _savedTextBufferSize = _textBufferSize;
    _savedOledLines = _oledLines;
}

void IndicatorInterface::_restoreCurrentText() {
    // Restore saved text buffer
    for (int i = 0; i < 5; i++) {
        _textBuffer[i] = _savedTextBuffer[i];
    }
    _textBufferSize = _savedTextBufferSize;
    _oledLines = _savedOledLines;
    
    _updateOLEDDisplay();
}

void IndicatorInterface::_handleSpecialBlink() {
    if (!_isBlinkingOK && !_isBlinkingCross) return;
    
    unsigned long currentTime = millis();
    if (currentTime - _lastBlinkToggle >= _blinkDelayTime) {
        _blinkShowSpecial = !_blinkShowSpecial;
        _lastBlinkToggle = currentTime;
        
        if (_blinkShowSpecial) {
            // Show OK or Cross
            if (_isBlinkingOK) {
                displayOK();
            } else if (_isBlinkingCross) {
                displayCross();
            }
        } else {
            // Show original text
            _restoreCurrentText();
        }
    }
}



void IndicatorInterface::startBlinking(const std::string& portName, unsigned long onTime, unsigned long offTime) {
    LoggerManager::info("INDICATION", 
        String(portName.c_str()) + " start blinking");
    // Check if port is already blinking
    for (auto& blinkPort : _blinkingPorts) {
        if (blinkPort.portName == portName) {
            // Update existing blinking parameters
            blinkPort.onTime = onTime;
            blinkPort.offTime = offTime;
            blinkPort.isActive = true;
            return;
        }
    }
    
    // Add new blinking port
    BlinkingPort newBlink;
    newBlink.portName = portName;
    newBlink.onTime = onTime;
    newBlink.offTime = offTime;
    newBlink.lastToggleTime = millis();
    newBlink.currentState = true;  // Start with ON
    newBlink.isActive = true;
    
    _blinkingPorts.push_back(newBlink);
    
    // Set initial state to ON
    writePort(portName, true);
}

void IndicatorInterface::stopBlinking(const std::string& portName) {
    LoggerManager::info("INDICATION", 
        String(portName.c_str()) + " stop blinking");
    for (auto it = _blinkingPorts.begin(); it != _blinkingPorts.end(); ++it) {
        if (it->portName == portName) {
            it->isActive = false;
            // Turn off the port when stopping blink
            writePort(portName, false);
            _blinkingPorts.erase(it);
            return;
        }
    }
}

void IndicatorInterface::updateBlinking() {
    unsigned long currentTime = millis();
    
    for (auto& blinkPort : _blinkingPorts) {
        if (!blinkPort.isActive) continue;
        
        unsigned long elapsed = currentTime - blinkPort.lastToggleTime;
        unsigned long targetTime = blinkPort.currentState ? blinkPort.onTime : blinkPort.offTime;
        
        if (elapsed >= targetTime) {
            // Toggle state
            blinkPort.currentState = !blinkPort.currentState;
            blinkPort.lastToggleTime = currentTime;
            
            // Update hardware
            writePort(blinkPort.portName, blinkPort.currentState);
        }
    }
}

bool IndicatorInterface::isBlinking(const std::string& portName) {
    for (const auto& blinkPort : _blinkingPorts) {
        if (blinkPort.portName == portName && blinkPort.isActive) {
            return true;
        }
    }
    return false;
}

-------- [ Separator ] ------

File Name: src/LoggerManager.cpp
Size: 63.11 KB
Code:
#include "LoggerManager.h"
#include "TemperatureController.h"  // Full include in .cpp file
#include "MeasurementPoint.h"       // Add this include


LoggerManager* LoggerManager::_instance = nullptr;

LoggerManager::LoggerManager(TemperatureController& controller, TimeManager& timeManager, fs::FS& filesystem)
    : _controller(&controller), _timeManager(&timeManager), _fs(&filesystem),
      _logFrequency(60000), _lastLogTime(0), _headerWritten(false),
      _enabled(true), _logDirectory(""), _dailyFiles(true), _lastError(""),
      _lastGeneratedHeader(""), _headerChanged(false), _fileSequenceNumber(0),
      _eventLoggingEnabled(true), _eventLogDirectory(""), _currentEventLogFile(""), _lastEventLogDate(""),
      _alarmStateLoggingEnabled(true), _alarmStateLogDirectory(""), _currentAlarmStateLogFile(""), _lastAlarmStateLogDate("") {
        _instance = this;
}


LoggerManager::~LoggerManager() {
    closeCurrentFile();
}

bool LoggerManager::begin() {
    if (!_enabled) return false;
    if(_enabled) {
    if (!_ensureDirectoryExists()) {
        _lastError = "Failed to create log directory";
        return false;
    }
    
    // Recover from existing files after reboot
    if (!_recoverFromExistingFiles()) {
        Serial.println("Warning: Could not recover from existing files, starting fresh");
        // Initialize fresh
        _fileSequenceNumber = 0;
        _headerWritten = false;
    }
    
    // Generate current header for comparison
    _lastGeneratedHeader = _generateCSVHeader();
    
    // Generate log file name with recovered sequence number
    _currentLogFile = _generateLogFileNameWithSequence();
    _lastLogDate = _getCurrentDateString();
   
    // Initialize alarm state logging
    if (_alarmStateLoggingEnabled) {
        _lastAlarmStateLogDate = _getCurrentDateString();
        _currentAlarmStateLogFile = _generateAlarmStateLogFileName();
        
        if (!_ensureAlarmStateLogExists()) {
            Serial.println("Warning: Could not initialize alarm state log file");
        } else {
            Serial.printf("Alarm state logging initialized. Log file: %s\n", _currentAlarmStateLogFile.c_str());
            logInfo("SYSTEM", "LoggerManager alarm state logging initialized successfully");
        }
    }
    
    Serial.printf("LoggerManager initialized. Log file: %s\n", _currentLogFile.c_str());
    Serial.printf("File sequence number: %d\n", _fileSequenceNumber);
    Serial.printf("Log frequency: %lu ms\n", _logFrequency);
    } else {
        Serial.println("No SD card");
        _enabled = false;
        return false;
    }
    
    return true;
}

bool LoggerManager::init() {
    //if (!_enabled) return false;
    if(_enabled) {

    if (!_ensureDirectoryExists()) {
        _lastError = "Failed to create log directory";
        return false;
    }
    
    // Initialize event logging
    if (_eventLoggingEnabled) {
        _lastEventLogDate = _getCurrentDateString();
        _currentEventLogFile = _generateEventLogFileName();
        
        if (!_ensureEventLogExists()) {
            Serial.println("Warning: Could not initialize event log file");
        } else {
            Serial.printf("Event logging initialized. Event log file: %s\n", _currentEventLogFile.c_str());
            
            // Log system startup event
            logInfo("SYSTEM", "LoggerManager event logging initialized successfully");
        }
    }
    
    Serial.printf("LoggerManager event logging initialized. Log file: %s\n", _currentLogFile.c_str());
    } else {
        Serial.println("No SD card");
        _enabled = false;
        return false;
        

    }
    
    return true;
}



void LoggerManager::setLogFrequency(unsigned long frequencyMs) {
    if (frequencyMs < 1000) frequencyMs = 1000; // Minimum 1 second
    _logFrequency = frequencyMs;
    Serial.printf("Log frequency set to %lu ms\n", _logFrequency);
}

unsigned long LoggerManager::getLogFrequency() const {
    return _logFrequency;
}

void LoggerManager::setEnabled(bool enabled) {
    _enabled = enabled;
    Serial.printf("Logging %s\n", enabled ? "enabled" : "disabled");
}

bool LoggerManager::isEnabled() const {
    return _enabled;
}

void LoggerManager::setDailyFiles(bool enabled) {
    _dailyFiles = enabled;
}

bool LoggerManager::isDailyFiles() const {
    return _dailyFiles;
}

void LoggerManager::setLogDirectory(const String& directory) {
    _logDirectory = directory;
    if (!_logDirectory.startsWith("/")) {
        _logDirectory = "/" + _logDirectory;
    }
}

String LoggerManager::getLogDirectory() {
    return _instance->_logDirectory;
}

void LoggerManager::update() {
    if (!_enabled) return;
    
    unsigned long currentTime = millis();
    
    // Check if it's time to log temperature data
    if (currentTime - _lastLogTime >= _logFrequency) {
        // Check if we need new daily files
        if (_dailyFiles) {
            String currentDate = _getCurrentDateString();
            if (currentDate != _lastLogDate) {
                // New day - recover from existing files for new date
                _recoverFromExistingFiles();
                _lastLogDate = currentDate;
                
                // Also update event log file for new day
                if (_eventLoggingEnabled && currentDate != _lastEventLogDate) {
                    _lastEventLogDate = currentDate;
                    _currentEventLogFile = _generateEventLogFileName();
                    logInfo("SYSTEM", "New day - event log file created: " + _currentEventLogFile);
                }
            }
        }
        
        // Check if header has changed (point names changed)
        if (_hasHeaderChanged()) {
            Serial.println("Header changed - creating new log file");
            _incrementSequenceNumber();
            createNewLogFile();
            
            // Log the configuration change event
            if (_eventLoggingEnabled) {
                logWarning("CONFIG", "Measurement point configuration changed - new data log file created");
            }
        }
        
        logDataNow();
    }
}




bool LoggerManager::logDataNow() {
    if (!_enabled) return false;
    
    // Write header if this is a new file
    if (!_headerWritten) {
        if (!_writeHeader()) {
            return false;
        }
        _headerWritten = true;
    }
    
    // Write data row
    if (!_writeDataRow()) {
        return false;
    }
    
    _lastLogTime = millis();
    return true;
}




String LoggerManager::getCurrentLogFile() const {
    return _currentLogFile;
}

bool LoggerManager::closeCurrentFile() {
    // SD library automatically handles file closing
    return true;
}

unsigned long LoggerManager::getLastLogTime() const {
    return _lastLogTime;
}

String LoggerManager::getLastError() const {
    return _lastError;
}

// Private methods implementation

String LoggerManager::_generateLogFileName() {
    String dateStr = _getCurrentDateString();
    return _generateLogFileNameWithSequence();
}

String LoggerManager::_generateLogFileNameWithSequence() {
    
    String dateStr = _getCurrentDateString();
    String filename;
    
    // Always ensure we have a valid path starting with /
    if (_logDirectory.isEmpty()) {
        filename = "/temp_log_" + dateStr + "_" + String(_fileSequenceNumber) + ".csv";
    } else {
        // Ensure _logDirectory starts with /
        String dir = _logDirectory;
        if (!dir.startsWith("/")) {
            dir = "/" + dir;
        }
        filename = dir + "/temp_log_" + dateStr + "_" + String(_fileSequenceNumber) + ".csv";
    }
    
    return filename;
}



String LoggerManager::_generateCSVHeader() {
    String header = "Date,Time";
    
    // Add all 60 measurement points (0-59)
    for (int i = 0; i < 60; i++) {
        MeasurementPoint* point = _controller->getMeasurementPoint(i);
        if (point) {
            String pointName = point->getName();
            if (pointName.isEmpty()) {
                pointName = "Point_" + String(i);
            }
            header += "," + String(i) + "." + _escapeCSVField(pointName);
        } else {
            header += "," + String(i) + ".Point_" + String(i);
        }
    }
    
    header += "\n";
    return header;
}

bool LoggerManager::_writeHeader() {
    if (!_enabled) return false;
    File file = _fs->open(_currentLogFile.c_str(), FILE_WRITE);
    if (!file) {
        _lastError = "Failed to open log file for header writing: " + _currentLogFile;
        return false;
    }
    
    String header = _generateCSVHeader();
    size_t written = file.print(header);
    file.close();
    
    if (written != header.length()) {
        _lastError = "Failed to write complete header";
        return false;
    }
    
    Serial.printf("Header written to %s\n", _currentLogFile.c_str());
    return true;
}

bool LoggerManager::_writeDataRow() {
    if (!_enabled) return false;
    File file = _fs->open(_currentLogFile.c_str(), FILE_APPEND);
    if (!file) {
        _lastError = "Failed to open log file for data writing: " + _currentLogFile;
        return false;
    }
    
    // Build data row
    String dataRow = _getCurrentDateString() + "," + _getCurrentTimeString();
    
    // Add temperature data for all 60 points
    for (int i = 0; i < 60; i++) {
        MeasurementPoint* point = _controller->getMeasurementPoint(i);
        if (point && point->getBoundSensor()) {
            // Point has a bound sensor, log actual temperature
            dataRow += "," + String(point->getCurrentTemp());
        } else {
            // No bound sensor, log empty value
            dataRow += ",";
        }
    }
    
    dataRow += "\n";
    
    size_t written = file.print(dataRow);
    file.close();
    
    if (written != dataRow.length()) {
        _lastError = "Failed to write complete data row";
        return false;
    }
    
    return true;
}

String LoggerManager::_escapeCSVField(const String& field) {
    if (field.indexOf(',') >= 0 || field.indexOf('"') >= 0 || field.indexOf('\n') >= 0) {
        String escaped = "\"";
        for (int i = 0; i < field.length(); i++) {
            if (field.charAt(i) == '"') {
                escaped += "\"\"";
            } else {
                escaped += field.charAt(i);
            }
        }
        escaped += "\"";
        return escaped;
    }
    return field;
}

bool LoggerManager::_ensureDirectoryExists() {
    if (!_enabled) return false;
    // For SD card, always use root directory
    if (_logDirectory.isEmpty() || _logDirectory == "/") {
        return true; // Root directory always exists
    }
    
    // Try to check if custom directory exists, but don't fail if it doesn't
    File dir = _fs->open(_logDirectory.c_str());
    if (!dir) {
        Serial.printf("Directory %s does not exist, using root directory\n", _logDirectory.c_str());
        _logDirectory = ""; // Fall back to root
        return true;
    }
    
    if (!dir.isDirectory()) {
        dir.close();
        Serial.printf("Path %s exists but is not a directory, using root\n", _logDirectory.c_str());
        _logDirectory = ""; // Fall back to root
        return true;
    }
    
    dir.close();
    return true;
}

String LoggerManager::_getCurrentDateString() {
    if (_timeManager && _timeManager->isTimeSet()) {
        return _timeManager->getDateString(); // Assuming this method exists
    } else {
        // Fallback to millis-based date
        unsigned long days = millis() / (24UL * 60UL * 60UL * 1000UL);
        return "Day_" + String(days);
    }
}

String LoggerManager::_getCurrentTimeString() {
    if (_timeManager && _timeManager->isTimeSet()) {
        return _timeManager->getTimeString(); // Assuming this method exists
    } else {
        // Fallback to millis-based time
        unsigned long totalSeconds = (millis() / 1000) % (24 * 60 * 60);
        int hours = totalSeconds / 3600;
        int minutes = (totalSeconds % 3600) / 60;
        int seconds = totalSeconds % 60;
        
        char timeStr[9];
        sprintf(timeStr, "%02d:%02d:%02d", hours, minutes, seconds);
        return String(timeStr);
    }
}



bool LoggerManager::deleteLogFile(const String& filename) {
    if (!_enabled) return false;
    String fullPath = _logDirectory + "/" + filename;
    return _fs->remove(fullPath.c_str());
}

size_t LoggerManager::getLogFileSize() const {
    if (!_enabled) return -1;
    File file = _fs->open(_currentLogFile.c_str(), FILE_READ);
    if (!file) return 0;
    
    size_t size = file.size();
    file.close();
    return size;
}


bool LoggerManager::_hasHeaderChanged() {
    String currentHeader = _generateCSVHeader();
    
    // If this is the first time, store the header
    if (_lastGeneratedHeader.isEmpty()) {
        _lastGeneratedHeader = currentHeader;
        return false;
    }
    
    // Compare with last generated header
    if (currentHeader != _lastGeneratedHeader) {
        Serial.println("Header change detected:");
        Serial.println("Old header: " + _lastGeneratedHeader);
        Serial.println("New header: " + currentHeader);
        
        _lastGeneratedHeader = currentHeader;
        return true;
    }
    
    return false;
}

void LoggerManager::_incrementSequenceNumber() {
    _fileSequenceNumber++;
    Serial.printf("File sequence number incremented to: %d\n", _fileSequenceNumber);
}





void LoggerManager::forceNewFile() {
    if (!_enabled) return;
    _incrementSequenceNumber();
    createNewLogFile();
    Serial.println("Manually forced new log file creation");
}

int LoggerManager::getCurrentSequenceNumber() const {
    return _fileSequenceNumber;
}

void LoggerManager::resetSequenceNumber() {
    _fileSequenceNumber = 0;
    Serial.println("File sequence number reset to 0");
}

bool LoggerManager::_recoverFromExistingFiles() {
    if (!_enabled) return false;
    String currentDate = _getCurrentDateString();
    
    // Find all files for today
    std::vector<String> todaysFiles = _getFilesForDate(currentDate);
    
    if (todaysFiles.empty()) {
        // No files for today, start fresh
        _fileSequenceNumber = 0;
        _headerWritten = false;
        Serial.printf("No existing files for date %s, starting with sequence 0\n", currentDate.c_str());
        return true;
    }
    
    // Find the highest sequence number for today
    int highestSequence = _findHighestSequenceForDate(currentDate);
    
    // Find the latest file (highest sequence number)
    String latestFile = _findLatestFileForDate(currentDate);
    
    if (latestFile.isEmpty()) {
        // Couldn't find latest file, start fresh
        _fileSequenceNumber = 0;
        _headerWritten = false;
        Serial.println("Could not determine latest file, starting fresh");
        return false;
    }
    
    // Read header from latest file
    String existingHeader = _readHeaderFromFile(latestFile);
    String currentHeader = _generateCSVHeader();
    
    if (existingHeader.isEmpty()) {
        // Could not read header, assume file is incomplete
        _fileSequenceNumber = highestSequence;
        _headerWritten = false;
        Serial.printf("Could not read header from %s, will rewrite\n", latestFile.c_str());
        return true;
    }
    
    // Compare headers
    if (existingHeader == currentHeader) {
        // Headers match, continue with existing file
        _fileSequenceNumber = highestSequence;
        _headerWritten = true;
        _currentLogFile = latestFile;
        Serial.printf("Recovered: Using existing file %s (sequence %d)\n", 
                     latestFile.c_str(), _fileSequenceNumber);
        return true;
    } else {
        // Headers don't match, need new file
        _fileSequenceNumber = highestSequence + 1;
        _headerWritten = false;
        Serial.printf("Header changed, creating new file with sequence %d\n", _fileSequenceNumber);
        Serial.println("Old header: " + existingHeader);
        Serial.println("New header: " + currentHeader);
        return true;
    }
}

std::vector<String> LoggerManager::_getFilesForDate(const String& dateStr) {

    std::vector<String> files;
    
    // Open directory (root if _logDirectory is empty)
    String dirPath = _logDirectory.isEmpty() ? "/" : _logDirectory;
    File dir = _fs->open(dirPath.c_str());
    
    if (!dir || !dir.isDirectory()) {
        Serial.printf("Could not open directory: %s\n", dirPath.c_str());
        return files;
    }
    
    // Pattern to match: temp_log_YYYY-MM-DD_N.csv
    String pattern = "temp_log_" + dateStr + "_";
    
    File file = dir.openNextFile();
    while (file) {
        String filename = String(file.name());
        
        // Check if filename matches our pattern and is a CSV file
        if (filename.startsWith(pattern) && filename.endsWith(".csv")) {
            String fullPath = dirPath;
            if (!fullPath.endsWith("/")) fullPath += "/";
            fullPath += filename;
            files.push_back(fullPath);
        }
        
        file = dir.openNextFile();
    }
    
    dir.close();
    
    Serial.printf("Found %d files for date %s\n", files.size(), dateStr.c_str());
    return files;
}

int LoggerManager::_findHighestSequenceForDate(const String& dateStr) {
    std::vector<String> files = _getFilesForDate(dateStr);
    int highestSequence = -1;
    
    for (const String& filepath : files) {
        int sequence = _extractSequenceNumber(filepath);
        if (sequence > highestSequence) {
            highestSequence = sequence;
        }
    }
    
    return highestSequence >= 0 ? highestSequence : 0;
}

String LoggerManager::_findLatestFileForDate(const String& dateStr) {
    std::vector<String> files = _getFilesForDate(dateStr);
    String latestFile = "";
    int highestSequence = -1;
    
    for (const String& filepath : files) {
        int sequence = _extractSequenceNumber(filepath);
        if (sequence > highestSequence) {
            highestSequence = sequence;
            latestFile = filepath;
        }
    }
    
    return latestFile;
}

int LoggerManager::_extractSequenceNumber(const String& filename) {
    // Extract sequence number from filename like: temp_log_2025-06-15_3.csv
    int lastUnderscore = filename.lastIndexOf('_');
    int dotIndex = filename.lastIndexOf('.');
    
    if (lastUnderscore == -1 || dotIndex == -1 || lastUnderscore >= dotIndex) {
        return -1; // Invalid format
    }
    
    String sequenceStr = filename.substring(lastUnderscore + 1, dotIndex);
    return sequenceStr.toInt();
}

String LoggerManager::_readHeaderFromFile(const String& filename) {

    File file = _fs->open(filename.c_str(), FILE_READ);
    if (!file) {
        Serial.printf("Could not open file for header reading: %s\n", filename.c_str());
        return "";
    }
    
    // Read first line (header)
    String header = "";
    while (file.available()) {
        char c = file.read();
        if (c == '\n') {
            break;
        }
        header += c;
    }
    
    file.close();
    
    // Add newline back for comparison
    if (!header.isEmpty()) {
        header += "\n";
    }
    
    return header;
}


bool LoggerManager::createNewLogFile() {
    if (!_enabled) return false;
    closeCurrentFile();
    
    // Generate new filename with current sequence number
    _currentLogFile = _generateLogFileNameWithSequence();
    _headerWritten = false;
    
    // Update the stored header to current state
    _lastGeneratedHeader = _generateCSVHeader();
    
    Serial.printf("Created new log file: %s (sequence: %d)\n", 
                 _currentLogFile.c_str(), _fileSequenceNumber);
    return true;
}



// Event logging configuration methods
void LoggerManager::setEventLoggingEnabled(bool enabled) {
    _eventLoggingEnabled = enabled;
    Serial.printf("Event logging %s\n", enabled ? "enabled" : "disabled");
}

bool LoggerManager::isEventLoggingEnabled() const {
    return _eventLoggingEnabled;
}

void LoggerManager::setEventLogDirectory(const String& directory) {
    _eventLogDirectory = directory;
    if (!_eventLogDirectory.startsWith("/")) {
        _eventLogDirectory = "/" + _eventLogDirectory;
    }
}

String LoggerManager::getEventLogDirectory() const {
    return _eventLogDirectory;
}

// Main event logging method
bool LoggerManager::logEvent(const String& source, const String& description, const String& priority) {
    if (!_enabled) return false;
    if (!_eventLoggingEnabled) return false;
    
    // Check if we need a new event log file for today
    String currentDate = _getCurrentDateString();
    if (currentDate != _lastEventLogDate) {
        _lastEventLogDate = currentDate;
        _currentEventLogFile = _generateEventLogFileName();
    }
    
    // Ensure event log file exists
    if (!_ensureEventLogExists()) {
        return false;
    }
    
    // Generate timestamp
    String timestamp = _getCurrentDateString() + " " + _getCurrentTimeString();
    
    // Write event row
    return _writeEventRow(timestamp, source, description, priority);
}

// Convenience methods for different priority levels
bool LoggerManager::logInfo(const String& source, const String& description) {
    if (!_enabled) return false;
    return logEvent(source, description, "INFO");
}

bool LoggerManager::logWarning(const String& source, const String& description) {
    if (!_enabled) return false;
    return logEvent(source, description, "WARNING");
}

bool LoggerManager::logError(const String& source, const String& description) {
    if (!_enabled) return false;
    return logEvent(source, description, "ERROR");
}

bool LoggerManager::logCritical(const String& source, const String& description) {
    if (!_enabled) return false;
    return logEvent(source, description, "CRITICAL");
}

// Event log file management
String LoggerManager::getCurrentEventLogFile() const {
    return _currentEventLogFile;
}

std::vector<String> LoggerManager::getEventLogFiles() {

    std::vector<String> files;
    
    String dirPath = _eventLogDirectory.isEmpty() ? "/" : _eventLogDirectory;
    File dir = _fs->open(dirPath.c_str());
    
    if (!dir || !dir.isDirectory()) {
        return files;
    }
    
    File file = dir.openNextFile();
    while (file) {
        String filename = String(file.name());
        if (filename.startsWith("events_") && filename.endsWith(".csv")) {
            String fullPath = dirPath;
            if (!fullPath.endsWith("/")) fullPath += "/";
            fullPath += filename;
            files.push_back(fullPath);
        }
        file = dir.openNextFile();
    }
    
    dir.close();
    return files;
}

bool LoggerManager::deleteEventLogFile(const String& filename) {
    if (!_enabled) return false;
    String fullPath = _eventLogDirectory.isEmpty() ? "/" : _eventLogDirectory;
    if (!fullPath.endsWith("/")) fullPath += "/";
    fullPath += filename;
    return _fs->remove(fullPath.c_str());
}

// Private event logging methods
String LoggerManager::_generateEventLogFileName() {
    String dateStr = _getCurrentDateString();
    String filename;
    
    if (_eventLogDirectory.isEmpty()) {
        filename = "/events_" + dateStr + ".csv";  // Always start with /
    } else {
        String dir = _eventLogDirectory;
        if (!dir.startsWith("/")) {
            dir = "/" + dir;
        }
        filename = dir + "/events_" + dateStr + ".csv";
    }
    
    return filename;
}


bool LoggerManager::_ensureEventLogExists() {
    if (!_enabled) return false;
    // Check if event log file exists
    File file = _fs->open(_currentEventLogFile.c_str(), FILE_READ);
    if (file) {
        file.close();
        return true; // File exists
    }
    
    // File doesn't exist, create it with header
    return _writeEventHeader();
}

bool LoggerManager::_writeEventHeader() {
    if (!_enabled) return false;
    File file = _fs->open(_currentEventLogFile.c_str(), FILE_WRITE);
    if (!file) {
        _lastError = "Failed to open event log file for header writing: " + _currentEventLogFile;
        return false;
    }
    
    String header = "Timestamp,Source,Description,Priority\n";
    size_t written = file.print(header);
    file.close();
    
    if (written != header.length()) {
        _lastError = "Failed to write complete event log header";
        return false;
    }
    
    Serial.printf("Event log header written to %s\n", _currentEventLogFile.c_str());
    return true;
}

bool LoggerManager::_writeEventRow(const String& timestamp, const String& source, 
                                  const String& description, const String& priority) {
    if (!_enabled) return false;
    File file = _fs->open(_currentEventLogFile.c_str(), FILE_APPEND);
    if (!file) {
        _lastError = "Failed to open event log file for writing: " + _currentEventLogFile;
        return false;
    }
    
    // Build event row with proper CSV escaping
    String eventRow = _escapeCSVField(timestamp) + "," + 
                     _escapeCSVField(source) + "," + 
                     _escapeCSVField(description) + "," + 
                     _escapeCSVField(priority) + "\n";
    
    size_t written = file.print(eventRow);
    file.close();
    
    if (written != eventRow.length()) {
        _lastError = "Failed to write complete event log row";
        return false;
    }
    
    // Also print to serial for debugging
    Serial.printf("[%s] %s: %s (%s)\n", timestamp.c_str(), source.c_str(), description.c_str(), priority.c_str());
    
    return true;
}


// Alarm state logging configuration methods
void LoggerManager::setAlarmStateLoggingEnabled(bool enabled) {
    _alarmStateLoggingEnabled = enabled;
    Serial.printf("Alarm state logging %s\n", enabled ? "enabled" : "disabled");
}

bool LoggerManager::isAlarmStateLoggingEnabled() const {
    return _alarmStateLoggingEnabled;
}

void LoggerManager::setAlarmStateLogDirectory(const String& directory) {
    _alarmStateLogDirectory = directory;
    if (!_alarmStateLogDirectory.startsWith("/") && !_alarmStateLogDirectory.isEmpty()) {
        _alarmStateLogDirectory = "/" + _alarmStateLogDirectory;
    }
}

String LoggerManager::getAlarmStateLogDirectory() const {
    return _alarmStateLogDirectory;
}

// Static method for alarm state logging
bool LoggerManager::logAlarmStateChange(int pointNumber, const String& pointName, 
                                       const String& alarmType, const String& alarmPriority,
                                       const String& previousState, const String& newState,
                                       int16_t currentTemp, int16_t threshold) {
    
    return _instance ? _instance->logAlarmState(pointNumber, pointName, alarmType, alarmPriority,
                                               previousState, newState, currentTemp, threshold) : false;
}

// Instance method for alarm state logging
bool LoggerManager::logAlarmState(int pointNumber, const String& pointName, 
                                 const String& alarmType, const String& alarmPriority,
                                 const String& previousState, const String& newState,
                                 int16_t currentTemp, int16_t threshold) {
    if (!_enabled) return false;
    if (!_alarmStateLoggingEnabled) return false;
    
    // Check if we need a new alarm state log file for today
    String currentDate = _getCurrentDateString();
    if (currentDate != _lastAlarmStateLogDate) {
        _lastAlarmStateLogDate = currentDate;
        _currentAlarmStateLogFile = _generateAlarmStateLogFileName();
    }
    
    // Ensure alarm state log file exists
    if (!_ensureAlarmStateLogExists()) {
        return false;
    }
    
    // Generate timestamp
    String timestamp = _getCurrentDateString() + " " + _getCurrentTimeString();
    
    // Write alarm state row
    return _writeAlarmStateRow(timestamp, pointNumber, pointName, alarmType, alarmPriority,
                              previousState, newState, currentTemp, threshold);
}

// Private methods for alarm state logging
String LoggerManager::_generateAlarmStateLogFileName() {

    String dateStr = _getCurrentDateString();
    String filename;
    
    if (_alarmStateLogDirectory.isEmpty()) {
        filename = "/alarm_states_" + dateStr + ".csv";
    } else {
        String dir = _alarmStateLogDirectory;
        if (!dir.startsWith("/")) {
            dir = "/" + dir;
        }
        filename = dir + "/alarm_states_" + dateStr + ".csv";
    }
    
    return filename;
}

bool LoggerManager::_ensureAlarmStateLogExists() {
    if (!_enabled) return false;
    // Check if alarm state log file exists
    File file = _fs->open(_currentAlarmStateLogFile.c_str(), FILE_READ);
    if (file) {
        file.close();
        return true; // File exists
    }
    
    // File doesn't exist, create it with header
    return _writeAlarmStateHeader();
}

bool LoggerManager::_writeAlarmStateHeader() {
    if (!_enabled) return false;
    File file = _fs->open(_currentAlarmStateLogFile.c_str(), FILE_WRITE);
    if (!file) {
        _lastError = "Failed to open alarm state log file for header writing: " + _currentAlarmStateLogFile;
        return false;
    }
    
    String header = "Timestamp,PointNumber,PointName,AlarmType,AlarmPriority,PreviousState,NewState,CurrentTemperature,Threshold\n";
    size_t written = file.print(header);
    file.close();
    
    if (written != header.length()) {
        _lastError = "Failed to write complete alarm state log header";
        return false;
    }
    
    Serial.printf("Alarm state log header written to %s\n", _currentAlarmStateLogFile.c_str());
    return true;
}

bool LoggerManager::_writeAlarmStateRow(const String& timestamp, int pointNumber, const String& pointName,
                                       const String& alarmType, const String& alarmPriority,
                                       const String& previousState, const String& newState,
                                       int16_t currentTemp, int16_t threshold) {
    if (!_enabled) return false;
    File file = _fs->open(_currentAlarmStateLogFile.c_str(), FILE_APPEND);
    if (!file) {
        _lastError = "Failed to open alarm state log file for writing: " + _currentAlarmStateLogFile;
        return false;
    }
    
    // Build alarm state row with proper CSV escaping
    String alarmStateRow = _escapeCSVField(timestamp) + "," + 
                          String(pointNumber) + "," +
                          _escapeCSVField(pointName) + "," + 
                          _escapeCSVField(alarmType) + "," + 
                          _escapeCSVField(alarmPriority) + "," + 
                          _escapeCSVField(previousState) + "," + 
                          _escapeCSVField(newState) + "," + 
                          String(currentTemp) + "," + 
                          String(threshold) + "\n";
    
    size_t written = file.print(alarmStateRow);
    file.close();
    
    if (written != alarmStateRow.length()) {
        _lastError = "Failed to write complete alarm state log row";
        return false;
    }
    
    // Also print to serial for debugging
    Serial.printf("[ALARM_STATE] %s: Point %d (%s) %s %s: %s -> %s (Temp: %d, Threshold: %d)\n", 
                 timestamp.c_str(), pointNumber, pointName.c_str(), alarmType.c_str(), 
                 alarmPriority.c_str(), previousState.c_str(), newState.c_str(), currentTemp, threshold);
    
    return true;
}

// Alarm state log management
String LoggerManager::getCurrentAlarmStateLogFile() const {
    return _currentAlarmStateLogFile;
}

// std::vector<String> LoggerManager::getAlarmStateLogFiles() {

//     std::vector<String> files;
    
//     String dirPath = _instance->_alarmStateLogDirectory.isEmpty() ? "/" : _instance->_alarmStateLogDirectory;
//     File dir = _instance->_fs->open(dirPath.c_str());
    
//     if (!dir || !dir.isDirectory()) {
//         return files;
//     }
    
//     File file = dir.openNextFile();
//     while (file) {
//         String filename = String(file.name());
//         if (filename.startsWith("alarm_states_") && filename.endsWith(".csv")) {
//             String fullPath = dirPath;
//             if (!fullPath.endsWith("/")) fullPath += "/";
//             fullPath += filename;
//             files.push_back(fullPath);
//         }
//         file = dir.openNextFile();
//     }
    
//     dir.close();
//     return files;
// }

bool LoggerManager::deleteAlarmStateLogFile(const String& filename) {
    String fullPath = _alarmStateLogDirectory.isEmpty() ? "/" : _alarmStateLogDirectory;
    if (!fullPath.endsWith("/")) fullPath += "/";
    fullPath += filename;
    return _fs->remove(fullPath.c_str());
}


// Add to LoggerManager.cpp:
bool LoggerManager::_isSDCardAvailable() {
    // Try to open the filesystem
    File testFile = _fs->open("/");
    if (!testFile) {
        return false;
    }
    testFile.close();
    return true;
}


String LoggerManager::getAlarmHistoryJson(const String& startDate, const String& endDate) {
    if (!_instance) {
        return "{\"success\":false,\"error\":\"LoggerManager not initialized\"}";
    }
    
    DynamicJsonDocument doc(16384); // Large document for history
    doc["success"] = true;
    JsonArray historyArray = doc.createNestedArray("history");
    
    // Get all alarm log files in the date range
    std::vector<String> files = _getAlarmLogFilesInRange(startDate, endDate);
    
    if (files.empty()) {
        doc["success"] = false;
        doc["error"] = "No alarm log files found in the specified date range";
        String output;
        serializeJson(doc, output);
        return output;
    }
    
    // Read and parse each file
    // for (const String& filename : files) {
    //     String fullPath = _instance->_alarmStateLogDirectory.isEmpty() ? "/" : _instance->_alarmStateLogDirectory;
    //     if (!fullPath.endsWith("/")) fullPath += "/";
    //     fullPath += filename;
        
    //     File file = _instance->_fs->open(fullPath.c_str(), FILE_READ);
    //     if (!file) {
    //         continue;
    //     }

    for (const String& filename : files) {
        String fullPath = _instance->_alarmStateLogDirectory.isEmpty() ? "/" : _instance->_alarmStateLogDirectory;
        if (!fullPath.endsWith("/")) fullPath += "/";
        fullPath += filename;
        
        Serial.printf("Opening file: %s\n", fullPath.c_str());
        
        File file = _instance->_fs->open(fullPath.c_str(), FILE_READ);
        if (!file) {
            Serial.printf("Failed to open file: %s\n", fullPath.c_str());
            continue;
        }
        
        // Skip header line
        if (file.available()) {
            file.readStringUntil('\n');
        }
        
        // Read data lines
        while (file.available()) {
            String line = file.readStringUntil('\n');
            line.trim();
            if (line.isEmpty()) continue;
            
            DynamicJsonDocument entryDoc(512);
            if (_parseAlarmStateLogEntry(line, entryDoc)) {
                JsonObject entry = historyArray.createNestedObject();
                entry["timestamp"] = entryDoc["timestamp"];
                entry["pointNumber"] = entryDoc["pointNumber"];
                entry["pointName"] = entryDoc["pointName"];
                entry["alarmType"] = entryDoc["alarmType"];
                entry["alarmPriority"] = entryDoc["alarmPriority"];
                entry["previousState"] = entryDoc["previousState"];
                entry["newState"] = entryDoc["newState"];
                entry["currentTemperature"] = entryDoc["currentTemperature"];
                entry["threshold"] = entryDoc["threshold"];
            }
        }
        
        file.close();
    }
    
    doc["totalEntries"] = historyArray.size();
    
    String output;
    serializeJson(doc, output);
    return output;
}

String LoggerManager::getAlarmHistoryCsv(const String& startDate, const String& endDate) {
    if (!_instance) {
        return "";
    }
    
    String csv = "Timestamp,PointNumber,PointName,AlarmType,AlarmPriority,PreviousState,NewState,CurrentTemperature,Threshold\n";
    
    // Get all alarm log files in the date range
    std::vector<String> files = _getAlarmLogFilesInRange(startDate, endDate);
    
    if (files.empty()) {
        return "";
    }
    
    // Read and merge data from all files
    for (const String& filename : files) {
        String fullPath = _instance->_alarmStateLogDirectory.isEmpty() ? "/" : _instance->_alarmStateLogDirectory;
        if (!fullPath.endsWith("/")) fullPath += "/";
        fullPath += filename;
        
        File file = _instance->_fs->open(fullPath.c_str(), FILE_READ);
        if (!file) {
            continue;
        }
        
        // Skip header line
        if (file.available()) {
            file.readStringUntil('\n');
        }
        
        // Copy data lines
        while (file.available()) {
            String line = file.readStringUntil('\n');
            line.trim();
            if (!line.isEmpty()) {
                csv += line + "\n";
            }
        }
        
        file.close();
    }
    
    return csv;
}

std::vector<String> LoggerManager::_getAlarmLogFilesInRange(const String& startDate, const String& endDate) {
    std::vector<String> matchingFiles;
    
    if (!_instance) {
        return matchingFiles;
    }
    
    String dirPath = _instance->_alarmStateLogDirectory.isEmpty() ? "/" : _instance->_alarmStateLogDirectory;
    Serial.printf("Searching for alarm log files in directory: %s\n", dirPath.c_str());
    File dir = _instance->_fs->open(dirPath.c_str());
    
    if (!dir || !dir.isDirectory()) {
        Serial.printf("Could not open directory: %s\n", dirPath.c_str());
        return matchingFiles;
    }
    
    String normalizedStart = _normalizeDate(startDate);
    Serial.printf("Normalized start date: %s\n", normalizedStart.c_str());
    String normalizedEnd = _normalizeDate(endDate);
    Serial.printf("Normalized end date: %s\n", normalizedEnd.c_str());
    
    File file = dir.openNextFile();
    while (file) {
        String filename = String(file.name());
        Serial.printf("Checking file: %s\n", filename.c_str());
        
        // Check if it's an alarm state log file
        if (filename.startsWith("alarm_states_") && filename.endsWith(".csv")) {
            // Extract date from filename (alarm_states_YYYY-MM-DD.csv)
            // The date starts after "alarm_states_" which is 13 characters
            String fileDate = filename.substring(13); // Remove "alarm_states_" prefix
            fileDate = fileDate.substring(0, fileDate.lastIndexOf('.')); // Remove .csv extension
            
            Serial.printf("Extracted file date: %s\n", fileDate.c_str());
            
            // Check if date is within range
            if (fileDate >= normalizedStart && fileDate <= normalizedEnd) {
                Serial.printf("File date %s is within range [%s, %s]\n", fileDate.c_str(), normalizedStart.c_str(), normalizedEnd.c_str());
                matchingFiles.push_back(filename);
            } else {
                Serial.printf("File date %s is outside range [%s, %s]\n", fileDate.c_str(), normalizedStart.c_str(), normalizedEnd.c_str());
            }
        }
        
        file = dir.openNextFile();
    }
    
    dir.close();
    
    Serial.printf("Found %d matching files\n", matchingFiles.size());
    
    // Sort files by date
    std::sort(matchingFiles.begin(), matchingFiles.end());
    
    return matchingFiles;
}
bool LoggerManager::_parseAlarmStateLogEntry(const String& line, DynamicJsonDocument& entry) {
    // This method doesn't need instance access, so it can remain unchanged
    // Parse CSV line: Timestamp,PointNumber,PointName,AlarmType,AlarmPriority,PreviousState,NewState,CurrentTemperature,Threshold
    int fieldIndex = 0;
    int startPos = 0;
    String fields[9];
    bool inQuotes = false;
    
    for (int i = 0; i <= line.length(); i++) {
        char c = (i < line.length()) ? line.charAt(i) : ',';
        
        if (c == '"') {
            inQuotes = !inQuotes;
        } else if (c == ',' && !inQuotes) {
            if (fieldIndex < 9) {
                fields[fieldIndex] = line.substring(startPos, i);
                // Remove quotes if present
                if (fields[fieldIndex].startsWith("\"") && fields[fieldIndex].endsWith("\"")) {
                    fields[fieldIndex] = fields[fieldIndex].substring(1, fields[fieldIndex].length() - 1);
                }
                fields[fieldIndex].trim();
            }
            fieldIndex++;
            startPos = i + 1;
        }
    }
    
    if (fieldIndex < 8) { // We need at least 9 fields (0-8)
        return false;
    }
    
    // Parse fields into JSON
    entry["timestamp"] = fields[0];
    entry["pointNumber"] = fields[1].toInt();
    entry["pointName"] = fields[2];
    entry["alarmType"] = fields[3];
    entry["alarmPriority"] = fields[4];
    entry["previousState"] = fields[5];
    entry["newState"] = fields[6];
    entry["currentTemperature"] = fields[7].toInt();
    entry["threshold"] = fields[8].toInt();
    
    return true;
}

String LoggerManager::_normalizeDate(const String& dateStr) {
    // This method doesn't need instance access, so it can remain unchanged
    // Ensure date is in YYYY-MM-DD format
    String normalized = dateStr;
    normalized.trim();
    
    // If date contains slashes, replace with dashes
    normalized.replace("/", "-");
    
    // Ensure proper formatting with leading zeros
    int firstDash = normalized.indexOf('-');
    int secondDash = normalized.lastIndexOf('-');
    
    if (firstDash > 0 && secondDash > firstDash) {
        String year = normalized.substring(0, firstDash);
        String month = normalized.substring(firstDash + 1, secondDash);
        String day = normalized.substring(secondDash + 1);
        
        // Pad with zeros if needed
        if (month.length() == 1) month = "0" + month;
        if (day.length() == 1) day = "0" + day;
        
        normalized = year + "-" + month + "-" + day;
    }
    
    return normalized;
}

// String LoggerManager::getEventLogsJson(const String& startDate, const String& endDate) {
//     if (!_instance) {
//         return "{\"success\":false,\"error\":\"LoggerManager not initialized\"}";
//     }
    
//     DynamicJsonDocument doc(16384); // Large document for logs
//     doc["success"] = true;
//     JsonArray logsArray = doc.createNestedArray("logs");
    
//     // Get all event log files in the date range
//     std::vector<String> files = _getEventLogFilesInRange(startDate, endDate);
    
//     if (files.empty()) {
//         doc["success"] = false;
//         doc["error"] = "No event log files found in the specified date range";
//         String output;
//         serializeJson(doc, output);
//         return output;
//     }
    
//     // Read and parse each file
//     for (const String& filename : files) {
//         String fullPath = _instance->_eventLogDirectory.isEmpty() ? "/" : _instance->_eventLogDirectory;
//         if (!fullPath.endsWith("/")) fullPath += "/";
//         fullPath += filename;
        
//         Serial.printf("Opening event log file: %s\n", fullPath.c_str());
        
//         File file = _instance->_fs->open(fullPath.c_str(), FILE_READ);
//         if (!file) {
//             Serial.printf("Failed to open event log file: %s\n", fullPath.c_str());
//             continue;
//         }
        
//         // Skip header line
//         if (file.available()) {
//             file.readStringUntil('\n');
//         }
        
//         // Read data lines
//         while (file.available()) {
//             String line = file.readStringUntil('\n');
//             line.trim();
//             if (line.isEmpty()) continue;
            
//             DynamicJsonDocument entryDoc(512);
//             if (_parseEventLogEntry(line, entryDoc)) {
//                 JsonObject entry = logsArray.createNestedObject();
//                 entry["timestamp"] = entryDoc["timestamp"];
//                 entry["source"] = entryDoc["source"];
//                 entry["description"] = entryDoc["description"];
//                 entry["priority"] = entryDoc["priority"];
//             }
//         }
        
//         file.close();
//     }
    
//     doc["totalEntries"] = logsArray.size();
    
//     String output;
//     serializeJson(doc, output);
//     return output;
// }

// String LoggerManager::getEventLogsCsv(const String& startDate, const String& endDate) {
//     if (!_instance) {
//         return "";
//     }
    
//     String csv = "Timestamp,Source,Description,Priority\n";
    
//     // Get all event log files in the date range
//     std::vector<String> files = _getEventLogFilesInRange(startDate, endDate);
    
//     if (files.empty()) {
//         return "";
//     }
    
//     // Read and merge data from all files
//     for (const String& filename : files) {
//         String fullPath = _instance->_eventLogDirectory.isEmpty() ? "/" : _instance->_eventLogDirectory;
//         if (!fullPath.endsWith("/")) fullPath += "/";
//         fullPath += filename;
        
//         File file = _instance->_fs->open(fullPath.c_str(), FILE_READ);
//         if (!file) {
//             continue;
//         }
        
//         // Skip header line
//         if (file.available()) {
//             file.readStringUntil('\n');
//         }
        
//         // Copy data lines
//         while (file.available()) {
//             String line = file.readStringUntil('\n');
//             line.trim();
//             if (!line.isEmpty()) {
//                 csv += line + "\n";
//             }
//         }
        
//         file.close();
//     }
    
//     return csv;
// }

// std::vector<String> LoggerManager::_getEventLogFilesInRange(const String& startDate, const String& endDate) {
//     std::vector<String> matchingFiles;
    
//     if (!_instance) {
//         return matchingFiles;
//     }
    
//     String dirPath = _instance->_eventLogDirectory.isEmpty() ? "/" : _instance->_eventLogDirectory;
//     Serial.printf("Searching for event log files in directory: %s\n", dirPath.c_str());
//     File dir = _instance->_fs->open(dirPath.c_str());
    
//     if (!dir || !dir.isDirectory()) {
//         Serial.printf("Could not open directory: %s\n", dirPath.c_str());
//         return matchingFiles;
//     }
    
//     String normalizedStart = _normalizeDate(startDate);
//     Serial.printf("Normalized start date: %s\n", normalizedStart.c_str());
//     String normalizedEnd = _normalizeDate(endDate);
//     Serial.printf("Normalized end date: %s\n", normalizedEnd.c_str());
    
//     File file = dir.openNextFile();
//     while (file) {
//         String filename = String(file.name());
//         Serial.printf("Checking file: %s\n", filename.c_str());
        
//         // Check if it's an event log file
//         if (filename.startsWith("events_") && filename.endsWith(".csv")) {
//             // Extract date from filename (events_YYYY-MM-DD.csv)
//             String fileDate = filename.substring(7); // Remove "events_" prefix
//             fileDate = fileDate.substring(0, fileDate.lastIndexOf('.')); // Remove .csv extension
            
//             Serial.printf("Extracted file date: %s\n", fileDate.c_str());
            
//             // Check if date is within range
//             if (fileDate >= normalizedStart && fileDate <= normalizedEnd) {
//                 Serial.printf("File date %s is within range [%s, %s]\n", fileDate.c_str(), normalizedStart.c_str(), normalizedEnd.c_str());
//                 matchingFiles.push_back(filename);
//             }
//         }
        
//         file = dir.openNextFile();
//     }
    
//     dir.close();
    
//     Serial.printf("Found %d matching event log files\n", matchingFiles.size());
    
//     // Sort files by date
//     std::sort(matchingFiles.begin(), matchingFiles.end());
    
//     return matchingFiles;
// }

// bool LoggerManager::_parseEventLogEntry(const String& line, DynamicJsonDocument& entry) {
//     // Parse CSV line: Timestamp,Source,Description,Priority
//     int fieldIndex = 0;
//     int startPos = 0;
//     String fields[4];
//     bool inQuotes = false;
    
//     for (int i = 0; i <= line.length(); i++) {
//         char c = (i < line.length()) ? line.charAt(i) : ',';
        
//         if (c == '"') {
//             inQuotes = !inQuotes;
//         } else if (c == ',' && !inQuotes) {
//             if (fieldIndex < 4) {
//                 fields[fieldIndex] = line.substring(startPos, i);
//                 // Remove quotes if present
//                 if (fields[fieldIndex].startsWith("\"") && fields[fieldIndex].endsWith("\"")) {
//                     fields[fieldIndex] = fields[fieldIndex].substring(1, fields[fieldIndex].length() - 1);
//                 }
//                 fields[fieldIndex].trim();
//             }
//             fieldIndex++;
//             startPos = i + 1;
//         }
//     }
    
//     if (fieldIndex < 3) { // We need at least 4 fields (0-3)
//         return false;
//     }
    
//     // Parse fields into JSON
//     entry["timestamp"] = fields[0];
//     entry["source"] = fields[1];
//     entry["description"] = fields[2];
//     entry["priority"] = fields[3];
    
//     return true;
// }


// Add these methods to your LoggerManager.cpp file

// Static method to get event logs as JSON
String LoggerManager::getEventLogsJson(const String& startDate, const String& endDate) {
    if (!_instance) {
        return "{\"success\":false,\"error\":\"LoggerManager not initialized\"}";
    }
    
    DynamicJsonDocument doc(16384); // Large document for logs
    doc["success"] = true;
    JsonArray logsArray = doc.createNestedArray("logs");
    
    // Get all event log files in the date range
    std::vector<String> files = _getEventLogFilesInRange(startDate, endDate);
    
    if (files.empty()) {
        doc["success"] = false;
        doc["error"] = "No event log files found in the specified date range";
        String output;
        serializeJson(doc, output);
        return output;
    }
    
    // Read and parse each file
    for (const String& filename : files) {
        String fullPath = _instance->_eventLogDirectory.isEmpty() ? "/" : _instance->_eventLogDirectory;
        if (!fullPath.endsWith("/")) fullPath += "/";
        fullPath += filename;
        
        Serial.printf("Opening event log file: %s\n", fullPath.c_str());
        
        File file = _instance->_fs->open(fullPath.c_str(), FILE_READ);
        if (!file) {
            Serial.printf("Failed to open event log file: %s\n", fullPath.c_str());
            continue;
        }
        
        // Skip header line
        if (file.available()) {
            file.readStringUntil('\n');
        }
        
        // Read data lines
        while (file.available()) {
            String line = file.readStringUntil('\n');
            line.trim();
            if (line.isEmpty()) continue;
            
            DynamicJsonDocument entryDoc(512);
            if (_parseEventLogEntry(line, entryDoc)) {
                JsonObject entry = logsArray.createNestedObject();
                entry["timestamp"] = entryDoc["timestamp"];
                entry["source"] = entryDoc["source"];
                entry["description"] = entryDoc["description"];
                entry["priority"] = entryDoc["priority"];
            }
        }
        
        file.close();
    }
    
    doc["totalEntries"] = logsArray.size();
    
    String output;
    serializeJson(doc, output);
    return output;
}

// Static method to get event logs as CSV
String LoggerManager::getEventLogsCsv(const String& startDate, const String& endDate) {
    if (!_instance) {
        return "";
    }
    
    String csv = "Timestamp,Source,Description,Priority\n";
    
    // Get all event log files in the date range
    std::vector<String> files = _getEventLogFilesInRange(startDate, endDate);
    
    if (files.empty()) {
        return "";
    }
    
    // Read and merge data from all files
    for (const String& filename : files) {
        String fullPath = _instance->_eventLogDirectory.isEmpty() ? "/" : _instance->_eventLogDirectory;
        if (!fullPath.endsWith("/")) fullPath += "/";
        fullPath += filename;
        
        File file = _instance->_fs->open(fullPath.c_str(), FILE_READ);
        if (!file) {
            continue;
        }
        
        // Skip header line
        if (file.available()) {
            file.readStringUntil('\n');
        }
        
        // Copy data lines
        while (file.available()) {
            String line = file.readStringUntil('\n');
            line.trim();
            if (!line.isEmpty()) {
                csv += line + "\n";
            }
        }
        
        file.close();
    }
    
    return csv;
}

// Static method to get event log files in range
std::vector<String> LoggerManager::_getEventLogFilesInRange(const String& startDate, const String& endDate) {
    std::vector<String> matchingFiles;
    
    if (!_instance) {
        return matchingFiles;
    }
    
    String dirPath = _instance->_eventLogDirectory.isEmpty() ? "/" : _instance->_eventLogDirectory;
    Serial.printf("Searching for event log files in directory: %s\n", dirPath.c_str());
    File dir = _instance->_fs->open(dirPath.c_str());
    
    if (!dir || !dir.isDirectory()) {
        Serial.printf("Could not open directory: %s\n", dirPath.c_str());
        return matchingFiles;
    }
    
    String normalizedStart = _normalizeDate(startDate);
    Serial.printf("Normalized start date: %s\n", normalizedStart.c_str());
    String normalizedEnd = _normalizeDate(endDate);
    Serial.printf("Normalized end date: %s\n", normalizedEnd.c_str());
    
    File file = dir.openNextFile();
    while (file) {
        String filename = String(file.name());
        Serial.printf("Checking file: %s\n", filename.c_str());
        
        // Check if it's an event log file
        if (filename.startsWith("events_") && filename.endsWith(".csv")) {
            // Extract date from filename (events_YYYY-MM-DD.csv)
            String fileDate = filename.substring(7); // Remove "events_" prefix
            fileDate = fileDate.substring(0, fileDate.lastIndexOf('.')); // Remove .csv extension
            
            Serial.printf("Extracted file date: %s\n", fileDate.c_str());
            
            // Check if date is within range
            if (fileDate >= normalizedStart && fileDate <= normalizedEnd) {
                Serial.printf("File date %s is within range [%s, %s]\n", fileDate.c_str(), normalizedStart.c_str(), normalizedEnd.c_str());
                matchingFiles.push_back(filename);
            }
        }
        
        file = dir.openNextFile();
    }
    
    dir.close();
    
    Serial.printf("Found %d matching event log files\n", matchingFiles.size());
    
    // Sort files by date
    std::sort(matchingFiles.begin(), matchingFiles.end());
    
    return matchingFiles;
}

// Static method to parse event log entry
bool LoggerManager::_parseEventLogEntry(const String& line, DynamicJsonDocument& entry) {
    // Parse CSV line: Timestamp,Source,Description,Priority
    int fieldIndex = 0;
    int startPos = 0;
    String fields[4];
    bool inQuotes = false;
    
    for (int i = 0; i <= line.length(); i++) {
        char c = (i < line.length()) ? line.charAt(i) : ',';
        
        if (c == '"') {
            inQuotes = !inQuotes;
        } else if (c == ',' && !inQuotes) {
            if (fieldIndex < 4) {
                fields[fieldIndex] = line.substring(startPos, i);
                // Remove quotes if present
                if (fields[fieldIndex].startsWith("\"") && fields[fieldIndex].endsWith("\"")) {
                    fields[fieldIndex] = fields[fieldIndex].substring(1, fields[fieldIndex].length() - 1);
                }
                fields[fieldIndex].trim();
            }
            fieldIndex++;
            startPos = i + 1;
        }
    }
    
    if (fieldIndex < 3) { // We need at least 4 fields (0-3)
        return false;
    }
    
    // Parse fields into JSON
    entry["timestamp"] = fields[0];
    entry["source"] = fields[1];
    entry["description"] = fields[2];
    entry["priority"] = fields[3];
    
    return true;
}

// Static method to get event log statistics
String LoggerManager::getEventLogStatsJson(const String& startDate, const String& endDate) {
    if (!_instance) {
        return "{\"success\":false,\"error\":\"LoggerManager not initialized\"}";
    }
    
    DynamicJsonDocument doc(1024);
    doc["success"] = true;
    
    // Initialize counters
    int totalEntries = 0;
    int criticalCount = 0;
    int errorCount = 0;
    int warningCount = 0;
    int infoCount = 0;
    
    // Get all event log files in the date range
    std::vector<String> files = _getEventLogFilesInRange(startDate, endDate);
    
    // Count entries by priority
    for (const String& filename : files) {
        String fullPath = _instance->_eventLogDirectory.isEmpty() ? "/" : _instance->_eventLogDirectory;
        if (!fullPath.endsWith("/")) fullPath += "/";
        fullPath += filename;
        
        File file = _instance->_fs->open(fullPath.c_str(), FILE_READ);
        if (!file) {
            continue;
        }
        
        // Skip header line
        if (file.available()) {
            file.readStringUntil('\n');
        }
        
        // Read data lines
        while (file.available()) {
            String line = file.readStringUntil('\n');
            line.trim();
            if (line.isEmpty()) continue;
            
            totalEntries++;
            
            // Quick parse to get priority (last field)
            int lastComma = line.lastIndexOf(',');
            if (lastComma != -1) {
                String priority = line.substring(lastComma + 1);
                priority.trim();
                
                // Remove quotes if present
                if (priority.startsWith("\"") && priority.endsWith("\"")) {
                    priority = priority.substring(1, priority.length() - 1);
                }
                
                if (priority == "CRITICAL") {
                    criticalCount++;
                } else if (priority == "ERROR") {
                    errorCount++;
                } else if (priority == "WARNING") {
                    warningCount++;
                } else if (priority == "INFO") {
                    infoCount++;
                }
            }
        }
        
        file.close();
    }
    
    // Build statistics JSON
    doc["totalEntries"] = totalEntries;
    doc["dateRange"]["start"] = startDate;
    doc["dateRange"]["end"] = endDate;
    doc["filesFound"] = files.size();
    
    JsonObject priorityStats = doc.createNestedObject("priorityStats");
    priorityStats["critical"] = criticalCount;
    priorityStats["error"] = errorCount;
    priorityStats["warning"] = warningCount;
    priorityStats["info"] = infoCount;
    
    String output;
    serializeJson(doc, output);
    return output;
}

// Static method to get event log files
std::vector<String> LoggerManager::getEventLogFilesStatic() {
    std::vector<String> files;
    
    if (!_instance) {
        return files;
    }
    
    String dirPath = _instance->_eventLogDirectory.isEmpty() ? "/" : _instance->_eventLogDirectory;
    File dir = _instance->_fs->open(dirPath.c_str());
    
    if (!dir || !dir.isDirectory()) {
        return files;
    }
    
    File file = dir.openNextFile();
    while (file) {
        String filename = String(file.name());
        if (filename.startsWith("events_") && filename.endsWith(".csv")) {
            files.push_back(filename);
        }
        file = dir.openNextFile();
    }
    
    dir.close();
    
    // Sort files by date
    std::sort(files.begin(), files.end());
    
    return files;
}



// Static method to get temperature data log files
std::vector<String> LoggerManager::getLogFiles() {
    std::vector<String> files;
    if (!_instance) {
        return files;
    }
    
    String dirPath = _instance->_logDirectory.isEmpty() ? "/" : _instance->_logDirectory;
    File dir = _instance->_fs->open(dirPath.c_str());
    if (!dir || !dir.isDirectory()) {
        return files;
    }
    
    File file = dir.openNextFile();
    while (file) {
        String filename = String(file.name());
        if (filename.startsWith("temp_log_") && filename.endsWith(".csv")) {
            files.push_back(filename);
        }
        file = dir.openNextFile();
    }
    
    dir.close();
    std::sort(files.begin(), files.end());
    return files;
}

// Static method to get alarm state log files
std::vector<String> LoggerManager::getAlarmStateLogFiles() {
    std::vector<String> files;
    if (!_instance) {
        return files;
    }
    
    String dirPath = _instance->_alarmStateLogDirectory.isEmpty() ? "/" : _instance->_alarmStateLogDirectory;
    File dir = _instance->_fs->open(dirPath.c_str());
    if (!dir || !dir.isDirectory()) {
        return files;
    }
    
    File file = dir.openNextFile();
    while (file) {
        String filename = String(file.name());
        if (filename.startsWith("alarm_states_") && filename.endsWith(".csv")) {
            files.push_back(filename);
        }
        file = dir.openNextFile();
    }
    
    dir.close();
    std::sort(files.begin(), files.end());
    return files;
}

// Static method to get file information
bool LoggerManager::getFileInfo(const String& filename, const String& type, size_t& fileSize, String& date) {
    if (!_instance) {
        return false;
    }
    
    String dirPath = getLogDirectoryPath(type);
    String fullPath = dirPath;
    if (!fullPath.endsWith("/") && !fullPath.isEmpty()) fullPath += "/";
    fullPath += filename;
    
    File file = _instance->_fs->open(fullPath.c_str(), FILE_READ);
    if (!file) {
        return false;
    }
    
    fileSize = file.size();
    file.close();
    
    // Extract date from filename based on type
    if (type == "data" && filename.startsWith("temp_log_") && filename.endsWith(".csv")) {
        int firstUnderscore = filename.indexOf('_', 5); // Skip "temp_"
        int secondUnderscore = filename.indexOf('_', firstUnderscore + 1);
        if (firstUnderscore > 0 && secondUnderscore > firstUnderscore) {
            date = filename.substring(firstUnderscore + 1, secondUnderscore);
        }
    } else if (type == "event" && filename.startsWith("events_") && filename.endsWith(".csv")) {
        date = filename.substring(7, filename.length() - 4);
    } else if (type == "alarm" && filename.startsWith("alarm_states_") && filename.endsWith(".csv")) {
        date = filename.substring(13, filename.length() - 4);
    }
    
    return true;
}

// Static method to open log files
File LoggerManager::openLogFile(const String& filename, const String& type) {
    if (!_instance) {
        return File();
    }
    
    String dirPath = getLogDirectoryPath(type);
    String fullPath = dirPath;
    if (!fullPath.endsWith("/") && !fullPath.isEmpty()) fullPath += "/";
    fullPath += filename;
    
    return _instance->_fs->open(fullPath.c_str(), FILE_READ);
}

// Static method to get directory path for different log types
String LoggerManager::getLogDirectoryPath(const String& type) {
    if (!_instance) {
        return "/";
    }
    
    if (type == "data") {
        return _instance->_logDirectory.isEmpty() ? "/" : _instance->_logDirectory;
    } else if (type == "event") {
        return _instance->_eventLogDirectory.isEmpty() ? "/" : _instance->_eventLogDirectory;
    } else if (type == "alarm") {
        return _instance->_alarmStateLogDirectory.isEmpty() ? "/" : _instance->_alarmStateLogDirectory;
    }
    
    return "/";
}


// std::vector<String> LoggerManager::getLogFiles() {

//     std::vector<String> files;
    
//     File dir = _fs->open(_logDirectory.c_str());
//     if (!dir || !dir.isDirectory()) {
//         return files;
//     }
    
//     File file = dir.openNextFile();
//     while (file) {
//         if (!file.isDirectory() && String(file.name()).endsWith(".csv")) {
//             files.push_back(String(file.name()));
//         }
//         file = dir.openNextFile();
//     }
    
//     dir.close();
//     return files;
// }

-------- [ Separator ] ------

File Name: src/MeasurementPoint.cpp
Size: 3.92 KB
Code:
#include "MeasurementPoint.h"


MeasurementPoint::MeasurementPoint(uint8_t address, const String& name)
    : address(address),
      name(name),
      currentTemp(0),
      minTemp(32767),
      maxTemp(-32768),
      lowAlarmThreshold(-10),
      highAlarmThreshold(50),
      alarmStatus(0),
      errorStatus(0),
      boundSensor(nullptr)
      //oneWireBus(0)
{
    // Nothing else needed
}

MeasurementPoint::~MeasurementPoint() {
    // Do not delete boundSensor here; ownership is external
    boundSensor = nullptr;
}

uint8_t MeasurementPoint::getAddress() const {
    return address;
}

String MeasurementPoint::getName() const {
    return name;
}

int16_t MeasurementPoint::getCurrentTemp() const {
    return currentTemp;
}

int16_t MeasurementPoint::getMinTemp() const {
    return minTemp;
}

int16_t MeasurementPoint::getMaxTemp() const {
    return maxTemp;
}

int16_t MeasurementPoint::getLowAlarmThreshold() const {
    return lowAlarmThreshold;
}

int16_t MeasurementPoint::getHighAlarmThreshold() const {
    return highAlarmThreshold;
}

uint8_t MeasurementPoint::getAlarmStatus() const {
    return alarmStatus;
}

uint8_t MeasurementPoint::getErrorStatus() const {
    return errorStatus;
}

void MeasurementPoint::setName(const String& newName) {
    if (newName != name) {
        String oldName = name.isEmpty() ? "Point_" + String(address) : name;
        name = newName;
        LoggerManager::info("POINT_CONFIG", 
            "Point " + String(address) + " name changed from '" + 
            oldName + "' to '" + name + "'");
    }
    //name = newName;
}

void MeasurementPoint::setLowAlarmThreshold(int16_t threshold) {

    if (lowAlarmThreshold != threshold) {
        LoggerManager::info("POINT_CONFIG", 
            "Point " + String(address) + " (" + name + 
            ") low alarm threshold changed from " + String(lowAlarmThreshold) + 
            "¬∞C to " + String(threshold) + "¬∞C");
        lowAlarmThreshold = threshold;
    }

    //lowAlarmThreshold = threshold;
    updateAlarmStatus();
}

void MeasurementPoint::setHighAlarmThreshold(int16_t threshold) {
    if (highAlarmThreshold != threshold) {
        LoggerManager::info("POINT_CONFIG", 
            "Point " + String(address) + " (" + name + 
            ") high alarm threshold changed from " + String(highAlarmThreshold) + 
            "¬∞C to " + String(threshold) + "¬∞C");
        highAlarmThreshold = threshold;
    }
    //highAlarmThreshold = threshold;
    updateAlarmStatus();
}

void MeasurementPoint::bindSensor(Sensor* sensor) {
    boundSensor = sensor;
}

void MeasurementPoint::unbindSensor() {
    boundSensor = nullptr;
}

Sensor* MeasurementPoint::getBoundSensor() const {
    return boundSensor;
}

void MeasurementPoint::update() {
    if (boundSensor != nullptr) {
        // Example: ask the sensor for the latest temperature
        //if (boundSensor->readTemperature()) {
            currentTemp = boundSensor->getCurrentTemp();
            //Serial.printf("\nPoint: %d. %s. Sensor: %s. Temp: %d\n", getAddress(), getName(), boundSensor->getName(), currentTemp);
            if (currentTemp < minTemp) minTemp = currentTemp;
            if (currentTemp > maxTemp) maxTemp = currentTemp;
            errorStatus = boundSensor->getErrorStatus();
        //} else {
            //errorStatus = boundSensor->getErrorStatus();
        //}
    } else {
        errorStatus = 0x01; // Example: error code for "not bound"
    }
    updateAlarmStatus();
}

void MeasurementPoint::resetMinMaxTemp() {
    minTemp = currentTemp;
    maxTemp = currentTemp;
}

void MeasurementPoint::updateAlarmStatus() {
    alarmStatus = 0;
    if (errorStatus != 0) return;
    if (currentTemp < lowAlarmThreshold) alarmStatus |= 0x01; // Low alarm bit
    if (currentTemp > highAlarmThreshold) alarmStatus |= 0x02; // High alarm bit
}

// void MeasurementPoint::setOneWireBus(uint8_t bus) {
//     oneWireBus = bus;

// }
// uint8_t MeasurementPoint::getOneWireBus() {
//     return oneWireBus;

// }

-------- [ Separator ] ------

File Name: src/RegisterMap.cpp
Size: 5.20 KB
Code:
#include "RegisterMap.h"

RegisterMap::RegisterMap() {
    deviceId = 1000;
    firmwareVersion = 0x0100;
    numActiveDS18B20 = 0;
    numActivePT1000 = 0;
    for (int i = 0; i < 7; i++) deviceStatus[i] = 0;
    for (int i = 0; i < 60; i++) {
        currentTemps[i] = 0;
        minTemps[i] = 32767;
        maxTemps[i] = -32768;
        alarmStatus[i] = 0;
        errorStatus[i] = 0;
        lowAlarmThresholds[i] = -10;
        highAlarmThresholds[i] = 50;
    }
}

bool RegisterMap::isValidAddress(uint16_t address) {
    if (address <= DEVICE_STATUS_END_REG) return true;
    if (address >= CURRENT_TEMP_DS18B20_START_REG && address <= CURRENT_TEMP_PT1000_END_REG) return true;
    if (address >= MIN_TEMP_DS18B20_START_REG && address <= MIN_TEMP_PT1000_END_REG) return true;
    if (address >= MAX_TEMP_DS18B20_START_REG && address <= MAX_TEMP_PT1000_END_REG) return true;
    if (address >= ALARM_STATUS_DS18B20_START_REG && address <= ALARM_STATUS_PT1000_END_REG) return true;
    if (address >= ERROR_STATUS_DS18B20_START_REG && address <= ERROR_STATUS_PT1000_END_REG) return true;
    if (address >= LOW_ALARM_DS18B20_START_REG && address <= LOW_ALARM_PT1000_END_REG) return true;
    if (address >= HIGH_ALARM_DS18B20_START_REG && address <= HIGH_ALARM_PT1000_END_REG) return true;
    return false;
}

bool RegisterMap::isReadOnlyRegister(uint16_t address) {
    // Only alarm thresholds are writable
    if (address >= LOW_ALARM_DS18B20_START_REG && address <= LOW_ALARM_PT1000_END_REG) return false;
    if (address >= HIGH_ALARM_DS18B20_START_REG && address <= HIGH_ALARM_PT1000_END_REG) return false;
    return true;
}

uint16_t RegisterMap::readHoldingRegister(uint16_t address) {
    if (!isValidAddress(address)) return 0xFFFF;

    if (address == DEVICE_ID_REG) return deviceId;
    if (address == FIRMWARE_VERSION_REG) return firmwareVersion;
    if (address == NUM_DS18B20_REG) return numActiveDS18B20;
    if (address == NUM_PT1000_REG) return numActivePT1000;
    if (address >= DEVICE_STATUS_START_REG && address <= DEVICE_STATUS_END_REG)
        return deviceStatus[address - DEVICE_STATUS_START_REG];

    // DS18B20 and PT1000 share the same arrays, just different index offsets
    if (address >= CURRENT_TEMP_DS18B20_START_REG && address <= CURRENT_TEMP_PT1000_END_REG)
        return currentTemps[address - CURRENT_TEMP_DS18B20_START_REG];
    if (address >= MIN_TEMP_DS18B20_START_REG && address <= MIN_TEMP_PT1000_END_REG)
        return minTemps[address - MIN_TEMP_DS18B20_START_REG];
    if (address >= MAX_TEMP_DS18B20_START_REG && address <= MAX_TEMP_PT1000_END_REG)
        return maxTemps[address - MAX_TEMP_DS18B20_START_REG];
    if (address >= ALARM_STATUS_DS18B20_START_REG && address <= ALARM_STATUS_PT1000_END_REG)
        return alarmStatus[address - ALARM_STATUS_DS18B20_START_REG];
    if (address >= ERROR_STATUS_DS18B20_START_REG && address <= ERROR_STATUS_PT1000_END_REG)
        return errorStatus[address - ERROR_STATUS_DS18B20_START_REG];
    if (address >= LOW_ALARM_DS18B20_START_REG && address <= LOW_ALARM_PT1000_END_REG)
        return lowAlarmThresholds[address - LOW_ALARM_DS18B20_START_REG];
    if (address >= HIGH_ALARM_DS18B20_START_REG && address <= HIGH_ALARM_PT1000_END_REG)
        return highAlarmThresholds[address - HIGH_ALARM_DS18B20_START_REG];

    return 0xFFFF;
}

bool RegisterMap::writeHoldingRegister(uint16_t address, uint16_t value) {
    if (!isValidAddress(address)) return false;
    if (isReadOnlyRegister(address)) return false;

    // Only alarm thresholds are writable
    if (address >= LOW_ALARM_DS18B20_START_REG && address <= LOW_ALARM_PT1000_END_REG) {
        lowAlarmThresholds[address - LOW_ALARM_DS18B20_START_REG] = static_cast<int16_t>(value);
        return true;
    }
    if (address >= HIGH_ALARM_DS18B20_START_REG && address <= HIGH_ALARM_PT1000_END_REG) {
        highAlarmThresholds[address - HIGH_ALARM_DS18B20_START_REG] = static_cast<int16_t>(value);
        return true;
    }
    return false;
}

void RegisterMap::updateFromMeasurementPoint(const MeasurementPoint& point) {
    uint8_t idx = point.getAddress();
    // DS18B20: 0-49, PT1000: 50-59
    if (idx < 60) {
        currentTemps[idx] = point.getCurrentTemp();
        minTemps[idx] = point.getMinTemp();
        maxTemps[idx] = point.getMaxTemp();
        alarmStatus[idx] = point.getAlarmStatus();
        errorStatus[idx] = point.getErrorStatus();
        // Thresholds are updated by config methods, not here
    }
}

void RegisterMap::applyConfigToMeasurementPoint(MeasurementPoint& point) {
    uint8_t idx = point.getAddress();
    if (idx < 60) {
        point.setLowAlarmThreshold(lowAlarmThresholds[idx]);
        point.setHighAlarmThreshold(highAlarmThresholds[idx]);
        //Serial.printf("applyConfigToMeasurementPoint(%d): LAS: %d, HAS: %d\n", idx, lowAlarmThresholds[idx], highAlarmThresholds[idx]);
    }
}

void RegisterMap::applyConfigFromMeasurementPoint(const MeasurementPoint& point) {
    uint8_t idx = point.getAddress();
    if (idx < 60) {
        lowAlarmThresholds[idx] = point.getLowAlarmThreshold();
        highAlarmThresholds[idx] = point.getHighAlarmThreshold();
        //Serial.printf("applyConfigFromMeasurementPoint(%d): LAS: %d, HAS: %d\n", idx, lowAlarmThresholds[idx], highAlarmThresholds[idx]);
    }
}

-------- [ Separator ] ------

File Name: src/Sensor.cpp
Size: 7.31 KB
Code:
#include "Sensor.h"

//SPI PINs
// #define SCK_PIN  14
// #define MISO_PIN  12
// #define MOSI_PIN  13

Sensor::Sensor(SensorType type, uint8_t address, const String& name)
    : address(address), name(name), type(type),
      currentTemp(0), minTemp(32767), maxTemp(-32768),
      lowAlarmThreshold(-40), highAlarmThreshold(85),
      alarmStatus(0), errorStatus(0),
      oneWire(nullptr), dallasTemperature(nullptr), max31865(nullptr)
{
    if (type == SensorType::DS18B20) {
        connection.ds18b20.oneWirePin = 0;
        memset(connection.ds18b20.oneWireAddress, 0, 8);
    } else {
        connection.pt1000.csPin = 0;
        connection.pt1000.maxAddress = 0;
    }
}

Sensor::~Sensor() {
    if (oneWire != nullptr) {
        delete oneWire;
        oneWire = nullptr;
    }
    if (dallasTemperature != nullptr) {
        delete dallasTemperature;
        dallasTemperature = nullptr;
    }
    if (max31865 != nullptr) {
        delete max31865;
        max31865 = nullptr;
    }
}

void Sensor::setupDS18B20(uint8_t pin, const uint8_t* deviceAddress) {
    connection.ds18b20.oneWirePin = pin;
    memcpy(connection.ds18b20.oneWireAddress, deviceAddress, 8);
}

void Sensor::setupPT1000(uint8_t csPin, uint8_t maxAddress) {
    connection.pt1000.csPin = csPin;
    connection.pt1000.maxAddress = maxAddress;
}

bool Sensor::initialize() {
    if (type == SensorType::DS18B20) {
        oneWire = new OneWire(connection.ds18b20.oneWirePin);
        dallasTemperature = new DallasTemperature(oneWire);
        dallasTemperature->begin();
        DeviceAddress deviceAddress;
        memcpy(deviceAddress, connection.ds18b20.oneWireAddress, 8);
        dallasTemperature->setResolution(deviceAddress, 12);
        return dallasTemperature->isConnected(deviceAddress);
    } else if (type == SensorType::PT1000) {
        max31865 = new Adafruit_MAX31865(connection.pt1000.csPin);
        
        // Try to begin the MAX31865
        bool beginSuccess = max31865->begin(MAX31865_3WIRE); // Adjust for your wiring
        
        // if (!beginSuccess) {
        //     errorStatus |= ERROR_COMMUNICATION;
        //     return false;
        // }
        
        // // Check for faults immediately after initialization
        // uint8_t fault = max31865->readFault();
        // if (fault) {
        //     max31865->clearFault();
        //     errorStatus |= ERROR_COMMUNICATION;
        //     return false;
        // }
        
        // // Read RTD value to verify communication
        // uint16_t rtd = max31865->readRTD();
        // if (rtd == 0 || rtd == 0xFFFF) {  // Common values when module is not connected
        //     errorStatus |= ERROR_COMMUNICATION;
        //     // return false;
        // }
        
        // // Calculate resistance to check if it's within reasonable range for PT1000
        // float ratio = rtd / 32768.0;
        // float resistance = 4300.0 * ratio;  // Using RREF of 4300 for PT1000
        
        // // PT1000 should be roughly 1000 ohms at 0¬∞C, with reasonable range between 800-1400 ohms
        // // for normal temperature measurements (-50¬∞C to +100¬∞C)
        // if (resistance < 800.0 || resistance > 2200.0) {
        //     errorStatus |= ERROR_DISCONNECTED;
        //     // return false;
        // }
        
        return true;
    }
    return false;
}

bool Sensor::readTemperature() {
    float tempC = 0.0;
    bool success = false;
    errorStatus &= ~(ERROR_COMMUNICATION | ERROR_OUT_OF_RANGE | ERROR_DISCONNECTED);

    if (type == SensorType::DS18B20) {
        if (dallasTemperature != nullptr) {
            DeviceAddress deviceAddress;
            memcpy(deviceAddress, connection.ds18b20.oneWireAddress, 8);
            if (dallasTemperature->isConnected(deviceAddress)) {
                dallasTemperature->requestTemperaturesByAddress(deviceAddress);
                tempC = dallasTemperature->getTempC(deviceAddress);
                if (tempC != DEVICE_DISCONNECTED_C) {
                    success = true;
                } else {
                    errorStatus |= ERROR_DISCONNECTED;
                }
            } else {
                errorStatus |= ERROR_COMMUNICATION;
            }
        }
    } else if (type == SensorType::PT1000) {
        if (max31865 != nullptr) {
            uint8_t fault = max31865->readFault();
            // if (fault) {
            //     // if (fault & MAX31865_FAULT_HIGHTHRESH || fault & MAX31865_FAULT_LOWTHRESH) {
            //     //     errorStatus |= ERROR_OUT_OF_RANGE;
            //     // }
                if (fault & (MAX31865_FAULT_REFINLOW | MAX31865_FAULT_REFINHIGH |
                             MAX31865_FAULT_RTDINLOW | MAX31865_FAULT_OVUV)) {
                    errorStatus |= ERROR_COMMUNICATION;
                    max31865->clearFault();
                
                } else {
                    tempC = max31865->temperature(1000.0, 4300.0); // PT1000: 1000 ohm at 0¬∞C, adjust reference as needed
                    success = true;
                }
        }
    }

    if (success) {
        if (tempC < -40.0 || tempC > 200.0) {
            errorStatus |= ERROR_OUT_OF_RANGE;
        } else {
            currentTemp = static_cast<int16_t>(round(tempC));
            if (currentTemp < minTemp) minTemp = currentTemp;
            if (currentTemp > maxTemp) maxTemp = currentTemp;
        }
    }
    updateAlarmStatus();
    return success;
}

SensorType Sensor::getType() const { return type; }
uint8_t Sensor::getAddress() const { return address; }
String Sensor::getName() const { return name; }
void Sensor::setName(const String& newName) { name = newName; }

int16_t Sensor::getCurrentTemp() const {return currentTemp; }
int16_t Sensor::getMinTemp() const { return minTemp; }
int16_t Sensor::getMaxTemp() const { return maxTemp; }
int16_t Sensor::getLowAlarmThreshold() const { return lowAlarmThreshold; }
int16_t Sensor::getHighAlarmThreshold() const { return highAlarmThreshold; }
uint8_t Sensor::getAlarmStatus() const { return alarmStatus; }
uint8_t Sensor::getErrorStatus() const { return errorStatus; }

void Sensor::setAddress(uint8_t newAddress) { address = newAddress; }
void Sensor::setLowAlarmThreshold(int16_t threshold) { lowAlarmThreshold = threshold; updateAlarmStatus(); }
void Sensor::setHighAlarmThreshold(int16_t threshold) { highAlarmThreshold = threshold; updateAlarmStatus(); }

const uint8_t* Sensor::getDS18B20Address() const {
    if (type == SensorType::DS18B20) {
        return connection.ds18b20.oneWireAddress;
    }
    return nullptr;
}

void Sensor::resetMinMaxTemp() {
    minTemp = currentTemp;
    maxTemp = currentTemp;
}

void Sensor::updateAlarmStatus() {
    alarmStatus = 0;
    if (errorStatus != 0) return;
    if (currentTemp < lowAlarmThreshold) alarmStatus |= ALARM_LOW_TEMP;
    if (currentTemp > highAlarmThreshold) alarmStatus |= ALARM_HIGH_TEMP;
}


uint8_t Sensor::getPT1000ChipSelectPin() const {
    if (type == SensorType::PT1000) return connection.pt1000.csPin;
    return 0;
}

String Sensor::getDS18B20RomString() const {
    if (type != SensorType::DS18B20) return "";
    char buf[17]; // 16 hex chars + null
    const uint8_t* rom = connection.ds18b20.oneWireAddress;
    for (int i = 0; i < 8; ++i) {
        sprintf(buf + i*2, "%02X", rom[i]);
    }
    return String(buf);
}

void Sensor::getDS18B20RomArray(uint8_t out[8]) const {
    if (type == SensorType::DS18B20) {
        memcpy(out, connection.ds18b20.oneWireAddress, 8);
    }
}
-------- [ Separator ] ------

File Name: src/SettingsCSVManager.cpp
Size: 6.01 KB
Code:
#include "SettingsCSVManager.h"

SettingsCSVManager::SettingsCSVManager(ConfigAssist& config) 
    : _config(config), _lastError("") {
}

String SettingsCSVManager::exportSettingsToCSV() {
    String csv = "Setting,Value\n";
    
    // WiFi Settings
    csv += "st_ssid," + _escapeCSVField(_config("st_ssid")) + "\n";
    csv += "st_pass," + _escapeCSVField(_config("st_pass")) + "\n";
    csv += "host_name," + _escapeCSVField(_config("host_name")) + "\n";
    
    // Device Settings
    csv += "device_id," + _config("device_id") + "\n";
    csv += "firmware_version," + _escapeCSVField(_config("firmware_version")) + "\n";
    csv += "measurement_period," + _config("measurement_period") + "\n";
    
    // Acknowledged Delay Settings
    csv += "ack_delay_critical," + _config("ack_delay_critical") + "\n";
    csv += "ack_delay_high," + _config("ack_delay_high") + "\n";
    csv += "ack_delay_medium," + _config("ack_delay_medium") + "\n";
    csv += "ack_delay_low," + _config("ack_delay_low") + "\n";
    
    // Modbus Settings
    csv += "modbus_enabled," + _config("modbus_enabled") + "\n";
    csv += "modbus_address," + _config("modbus_address") + "\n";
    csv += "modbus_baud_rate," + _config("modbus_baud_rate") + "\n";
    
    return csv;
}

bool SettingsCSVManager::importSettingsFromCSV(const String& csvData) {
    if (!validateSettingsCSV(csvData)) {
        return false;
    }
    
    int lineStart = 0;
    int lineEnd = csvData.indexOf('\n');
    
    // Skip header line
    if (lineEnd == -1) {
        _lastError = "Invalid CSV format";
        return false;
    }
    lineStart = lineEnd + 1;
    
    // Parse each data line
    while (lineStart < csvData.length()) {
        lineEnd = csvData.indexOf('\n', lineStart);
        if (lineEnd == -1) lineEnd = csvData.length();
        
        String line = csvData.substring(lineStart, lineEnd);
        line.trim();
        
        if (line.length() > 0) {
            if (!_parseCSVLine(line)) {
                return false;
            }
        }
        
        lineStart = lineEnd + 1;
    }
    
    return true;
}

bool SettingsCSVManager::validateSettingsCSV(const String& csvData) {
    if (csvData.length() == 0) {
        _lastError = "Empty CSV data";
        return false;
    }
    
    // Check for header line
    int headerEnd = csvData.indexOf('\n');
    if (headerEnd == -1) {
        _lastError = "No header line found";
        return false;
    }
    
    String header = csvData.substring(0, headerEnd);
    if (header.indexOf("Setting") == -1 || header.indexOf("Value") == -1) {
        _lastError = "Invalid header format. Expected 'Setting,Value'";
        return false;
    }
    
    return true;
}

bool SettingsCSVManager::_parseCSVLine(const String& line) {
    int commaIndex = line.indexOf(',');
    if (commaIndex == -1) {
        _lastError = "Invalid CSV line format: " + line;
        return false;
    }
    
    String key = line.substring(0, commaIndex);
    String value = line.substring(commaIndex + 1);
    
    key.trim();
    value = _unescapeCSVField(value);
    
    // Validate and set configuration values
    if (key == "st_ssid" || key == "st_pass" || key == "host_name" || 
        key == "firmware_version" || key == "modbus_baud_rate") {
        // String values
        _config[key] = value;
    } else if (key == "device_id") {
        int deviceId = value.toInt();
        if (deviceId < 1 || deviceId > 9999) {
            _lastError = "Invalid device_id: " + value + " (must be 1-9999)";
            return false;
        }
        _config[key] = value;
    } else if (key == "measurement_period") {
        int period = value.toInt();
        if (period < 1 || period > 3600) {
            _lastError = "Invalid measurement_period: " + value + " (must be 1-3600)";
            return false;
        }
        _config[key] = value;
    } else if (key == "ack_delay_critical" || key == "ack_delay_high" || 
               key == "ack_delay_medium" || key == "ack_delay_low") {
        // Acknowledged delay validation
        int delay = value.toInt();
        if (delay < 1 || delay > 1440) {
            _lastError = "Invalid " + key + ": " + value + " (must be 1-1440 minutes)";
            return false;
        }
        _config[key] = value;
    } else if (key == "modbus_enabled") {
        if (value != "0" && value != "1") {
            String lowerValue = value;
            lowerValue.toLowerCase();
            if (lowerValue != "true" && lowerValue != "false") {
                _lastError = "Invalid modbus_enabled: " + value + " (must be 0/1 or true/false)";
                return false;
            }
            if (lowerValue == "true") value = "1";
            if (lowerValue == "false") value = "0";
        }
        _config[key] = value;
    } else if (key == "modbus_address") {
        int address = value.toInt();
        if (address < 1 || address > 247) {
            _lastError = "Invalid modbus_address: " + value + " (must be 1-247)";
            return false;
        }
        _config[key] = value;
    } else {
        // Unknown setting - log warning but don't fail
        Serial.println("Warning: Unknown setting in CSV: " + key);
        _config[key] = value;  // Still import it in case it's a future setting
    }
    
    return true;
}


String SettingsCSVManager::_escapeCSVField(const String& field) {
    if (field.indexOf(',') >= 0 || field.indexOf('"') >= 0 || field.indexOf('\n') >= 0) {
        String escaped = "\"";
        for (int i = 0; i < field.length(); i++) {
            if (field.charAt(i) == '"') {
                escaped += "\"\"";
            } else {
                escaped += field.charAt(i);
            }
        }
        escaped += "\"";
        return escaped;
    }
    return field;
}

String SettingsCSVManager::_unescapeCSVField(const String& field) {
    String trimmed = field;
    trimmed.trim();
    
    if (trimmed.startsWith("\"") && trimmed.endsWith("\"")) {
        String unescaped = trimmed.substring(1, trimmed.length() - 1);
        unescaped.replace("\"\"", "\"");
        return unescaped;
    }
    return trimmed;
}

-------- [ Separator ] ------

File Name: src/TempModbusServer.cpp
Size: 14.62 KB
Code:
#include "TempModbusServer.h"

TempModbusServer::TempModbusServer(RegisterMap& regMap, 
    uint8_t id, 
    HardwareSerial& serialPort, 
    int rx, 
    int tx, 
    int de,
    int baud) 
: registerMap(regMap), serverID(id), serial(serialPort), 
rxPin(rx), txPin(tx), baudRate(baud), dePin(de) {

// Create ModbusRTU server with 2000ms timeout
mbServer = new ModbusServerRTU(1000, dePin);

// Set static pointer to register map for worker functions
registerMapPtr = &regMap;

// LOG: Modbus server creation
LoggerManager::info("MODBUS", 
"Modbus server created - ID: " + String(id) + 
", Baud: " + String(baud) + 
", RX: " + String(rx) + 
", TX: " + String(tx) + 
", DE: " + String(de));
}


RegisterMap* TempModbusServer::registerMapPtr = nullptr;

TempModbusServer::~TempModbusServer() {
    if (mbServer) {
        // No need to call stop() as it doesn't exist
        delete mbServer;
        mbServer = nullptr;
    }
}


// bool TempModbusServer::begin() {
//     // Prepare serial port for Modbus RTU
//     RTUutils::prepareHardwareSerial(serial);
//     Serial.println("Modbus begin1");
//     if (baudRate == 0) {
//         baudRate = 9600;
//     }
//     serial.begin(baudRate, SERIAL_8N1, rxPin, txPin);
//     Serial.println("Modbus begin2");
    
//     // Register worker functions for different Modbus function codes
//     mbServer->registerWorker(serverID, READ_HOLD_REGISTER, &TempModbusServer::readHoldingRegistersWorker);
//     Serial.println("Modbus begin3");
//     mbServer->registerWorker(serverID, WRITE_HOLD_REGISTER, &TempModbusServer::writeHoldingRegisterWorker);
//     Serial.println("Modbus begin4");
//     mbServer->registerWorker(serverID, WRITE_MULT_REGISTERS, &TempModbusServer::writeMultipleRegistersWorker);
//     Serial.println("Modbus begin5");
    
//     // Start ModbusRTU server - note that begin() returns void
//     mbServer->begin(serial);
//     return true; // Assume success since we can't check
// }

bool TempModbusServer::begin() {
    LoggerManager::info("MODBUS", "Starting Modbus RTU server initialization");
    
    // Prepare serial port for Modbus RTU
    RTUutils::prepareHardwareSerial(serial);
    Serial.println("Modbus begin1");
    
    if (baudRate == 0) {
        baudRate = 9600;
        LoggerManager::warning("MODBUS", "Baud rate was 0, defaulting to 9600");
    }
    
    serial.begin(baudRate, SERIAL_8N1, rxPin, txPin);
    LoggerManager::info("MODBUS", 
        "Serial port initialized - Baud: " + String(baudRate) + 
        ", RX: " + String(rxPin) + 
        ", TX: " + String(txPin));
    Serial.println("Modbus begin2");
    
    // Register worker functions for different Modbus function codes
    mbServer->registerWorker(serverID, READ_HOLD_REGISTER, &TempModbusServer::readHoldingRegistersWorker);
    LoggerManager::info("MODBUS", "Registered READ_HOLD_REGISTER worker (FC=03)");
    Serial.println("Modbus begin3");
    
    mbServer->registerWorker(serverID, WRITE_HOLD_REGISTER, &TempModbusServer::writeHoldingRegisterWorker);
    LoggerManager::info("MODBUS", "Registered WRITE_HOLD_REGISTER worker (FC=06)");
    Serial.println("Modbus begin4");
    
    mbServer->registerWorker(serverID, WRITE_MULT_REGISTERS, &TempModbusServer::writeMultipleRegistersWorker);
    LoggerManager::info("MODBUS", "Registered WRITE_MULT_REGISTERS worker (FC=16)");
    Serial.println("Modbus begin5");
    
    // Start ModbusRTU server - note that begin() returns void
    mbServer->begin(serial);
    
    LoggerManager::info("MODBUS", 
        "Modbus RTU server started successfully - Server ID: " + String(serverID));
    
    return true; // Assume success since we can't check
}



void TempModbusServer::stop() {
    // There is no stop() method in ModbusServerRTU
    // You might want to implement any cleanup needed here
}


// Worker function for READ_HOLD_REGISTER (FC=03)
// ModbusMessage TempModbusServer::readHoldingRegistersWorker(ModbusMessage request) {
//     uint16_t address;           // Requested register address
//     uint16_t words;             // Requested number of registers
//     ModbusMessage response;     // Response message to be sent back
    
//     // Get request values
//     request.get(2, address);
//     request.get(4, words);
    
//     // Check if address and word count are valid
//     if (words > 0 && words <= 125) {  // Max 125 registers per request as per Modbus spec
//         // Set up response header
//         response.add(request.getServerID(), request.getFunctionCode(), (uint8_t)(words * 2));
        
//         // Add requested register values to response
//         bool allValid = true;
//         for (uint16_t i = 0; i < words; i++) {
//             uint16_t regValue = registerMapPtr->readHoldingRegister(address + i);
            
//             // Check if register read was successful - 0xFFFF is often used as an error indicator
//             if (regValue != 0xFFFF) {
//                 response.add(regValue);
//             } else {
//                 allValid = false;
//                 break;
//             }
//         }
        
//         // If any register was invalid, return error response
//         if (!allValid) {
//             response.clear();
//             response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
//         }
//     } else {
//         // Invalid word count, return error response
//         response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
//     }
    
//     return response;
// }

ModbusMessage TempModbusServer::readHoldingRegistersWorker(ModbusMessage request) {
    uint16_t address;           // Requested register address
    uint16_t words;             // Requested number of registers
    ModbusMessage response;     // Response message to be sent back
    
    // Get request values
    request.get(2, address);
    request.get(4, words);
    
    // LOG: Read request received
    LoggerManager::info("MODBUS_READ", 
        "Read request - Address: " + String(address) + 
        ", Count: " + String(words) + 
        ", Client ID: " + String(request.getServerID()));
    
    // Check if address and word count are valid
    if (words > 0 && words <= 125) {  // Max 125 registers per request as per Modbus spec
        // Set up response header
        response.add(request.getServerID(), request.getFunctionCode(), (uint8_t)(words * 2));
        
        // Add requested register values to response
        bool allValid = true;
        String readValues = "";
        
        for (uint16_t i = 0; i < words; i++) {
            uint16_t regValue = registerMapPtr->readHoldingRegister(address + i);
            
            // Check if register read was successful - 0xFFFF is often used as an error indicator
            if (regValue != 0xFFFF) {
                response.add(regValue);
                if (i < 5) { // Log first 5 values to avoid spam
                    readValues += String(address + i) + ":" + String(regValue) + " ";
                } else if (i == 5) {
                    readValues += "...";
                }
            } else {
                allValid = false;
                LoggerManager::error("MODBUS_READ", 
                    "Failed to read register " + String(address + i));
                break;
            }
        }
        
        // If any register was invalid, return error response
        if (!allValid) {
            response.clear();
            response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
            LoggerManager::error("MODBUS_READ", 
                "Read failed - Invalid register address range: " + 
                String(address) + "-" + String(address + words - 1));
        } else {
            LoggerManager::info("MODBUS_READ", 
                "Read successful - " + String(words) + " registers: " + readValues);
        }
    } else {
        // Invalid word count, return error response
        response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
        LoggerManager::error("MODBUS_READ", 
            "Read failed - Invalid word count: " + String(words) + " (max 125)");
    }
    
    return response;
}



// Worker function for WRITE_HOLD_REGISTER (FC=06)
// ModbusMessage TempModbusServer::writeHoldingRegisterWorker(ModbusMessage request) {
//     uint16_t address;           // Register address to write
//     uint16_t value;             // Value to write
//     ModbusMessage response;     // Response message to be sent back
    
//     // Get request values
//     request.get(2, address);
//     request.get(4, value);
    
//     // Try to write the value to the register
//     if (registerMapPtr->writeHoldingRegister(address, value)) {
//         // Success - echo the request as response
//         return request;
//     } else {
//         // Failed - return error response
//         response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
//         return response;
//     }
// }

ModbusMessage TempModbusServer::writeHoldingRegisterWorker(ModbusMessage request) {
    uint16_t address;           // Register address to write
    uint16_t value;             // Value to write
    ModbusMessage response;     // Response message to be sent back
    
    // Get request values
    request.get(2, address);
    request.get(4, value);
    
    // LOG: Write request received
    LoggerManager::info("MODBUS_WRITE", 
        "Write single register - Address: " + String(address) + 
        ", Value: " + String(value) + 
        ", Client ID: " + String(request.getServerID()));
    
    // Try to write the value to the register
    if (registerMapPtr->writeHoldingRegister(address, value)) {
        // Success - echo the request as response
        LoggerManager::info("MODBUS_WRITE", 
            "Write successful - Register " + String(address) + " = " + String(value));
        return request;
    } else {
        // Failed - return error response
        response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
        LoggerManager::error("MODBUS_WRITE", 
            "Write failed - Invalid register address: " + String(address));
        return response;
    }
}


// Worker function for WRITE_MULT_REGISTERS (FC=16)
// ModbusMessage TempModbusServer::writeMultipleRegistersWorker(ModbusMessage request) {
//     uint16_t address;           // Starting register address
//     uint16_t words;             // Number of registers to write
//     uint8_t bytesCount;         // Number of data bytes in request
//     ModbusMessage response;     // Response message to be sent back
    
//     // Get request values
//     request.get(2, address);
//     request.get(4, words);
//     request.get(6, bytesCount);
    
//     // Check if word count is valid
//     if (words > 0 && words <= 123 && bytesCount == words * 2) {  // Max 123 registers per request
//         bool allWritten = true;
        
//         // Write each register value
//         for (uint16_t i = 0; i < words; i++) {
//             uint16_t value;
//             request.get(7 + i * 2, value);
            
//             if (!registerMapPtr->writeHoldingRegister(address + i, value)) {
//                 allWritten = false;
//                 break;
//             }
//         }
        
//         if (allWritten) {
//             // Success - create response with address and word count
//             response.add(request.getServerID(), request.getFunctionCode());
//             response.add(address);
//             response.add(words);
//         } else {
//             // Failed to write at least one register
//             response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
//         }
//     } else {
//         // Invalid word count or byte count
//         response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
//     }
    
//     return response;
// }
ModbusMessage TempModbusServer::writeMultipleRegistersWorker(ModbusMessage request) {
    uint16_t address;           // Starting register address
    uint16_t words;             // Number of registers to write
    uint8_t bytesCount;         // Number of data bytes in request
    ModbusMessage response;     // Response message to be sent back
    
    // Get request values
    request.get(2, address);
    request.get(4, words);
    request.get(6, bytesCount);
    
    // LOG: Multiple write request received
    LoggerManager::info("MODBUS_WRITE", 
        "Write multiple registers - Start: " + String(address) + 
        ", Count: " + String(words) + 
        ", Bytes: " + String(bytesCount) + 
        ", Client ID: " + String(request.getServerID()));
    
    // Check if word count is valid
    if (words > 0 && words <= 123 && bytesCount == words * 2) {  // Max 123 registers per request
        bool allWritten = true;
        String writeValues = "";
        
        // Write each register value
        for (uint16_t i = 0; i < words; i++) {
            uint16_t value;
            request.get(7 + i * 2, value);
            
            if (registerMapPtr->writeHoldingRegister(address + i, value)) {
                if (i < 5) { // Log first 5 values to avoid spam
                    writeValues += String(address + i) + ":" + String(value) + " ";
                } else if (i == 5) {
                    writeValues += "...";
                }
            } else {
                allWritten = false;
                LoggerManager::error("MODBUS_WRITE", 
                    "Failed to write register " + String(address + i) + " = " + String(value));
                break;
            }
        }
        
        if (allWritten) {
            // Success - create response with address and word count
            response.add(request.getServerID(), request.getFunctionCode());
            response.add(address);
            response.add(words);
            LoggerManager::info("MODBUS_WRITE", 
                "Multiple write successful - " + String(words) + " registers: " + writeValues);
        } else {
            // Failed to write at least one register
            response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
            LoggerManager::error("MODBUS_WRITE", 
                "Multiple write failed - Error writing to register range: " + 
                String(address) + "-" + String(address + words - 1));
        }
    } else {
        // Invalid word count or byte count
        response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
        LoggerManager::error("MODBUS_WRITE", 
            "Multiple write failed - Invalid parameters: Words=" + String(words) + 
            ", Bytes=" + String(bytesCount) + " (expected " + String(words * 2) + ")");
    }
    
    return response;
}

-------- [ Separator ] ------

File Name: src/TemperatureController.cpp
Size: 64.00 KB
Code:
#include "TemperatureController.h"

TemperatureController::TemperatureController(uint8_t oneWirePin[4], uint8_t csPin[4], IndicatorInterface& indicator)
: indicator(indicator), 
measurementPeriodSeconds(10), 
deviceId(1), 
firmwareVersion(0x0100),
lastMeasurementTime(0), 
systemInitialized(false), 
_lastAlarmCheck(0),
_lastButtonState(false), 
_lastButtonPressTime(0), 
_currentDisplayedAlarm(nullptr),
_okDisplayStartTime(0), 
_showingOK(false),

_currentActiveAlarmIndex(0), _currentAcknowledgedAlarmIndex(0),
_lastAlarmDisplayTime(0), _acknowledgedAlarmDisplayDelay(5000), // 5 seconds
_displayingActiveAlarm(false)
{
    // Initialize measurement points
    for (uint8_t i = 0; i < 50; ++i)
        dsPoints[i] = MeasurementPoint(i, "DS18B20_Point_" + String(i));
    for (uint8_t i = 0; i < 10; ++i)
        ptPoints[i] = MeasurementPoint(50 + i, "PT1000_Point_" + String(i));
    
    // Initialize bus pins
    for (uint8_t i = 0; i < 4; i++) {
        oneWireBusPin[i] = oneWirePin[i];
        chipSelectPin[i] = csPin[i];
    }
    
    // Initialize OneWire buses
    for (int i = 0; i < 4; ++i) {
        oneWireBuses[i] = new OneWire(oneWireBusPin[i]);
        dallasSensors[i] = new DallasTemperature(oneWireBuses[i]);
    }
}

TemperatureController::~TemperatureController() {
    // Clean up sensors
    for (auto sensor : sensors)
        delete sensor;
    sensors.clear();
    
 
    
    // Clean up OneWire buses
    for (int i = 0; i < 4; ++i) {
        delete dallasSensors[i];
        delete oneWireBuses[i];
    }

    // Clean up configured alarms
    for (auto alarm : _configuredAlarms)
        delete alarm;
    _configuredAlarms.clear();
}

bool TemperatureController::begin() {
    // Initialize register map
    registerMap.writeHoldingRegister(0, deviceId);
    registerMap.writeHoldingRegister(1, firmwareVersion);
    registerMap.writeHoldingRegister(2, 0);
    registerMap.writeHoldingRegister(3, 0);
    for (int i = 4; i <= 10; i++)
        registerMap.writeHoldingRegister(i, 0);
    
    Serial.println("Discovering sensors...");
    discoverPTSensors();
    Serial.println("Setting HMI...");
    
    // Initialize indicator interface
    if (!indicator.begin()) {
        Serial.println("Failed to initialize indicator interface!");
        return false;
    }
    
    // Configure ports
    indicator.setDirection(0b0000000011111111); // P0-P7 as outputs
    
    // Set port names
    indicator.setPortName("BUTTON", 15);
    indicator.setPortName("Relay1", 0);
    indicator.setPortName("Relay2", 1);
    indicator.setPortName("Relay3", 2);
    indicator.setPortName("GreenLED", 4);
    indicator.setPortName("BlueLED", 5);
    indicator.setPortName("YellowLED", 6);
    indicator.setPortName("RedLED", 7);
    
    // Set individual port inversion for ULN2803
    indicator.setPortInverted("Relay1", false);
    indicator.setPortInverted("Relay2", false);
    indicator.setPortInverted("Relay3", false);
    indicator.setPortInverted("GreenLED", false);
    indicator.setPortInverted("BlueLED", false);
    indicator.setPortInverted("YellowLED", false);
    indicator.setPortInverted("RedLED", false);
    indicator.setPortInverted("BUTTON", false);
    
    // Turn off all LEDs initially
    indicator.setAllOutputsLow();
    
    // Set interrupt callback
    indicator.setInterruptCallback([](uint16_t currentState, uint16_t changedPins) {
        Serial.print("PCF8575 Interrupt - State: 0x");
        Serial.print(currentState, HEX);
        Serial.print(", Changed: 0x");
        Serial.println(changedPins, HEX);
    });
    
    // Set normal operation display
    indicator.setOledMode(3);
    indicator.writePort("GreenLED", true); // Normal operation LED
    
    systemInitialized = true;
    Serial.println("Setup complete!");
    indicator.printConfiguration();
    LoggerManager::info("SYSTEM", 
        "TemperatureController started");
    return true;
}

void TemperatureController::update() {
    updateAllSensors();
    readAllPoints();
    
    // Handle PCF8575 interrupts
    indicator.handleInterrupt();
    
    // Update alarm system
    updateAlarms();
    
    // Handle button presses
    _checkButtonPress();
    
    // Handle alarm display and outputs
    handleAlarmDisplay();
    handleAlarmOutputs();
    
    // Update OLED
    indicator.update();
    
    if (!systemInitialized) return;


    unsigned long currentTime = millis();
    if (currentTime - lastMeasurementTime >= measurementPeriodSeconds * 1000) {
        
        updateRegisterMap();
        lastMeasurementTime = currentTime;
        //applyConfigFromRegisterMap();
    }
}

// Alarm Management Methods
void TemperatureController::updateAlarms() {
    unsigned long currentTime = millis();
    if (currentTime - _lastAlarmCheck < _alarmCheckInterval) {
        return;
    }
    _lastAlarmCheck = currentTime;
    
    Serial.println("=== Checking alarms with fresh sensor data ===");
    
    // Check all measurement points for NEW alarm conditions
    for (uint8_t i = 0; i < 50; ++i) {
        if (dsPoints[i].getBoundSensor() != nullptr) {
            Serial.printf("DS Point %d: Temp=%d, High=%d, Low=%d\n",
                         i, dsPoints[i].getCurrentTemp(),
                         dsPoints[i].getHighAlarmThreshold(),
                         dsPoints[i].getLowAlarmThreshold());
            //_checkPointForAlarms(&dsPoints[i]);
        }
    }
    
    for (uint8_t i = 0; i < 10; ++i) {
        if (ptPoints[i].getBoundSensor() != nullptr) {
            Serial.printf("PT Point %d: Temp=%d, High=%d, Low=%d\n",
                         i, ptPoints[i].getCurrentTemp(),
                         ptPoints[i].getHighAlarmThreshold(),
                         ptPoints[i].getLowAlarmThreshold());
            //_checkPointForAlarms(&ptPoints[i]);
        }
    }
    
    // Update existing configured alarms (do NOT remove resolved alarms)
    Serial.println("=== Updating existing alarms ===");
    for (auto alarm : _configuredAlarms) {
        if (alarm->isEnabled()) {
            alarm->updateCondition();
            // Do NOT check for resolved state or remove alarms here
        }
    }
    
    // Sort alarms by priority
    std::sort(_configuredAlarms.begin(), _configuredAlarms.end(), AlarmComparator());
    
    Serial.printf("Active alarms count: %d\n", getActiveAlarms().size());
    
    // Debug: Print all current alarms
    for (auto alarm : _configuredAlarms) {
        if (alarm->isEnabled()) {
            Serial.printf("  Alarm: %s, Stage: %s, Point: %d\n",
                         alarm->getTypeString().c_str(),
                         alarm->getStageString().c_str(),
                         alarm->getSource() ? alarm->getSource()->getAddress() : -1);
        }
    }
}




void TemperatureController::_checkPointForAlarms(MeasurementPoint* point) {
    if (!point || !point->getBoundSensor()) return;
    
    // Check for high temperature alarm
    if (point->getCurrentTemp() >= point->getHighAlarmThreshold()) {
        if (!_hasAlarmForPoint(point, AlarmType::HIGH_TEMPERATURE)) {
            createAlarm(AlarmType::HIGH_TEMPERATURE, point, AlarmPriority::PRIORITY_HIGH);
        }
    }
    
    // Check for low temperature alarm
    if (point->getCurrentTemp() <= point->getLowAlarmThreshold()) {
        if (!_hasAlarmForPoint(point, AlarmType::LOW_TEMPERATURE)) {
            createAlarm(AlarmType::LOW_TEMPERATURE, point, AlarmPriority::PRIORITY_MEDIUM);
        }
    }
    
    // Check for sensor error
    if (point->getErrorStatus() != 0) {
        if (!_hasAlarmForPoint(point, AlarmType::SENSOR_ERROR)) {
            createAlarm(AlarmType::SENSOR_ERROR, point, AlarmPriority::PRIORITY_HIGH);
        }
    }
}

bool TemperatureController::_hasAlarmForPoint(MeasurementPoint* point, AlarmType type) {
    for (auto alarm : _configuredAlarms) {
        if (alarm->getSource() == point && 
            alarm->getType() == type && 
            alarm->isEnabled() &&
            alarm->isActive()) {
            return true;
        }
    }
    return false;
}


void TemperatureController::createAlarm(AlarmType type, MeasurementPoint* source, AlarmPriority priority) {
    // Check if this alarm already exists in configured alarms
    String configKey = "alarm_" + String(source->getAddress()) + "_" + String(static_cast<int>(type));
    
    for (auto alarm : _configuredAlarms) {
        if (alarm->getConfigKey() == configKey) {
            // Alarm already exists, just enable it if it's disabled
            if (!alarm->isEnabled()) {
                alarm->setEnabled(true);
                alarm->setStage(AlarmStage::NEW); // Reset stage
            }
            return;
        }
    }
    
    // Create new alarm and add to configured alarms
    Alarm* newAlarm = new Alarm(type, source, priority);
    newAlarm->setConfigKey(configKey);
    _configuredAlarms.push_back(newAlarm);
    
    // Sort alarms by priority
    std::sort(_configuredAlarms.begin(), _configuredAlarms.end(), AlarmComparator());
}


Alarm* TemperatureController::getHighestPriorityAlarm() const {
    for (auto alarm : _configuredAlarms) {
        if (alarm->isEnabled() && alarm->isActive()) {
            return alarm;
        }
    }
    return nullptr;
}


void TemperatureController::acknowledgeHighestPriorityAlarm() {
    Alarm* alarm = getHighestPriorityAlarm();
    if (alarm) {
        alarm->acknowledge();
        Serial.printf("Alarm acknowledged: %s\n", alarm->getStatusText().c_str());
    }
}

void TemperatureController::acknowledgeAllAlarms() {
    for (auto alarm : _configuredAlarms) {
        if (alarm->isEnabled() && alarm->isActive() && !alarm->isAcknowledged()) {
            alarm->acknowledge();
        }
    }
}


std::vector<Alarm*> TemperatureController::getActiveAlarms() const {
    std::vector<Alarm*> activeAlarms;
    for (auto alarm : _configuredAlarms) {
        if (alarm->isEnabled() && alarm->isActive()) {
            activeAlarms.push_back(alarm);
        }
    }
    return activeAlarms;
}

void TemperatureController::clearResolvedAlarms() {
    for (auto it = _configuredAlarms.begin(); it != _configuredAlarms.end();) {
        if ((*it)->isResolved()) {
            if (_currentDisplayedAlarm == *it) {
                _currentDisplayedAlarm = nullptr;
            }
            Serial.printf("Manually clearing resolved alarm: %s\n", (*it)->getConfigKey().c_str());
            delete *it;
            it = _configuredAlarms.erase(it);
        } else {
            ++it;
        }
    }
}

void TemperatureController::clearConfiguredAlarms() {
    for (auto it = _configuredAlarms.begin(); it != _configuredAlarms.end();) {
            if (_currentDisplayedAlarm == *it) {
                _currentDisplayedAlarm = nullptr;
            }
            Serial.printf("Manually clearing resolved alarm: %s\n", (*it)->getConfigKey().c_str());
            delete *it;
            it = _configuredAlarms.erase(it);
    }
}



// void TemperatureController::handleAlarmDisplay() {
//     Alarm* highestPriorityAlarm = getHighestPriorityAlarm();
    
//     if (highestPriorityAlarm) {
//         // Display alarm
//         _currentDisplayedAlarm = highestPriorityAlarm;
//         _showingOK = false;
        
//         indicator.setOledMode(2);
//         String displayText = highestPriorityAlarm->getDisplayText();
        
//         // Split display text into lines
//         int newlineIndex = displayText.indexOf('\n');
//         String line1 = displayText.substring(0, newlineIndex);
//         String line2 = displayText.substring(newlineIndex + 1);
        
//         String displayLines[2] = {line1, line2};
//         indicator.printText(displayLines, 2);
        
//     } else if (_currentDisplayedAlarm && !_showingOK) {
//         // No more alarms, show OK for 1 minute
//         _showOKAndTurnOffOLED();
        
//     } else if (_showingOK) {
//         // Check if OK display time has elapsed
//         if (millis() - _okDisplayStartTime >= 60000) { // 1 minute
//             indicator.setOLEDOff();
//             _showingOK = false;
//             _currentDisplayedAlarm = nullptr;
//         }
        
//     } else {
//         // Normal operation - show normal display
//         _updateNormalDisplay();
//     }
// }

// void TemperatureController::handleAlarmOutputs() {
//     Alarm* highestPriorityAlarm = getHighestPriorityAlarm();
    
//     if (highestPriorityAlarm) {
//         // Handle alarm outputs based on type and stage
//         if (highestPriorityAlarm->getType() == AlarmType::HIGH_TEMPERATURE) {
//             // High temperature alarm
//             indicator.writePort("RedLED", true);
//             indicator.writePort("GreenLED", false);
            
//             if (!highestPriorityAlarm->isAcknowledged()) {
//                 indicator.writePort("Relay1", true);
//             } else {
//                 indicator.writePort("Relay1", false);
//             }
//             indicator.writePort("Relay2", true);
//         }
//         // Add other alarm type handling here
        
//     } else {
//         // No active alarms - normal operation
//         indicator.writePort("GreenLED", true);
//         indicator.writePort("RedLED", false);
//         indicator.writePort("Relay1", false);
//         indicator.writePort("Relay2", false);
//     }
// }
void TemperatureController::handleAlarmOutputs() {
    // Calculate alarm counts for logging
    int activeAlarms = getAlarmCount(AlarmStage::ACTIVE);
    int highPriorityAlarms = getAlarmCount(AlarmPriority::PRIORITY_HIGH, AlarmStage::ACKNOWLEDGED, ">=", ">=");
    int lowPriorityAlarms = getAlarmCount(AlarmPriority::PRIORITY_LOW, AlarmStage::ACKNOWLEDGED, "==", ">=");
    int criticalAlarms = getAlarmCount(AlarmPriority::PRIORITY_CRITICAL, AlarmStage::ACKNOWLEDGED, "==", ">=");
    int mediumAlarms = getAlarmCount(AlarmPriority::PRIORITY_MEDIUM, AlarmStage::ACKNOWLEDGED, "==", ">=");
    
    // Calculate new output states using enhanced getAlarmCount methods
    bool newRelay1 = activeAlarms > 0;
    bool highPriorityRelay2 = highPriorityAlarms > 0;
    bool lowPriorityExists = lowPriorityAlarms > 0;
    bool newRedLed = criticalAlarms > 0;
    bool newYellowLed = getAlarmCount(AlarmPriority::PRIORITY_HIGH, AlarmStage::ACKNOWLEDGED, "==", ">=") > 0;
    bool mediumPriorityBlueLed = mediumAlarms > 0;
    
    // Log alarm summary if there are any changes or active alarms
    static unsigned long lastSummaryLog = 0;
    unsigned long now = millis();
    if (now - lastSummaryLog > 30000 || // Log every 30 seconds
        (activeAlarms > 0 && now - lastSummaryLog > 5000)) { // Or every 5 seconds if alarms active
        
        String summary = "Alarm summary - Active: " + String(activeAlarms) + 
                        ", High: " + String(highPriorityAlarms) + 
                        ", Medium: " + String(mediumAlarms) + 
                        ", Low: " + String(lowPriorityAlarms) + 
                        ", Critical: " + String(criticalAlarms);
        LoggerManager::info("ALARM_OUTPUT", summary);
        lastSummaryLog = now;
    }
    
    // Handle blinking for low priority alarms
    if (lowPriorityExists) {
        // Start blinking if not already blinking
        if (!highPriorityRelay2 && !indicator.isBlinking("Relay2")) {
            LoggerManager::info("INDICATION", 
                "Starting Relay2 blinking for " + String(lowPriorityAlarms) + " low priority alarms");
            indicator.startBlinking("Relay2", 1000, 5000);  // 2s on, 30s off
        }
        
        if (!indicator.isBlinking("BlueLED")) {
            LoggerManager::info("INDICATION", 
                "Starting BlueLED blinking for " + String(lowPriorityAlarms) + " low priority alarms");
            indicator.startBlinking("BlueLED", 500, 500);    // 500ms on, 500ms off
        }
    } else {
        // Stop blinking if no low priority alarms
        if (indicator.isBlinking("Relay2")) {
            LoggerManager::info("INDICATION", "Stopping Relay2 blinking - no low priority alarms");
            indicator.stopBlinking("Relay2");
        }
        if (indicator.isBlinking("BlueLED")) {
            LoggerManager::info("INDICATION", "Stopping BlueLED blinking - no low priority alarms");
            indicator.stopBlinking("BlueLED");
        }
    }
    
    // Calculate final states (excluding blinking ports)
    bool newRelay2 = highPriorityRelay2;  // Don't set if blinking
    bool newBlueLed = mediumPriorityBlueLed;  // Don't set if blinking
    
    // Only update non-blinking outputs if state has changed
    if (newRelay1 != _relay1State) {
        String reason = newRelay1 ? 
            ("Activated - " + String(activeAlarms) + " active alarms") : 
            "Deactivated - no active alarms";
        LoggerManager::info("INDICATION", "Relay1 " + reason);
        
        indicator.writePort("Relay1", newRelay1);
        _relay1State = newRelay1;
    }
    
    // Only control Relay2 directly if not blinking for low priority
    if (!indicator.isBlinking("Relay2") && newRelay2 != _relay2State) {
        String reason = newRelay2 ? 
            ("Activated - " + String(highPriorityAlarms) + " high/critical priority alarms") : 
            "Deactivated - no high/critical priority alarms";
        LoggerManager::info("INDICATION", "Relay2 " + reason);
        
        indicator.writePort("Relay2", newRelay2);
        _relay2State = newRelay2;
    }
    
    if (newRedLed != _redLedState) {
        String reason = newRedLed ? 
            ("ON - " + String(criticalAlarms) + " critical alarms") : 
            "OFF - no critical alarms";
        LoggerManager::info("INDICATION", "RedLED " + reason);
        
        indicator.writePort("RedLED", newRedLed);
        _redLedState = newRedLed;
    }
    
    if (newYellowLed != _yellowLedState) {
        String reason = newYellowLed ? 
            ("ON - high priority alarms present") : 
            "OFF - no high priority alarms";
        LoggerManager::info("INDICATION", "YellowLED " + reason);
        
        indicator.writePort("YellowLED", newYellowLed);
        _yellowLedState = newYellowLed;
    }
    
    // Only control BlueLED directly if not blinking for low priority
    if (!indicator.isBlinking("BlueLED") && newBlueLed != _blueLedState) {
        String reason = newBlueLed ? 
            ("ON - " + String(mediumAlarms) + " medium priority alarms") : 
            "OFF - no medium priority alarms";
        LoggerManager::info("INDICATION", "BlueLED " + reason);
        
        indicator.writePort("BlueLED", newBlueLed);
        _blueLedState = newBlueLed;
    }
}


// void TemperatureController::handleAlarmOutputs() {
//     // Calculate new output states using enhanced getAlarmCount methods
//     bool newRelay1 = getAlarmCount(AlarmStage::ACTIVE) > 0;
    
//     // HIGH or CRITICAL priority alarms in ACKNOWLEDGED or ACTIVE states
//     bool highPriorityRelay2 = getAlarmCount(AlarmPriority::PRIORITY_HIGH, AlarmStage::ACKNOWLEDGED, ">=", ">=") > 0;
    
//     // LOW priority alarms in ACKNOWLEDGED or ACTIVE states (for blinking)
//     bool lowPriorityExists = getAlarmCount(AlarmPriority::PRIORITY_LOW, AlarmStage::ACKNOWLEDGED, "==", ">=") > 0;
    
//     // CRITICAL priority alarms in ACKNOWLEDGED or ACTIVE states  
//     bool newRedLed = getAlarmCount(AlarmPriority::PRIORITY_CRITICAL, AlarmStage::ACKNOWLEDGED, "==", ">=") > 0;
    
//     // HIGH priority alarms in ACKNOWLEDGED or ACTIVE states
//     bool newYellowLed = getAlarmCount(AlarmPriority::PRIORITY_HIGH, AlarmStage::ACKNOWLEDGED, "==", ">=") > 0;
    
//     // MEDIUM priority alarms in ACKNOWLEDGED or ACTIVE states
//     bool mediumPriorityBlueLed = getAlarmCount(AlarmPriority::PRIORITY_MEDIUM, AlarmStage::ACKNOWLEDGED, "==", ">=") > 0;
    
//     // Handle blinking for low priority alarms
//     if (lowPriorityExists) {
//         // Start blinking if not already blinking
//         if (!highPriorityRelay2 && !indicator.isBlinking("Relay2")) {
//             indicator.startBlinking("Relay2", 1000, 5000);  // 2s on, 30s off
            

//         }
        
//         if (!indicator.isBlinking("BlueLED")) {
//             indicator.startBlinking("BlueLED", 500, 500);    // 500ms on, 500ms off
//         }
//     } else {
//         // Stop blinking if no low priority alarms
//         indicator.stopBlinking("Relay2");
//         indicator.stopBlinking("BlueLED");
//     }
    
//     // Calculate final states (excluding blinking ports)
//     bool newRelay2 = highPriorityRelay2;  // Don't set if blinking
//     bool newBlueLed = mediumPriorityBlueLed;  // Don't set if blinking
    
//     // Only update non-blinking outputs if state has changed
//     if (newRelay1 != _relay1State) {
//         indicator.writePort("Relay1", newRelay1);
//         _relay1State = newRelay1;
//     }
    
//     // Only control Relay2 directly if not blinking for low priority
//     if (!indicator.isBlinking("Relay2") && newRelay2 != _relay2State) {
//         indicator.writePort("Relay2", newRelay2);
//         _relay2State = newRelay2;
//     }
    
//     if (newRedLed != _redLedState) {
//         indicator.writePort("RedLED", newRedLed);
//         _redLedState = newRedLed;
//     }
    
//     if (newYellowLed != _yellowLedState) {
//         indicator.writePort("YellowLED", newYellowLed);
//         _yellowLedState = newYellowLed;
//     }
    
//     // Only control BlueLED directly if not blinking for low priority
//     if (!indicator.isBlinking("BlueLED") && newBlueLed != _blueLedState) {
//         indicator.writePort("BlueLED", newBlueLed);
//         _blueLedState = newBlueLed;
//     }
// }




// void TemperatureController::_checkButtonPress() {
//     bool currentButtonState = indicator.readPort("BUTTON");
    
//     // Detect button press (HIGH to LOW transition)
//     if (_lastButtonState == true && currentButtonState == false) {
//         if ((millis() - _lastButtonPressTime) > _buttonDebounceDelay) {
//             Serial.println("BUTTON PRESS DETECTED!");
//             acknowledgeHighestPriorityAlarm();
//             _lastButtonPressTime = millis();
//         }
//     }
    
//     _lastButtonState = currentButtonState;
// }

void TemperatureController::_updateNormalDisplay() {
    // Show normal system status
    indicator.setOledMode(3);
    String lines[3] = {
        "System Normal",
        "Temp Monitor",
        "Ready"
    };
    indicator.printText(lines, 3);
}

void TemperatureController::_showOKAndTurnOffOLED() {
    indicator.displayOK();
    _okDisplayStartTime = millis();
    _showingOK = true;
}

String TemperatureController::getAlarmsJson() {
    DynamicJsonDocument doc(4096);
    JsonArray alarmArray = doc.createNestedArray("alarms");
    
    for (auto alarm : _configuredAlarms) {
        JsonObject obj = alarmArray.createNestedObject();
        obj["configKey"] = alarm->getConfigKey();
        obj["type"] = static_cast<int>(alarm->getType());
        obj["priority"] = static_cast<int>(alarm->getPriority());
        obj["enabled"] = alarm->isEnabled();
        obj["pointAddress"] = alarm->getPointAddress();
        obj["stage"] = static_cast<int>(alarm->getStage());
        obj["isActive"] = alarm->isActive();
        obj["isAcknowledged"] = alarm->isAcknowledged();
        obj["timestamp"] = alarm->getTimestamp();
        obj["acknowledgedTime"] = alarm->getAcknowledgedTime();
        obj["acknowledgedTimeLeft"] = alarm->getAcknowledgedTimeLeft();
        
        if (alarm->getSource()) {
            obj["pointName"] = alarm->getSource()->getName();
            obj["currentTemp"] = alarm->getSource()->getCurrentTemp();
            obj["threshold"] = (alarm->getType() == AlarmType::HIGH_TEMPERATURE)
                ? alarm->getSource()->getHighAlarmThreshold()
                : alarm->getSource()->getLowAlarmThreshold();
        }
    }
    
    String output;
    serializeJson(doc, output);
    return output;
}


// void TemperatureController::update() {
//     updateAllSensors();
    
//     // Add this line - handle PCF8575 interrupts
//     indicator.handleInterrupt();
    
//     // Handle alarm logic
    
    
//     // Update OLED
//     indicator.updateOLED();
    
//     if (!systemInitialized) return;
    
//     unsigned long currentTime = millis();
//     if (currentTime - lastMeasurementTime >= measurementPeriodSeconds) {
//         readAllPoints();
//         updateRegisterMap();
//         lastMeasurementTime = currentTime;
//         applyConfigFromRegisterMap();
//     }
// }



MeasurementPoint* TemperatureController::getMeasurementPoint(uint8_t address) {
    if (isDS18B20Address(address))
        return &dsPoints[address];
    if (isPT1000Address(address))
        return &ptPoints[address - 50];
    return nullptr;
}

MeasurementPoint* TemperatureController::getDS18B20Point(uint8_t idx) {
    return (idx < 50) ? &dsPoints[idx] : nullptr;
}

MeasurementPoint* TemperatureController::getPT1000Point(uint8_t idx) {
    return (idx < 10) ? &ptPoints[idx] : nullptr;
}

bool TemperatureController::addSensor(Sensor* sensor) {
    if (!sensor) return false;
    // For DS18B20, check by ROM string
    if (sensor->getType() == SensorType::DS18B20) {
        String romStr = sensor->getDS18B20RomString();
        if (findSensorByRom(romStr)) return false;
    } else if (sensor->getType() == SensorType::PT1000) {
        if (findSensorByChipSelect(sensor->getPT1000ChipSelectPin())) return false;
    }
    sensors.push_back(sensor);
    if (sensor->getType() == SensorType::DS18B20)
        registerMap.incrementActiveDS18B20();
    else
        registerMap.incrementActivePT1000();
    return true;
}

bool TemperatureController::removeSensorByRom(const String& romString) {
    for (auto it = sensors.begin(); it != sensors.end(); ++it) {
        if ((*it)->getType() == SensorType::DS18B20 &&
            (*it)->getDS18B20RomString() == romString) {
            // Unbind from any point
            for (uint8_t i = 0; i < 50; ++i) {
                if (dsPoints[i].getBoundSensor() == *it)
                    dsPoints[i].unbindSensor();
            }
            registerMap.decrementActiveDS18B20();
            delete *it;
            sensors.erase(it);
            return true;
        }
    }
    return false;
}

Sensor* TemperatureController::findSensorByRom(const String& romString) {
    for (auto s : sensors) {
            Serial.println("Sensor ROM" + s->getDS18B20RomString());
        if (s->getType() == SensorType::DS18B20 &&
            s->getDS18B20RomString() == romString)
            return s;
    }
    return nullptr;
}

Sensor* TemperatureController::findSensorByChipSelect(uint8_t csPin) {
    for (auto s : sensors)
        if (s->getType() == SensorType::PT1000 &&
            s->getPT1000ChipSelectPin() == csPin)
            return s;
    return nullptr;
}

Sensor* TemperatureController::getSensorByIndex(int idx) {
    return (idx >= 0 && idx < sensors.size()) ? sensors[idx] : nullptr;
}

bool TemperatureController::bindSensorToPointByRom(const String& romString, uint8_t pointAddress) {
    if(pointAddress > 49) return false;
    Sensor* sensor = findSensorByRom(romString);
    unbindSensorFromPointBySensor(sensor);
    MeasurementPoint* point = getMeasurementPoint(pointAddress);
    if (!sensor || !point){
        LoggerManager::warning("BINDING", 
            "Failed to bind sensor " + romString + " to point " + String(pointAddress));
        
        return false;} 

        point->bindSensor(sensor);
    


        String pointName = point->getName().isEmpty() ? 
            "Point_" + String(pointAddress) : point->getName();
        LoggerManager::info("BINDING", 
            "Sensor " + romString + " bound to point " + String(pointAddress) + 
            " (" + pointName + ")");




    return true;
}

bool TemperatureController::bindSensorToPointByChipSelect(uint8_t csPin, uint8_t pointAddress) {
    Serial.printf("Point address: %d\n", pointAddress);
    if((pointAddress < 50) || (pointAddress > 59)) 
        return false;
    Serial.printf("Point address: %d PASSED!\n", pointAddress);
    Sensor* sensor = findSensorByChipSelect(csPin);
    unbindSensorFromPointBySensor(sensor);
    MeasurementPoint* point = getMeasurementPoint(pointAddress);
    if (!sensor || !point) {
        
        LoggerManager::warning("BINDING", 
            "Failed to bind PT1000 sensor CS" + String(csPin) + 
            " to point " + String(pointAddress));
        return false;}
    point->bindSensor(sensor);
    String pointName = point->getName().isEmpty() ? 
            "Point_" + String(pointAddress) : point->getName();
        LoggerManager::info("BINDING", 
            "PT1000 sensor CS" + String(csPin) + " bound to point " + 
            String(pointAddress) + " (" + pointName + ")");
    return true;
}

bool TemperatureController::unbindSensorFromPoint(uint8_t pointAddress) {
    MeasurementPoint* point = getMeasurementPoint(pointAddress);
    if (!point) {
        LoggerManager::error("BINDING", 
            "Faild to unbound sensor from point " + String(pointAddress) + 
            " (" + point->getName() + ")");
        return false;
    }

    if (point->getBoundSensor()) {
        String sensorInfo = point->getBoundSensor()->getType() == SensorType::DS18B20 ? 
        point->getBoundSensor()->getDS18B20RomString() : 
            "CS" + String(point->getBoundSensor()->getPT1000ChipSelectPin());
        
        LoggerManager::info("BINDING", 
            "Sensor " + sensorInfo + " unbound from point " + String(pointAddress) + 
            " (" + point->getName() + ")");
    }

    point->unbindSensor();
    return true;
}

Sensor* TemperatureController::getBoundSensor(uint8_t pointAddress) {
    MeasurementPoint* point = getMeasurementPoint(pointAddress);
    return point ? point->getBoundSensor() : nullptr;
}

void TemperatureController::readAllPoints() {
    for (uint8_t i = 0; i < 50; ++i)
        dsPoints[i].update();
    for (uint8_t i = 0; i < 10; ++i)
        ptPoints[i].update();
}

void TemperatureController::updateRegisterMap() {
    for (uint8_t i = 0; i < 50; ++i)
        registerMap.updateFromMeasurementPoint(dsPoints[i]);
    for (uint8_t i = 0; i < 10; ++i)
        registerMap.updateFromMeasurementPoint(ptPoints[i]);
}

void TemperatureController::applyConfigFromRegisterMap() {
    for (uint8_t i = 0; i < 50; ++i)
        registerMap.applyConfigToMeasurementPoint(dsPoints[i]);
    for (uint8_t i = 0; i < 10; ++i)
        registerMap.applyConfigToMeasurementPoint(ptPoints[i]);
}

void TemperatureController::applyConfigToRegisterMap() {
    for (uint8_t i = 0; i < 50; ++i)
        registerMap.applyConfigFromMeasurementPoint(dsPoints[i]);
    for (uint8_t i = 0; i < 10; ++i)
        registerMap.applyConfigFromMeasurementPoint(ptPoints[i]);
}

bool TemperatureController::discoverDS18B20Sensors() {
    bool anyAdded = false;
    Serial.println("Discover method started...");
    LoggerManager::info("DISCOVERY", "Starting DS18B20 sensor discovery");
    uint totalFound = 0;
    // OneWire oneWire[] = { OneWire(oneWireBusPin[0]), OneWire(oneWireBusPin[1]), OneWire(oneWireBusPin[2]), OneWire(oneWireBusPin[3]) };
    // DallasTemperature dallasSensors[] = {DallasTemperature(&oneWire[0]), DallasTemperature(&oneWire[1]), DallasTemperature(&oneWire[2]), DallasTemperature(&oneWire[3])};
    for (uint j = 0; j < 4; j++){
        Serial.printf("Discover bus %d pin %d started...\n", j, oneWireBusPin[j]);
        
    //OneWire oneWire(oneWireBusPin[j]);
    
    dallasSensors[j]->begin();

    int deviceCount = dallasSensors[j]->getDeviceCount();
    Serial.printf("Devices on bus %d: %d\n", j, deviceCount);
    if (deviceCount == 0) continue;
    totalFound += deviceCount;

    DeviceAddress sensorAddress;
    if (deviceCount > 0) {
        LoggerManager::info("DISCOVERY", 
            "Found " + String(deviceCount) + " DS18B20 sensors on bus " + String(j));
        }
    

    for (int i = 0; i < deviceCount; i++) {
        if (dallasSensors[j]->getAddress(sensorAddress, i)) {
            Serial.printf("Bus %d. Device %d of %d\n", j, i, deviceCount);
            // Convert ROM to string for uniqueness
            char buf[17];
            for (int u = 0; u < 8; ++u) sprintf(buf + u*2, "%02X", sensorAddress[u]);
            String romString(buf);
            Serial.printf("ROM: %s\n", romString);

            // Check if already exists
            if (findSensorByRom(romString)){
                if(getSensorBus(findSensorByRom(romString)) != j) {
                    removeSensorByRom(romString);
                    Serial.println("Device existed on enother bus. Deleting");
                    //continue;

                } else continue;

            }
             

            String sensorName = "DS18B20_" + romString;
            Sensor* newSensor = new Sensor(SensorType::DS18B20, 0, sensorName); // address field not used for DS
            Serial.printf("Sensor created with name %s on bus %d\n", newSensor->getName(), getSensorBus(newSensor));

            newSensor->setupDS18B20(oneWireBusPin[j], sensorAddress);
            Serial.printf("Sensor %s set on bus %d/ pin %d\n", newSensor->getName(), getSensorBus(newSensor), newSensor->getOneWirePin());

            if (newSensor->initialize()) {
                sensors.push_back(newSensor);
                registerMap.incrementActiveDS18B20();
                anyAdded = true;
                Serial.printf("Sensor %s set on bus %d/ pin %d status: Connected\n", newSensor->getName(), getSensorBus(newSensor), newSensor->getOneWirePin());
                

            } else {
                delete newSensor;
            }
        }
    }
    }

    LoggerManager::info("DISCOVERY", 
        "DS18B20 discovery completed. Total sensors: " + String(totalFound));

    return anyAdded;
}


bool TemperatureController::discoverPTSensors() {
    bool anyAdded = false;
    Serial.println("Discover PT method started...");
    LoggerManager::info("DISCOVERY", "Starting PT1000 sensor discovery");
    for (uint j = 0; j < 4; j++){
        Serial.printf("Bus: %d: PIN: %d", j, chipSelectPin[j]);
    }
    // OneWire oneWire[] = { OneWire(oneWireBusPin[0]), OneWire(oneWireBusPin[1]), OneWire(oneWireBusPin[2]), OneWire(oneWireBusPin[3]) };
    // DallasTemperature dallasSensors[] = {DallasTemperature(&oneWire[0]), DallasTemperature(&oneWire[1]), DallasTemperature(&oneWire[2]), DallasTemperature(&oneWire[3])};
    for (uint j = 0; j < 4; j++){
        Serial.printf("Discover PT: bus %d pin %d started...\n", j, chipSelectPin[j]);
        

        if(findSensorByChipSelect(chipSelectPin[j]) != nullptr){
            Serial.printf("Sensor already discovered on bus %d\n", j);
            continue;

        }
  
        
             

            String sensorName = "PT1000_" + String(j);
            Sensor* newSensor = new Sensor(SensorType::PT1000, j, sensorName); // address field not used for DS
            Serial.printf("Sensor created with name %s on bus %d\n", newSensor->getName(), getSensorBus(newSensor));

            newSensor->setupPT1000(chipSelectPin[j], j);
            Serial.printf("Sensor %s set on bus %d/ pin %d\n", newSensor->getName(), getSensorBus(newSensor), newSensor->getPT1000ChipSelectPin());
            

            if (newSensor->initialize()) {

                


                sensors.push_back(newSensor);
                registerMap.incrementActivePT1000();
                anyAdded = true;
                Serial.printf("Sensor %s set on bus %d/ pin %d status: Connected\n", newSensor->getName(), getSensorBus(newSensor), newSensor->getPT1000ChipSelectPin());
                LoggerManager::info("DISCOVERY", 
                    "Added PT1000 sensor on bus: " + String(getSensorBus(newSensor)) + ", CS pin: " + String(newSensor->getPT1000ChipSelectPin()));

            } else {
                delete newSensor;
            }
        
    
        }
    return anyAdded;
}


String TemperatureController::getSensorsJson() {
    DynamicJsonDocument doc(8192);
    JsonArray sensorArray = doc.createNestedArray("sensors");

    for (auto sensor : sensors) {
        JsonObject obj = sensorArray.createNestedObject();
        obj["type"] = (sensor->getType() == SensorType::DS18B20) ? "DS18B20" : "PT1000";
        obj["name"] = sensor->getName();
        obj["currentTemp"] = sensor->getCurrentTemp();
        obj["minTemp"] = sensor->getMinTemp();
        obj["maxTemp"] = sensor->getMaxTemp();
        obj["lowAlarmThreshold"] = sensor->getLowAlarmThreshold();
        obj["highAlarmThreshold"] = sensor->getHighAlarmThreshold();
        obj["alarmStatus"] = sensor->getAlarmStatus();
        obj["errorStatus"] = sensor->getErrorStatus();
        obj["bus"] = getSensorBus(sensor);

        if (sensor->getType() == SensorType::DS18B20) {
            obj["romString"] = sensor->getDS18B20RomString();
            JsonArray romArr = obj.createNestedArray("romArray");
            uint8_t rom[8];
            sensor->getDS18B20RomArray(rom);
            for (int j = 0; j < 8; ++j) romArr.add(rom[j]);
            
        } else if (sensor->getType() == SensorType::PT1000) {
            obj["chipSelectPin"] = sensor->getPT1000ChipSelectPin();
        }

        // Binding info
        int boundPoint = -1;
        if (sensor->getType() == SensorType::DS18B20) {
            String romString = sensor->getDS18B20RomString();
            for (uint8_t i = 0; i < 50; ++i) {
                Sensor* bound = dsPoints[i].getBoundSensor();
                if (bound && bound->getType() == SensorType::DS18B20 &&
                    bound->getDS18B20RomString() == romString) {
                    boundPoint = dsPoints[i].getAddress();
                    break;
                }
            }
        } else if (sensor->getType() == SensorType::PT1000) {
            for (uint8_t i = 0; i < 10; ++i) {
                Sensor* bound = ptPoints[i].getBoundSensor();
                if (bound && bound == sensor) {
                    boundPoint = ptPoints[i].getAddress();
                    break;
                }
            }
        }
        if (boundPoint >= 0) obj["boundPoint"] = boundPoint;
        else obj["boundPoint"] = nullptr;
    }

    String out;
    serializeJson(doc, out);
    return out;
}

String TemperatureController::getPointsJson() {
    DynamicJsonDocument doc(8192);
    JsonArray pointsArray = doc.createNestedArray("points");

    // DS18B20 points
    for (uint8_t i = 0; i < 50; ++i) { //Should be 50 instad of 2 here
        MeasurementPoint& point = dsPoints[i];
        JsonObject obj = pointsArray.createNestedObject();
        obj["address"] = point.getAddress();
        obj["name"] = point.getName();
        obj["type"] = "DS18B20";
        obj["currentTemp"] = point.getCurrentTemp();
        obj["minTemp"] = point.getMinTemp();
        obj["maxTemp"] = point.getMaxTemp();
        obj["lowAlarmThreshold"] = point.getLowAlarmThreshold();
        obj["highAlarmThreshold"] = point.getHighAlarmThreshold();
        obj["alarmStatus"] = point.getAlarmStatus();
        obj["errorStatus"] = point.getErrorStatus();
        

        Sensor* bound = point.getBoundSensor();
        if (bound && bound->getType() == SensorType::DS18B20) {
            obj["sensorType"] = "DS18B20";
            obj["sensorRomString"] = bound->getDS18B20RomString();
            JsonArray romArr = obj.createNestedArray("sensorRomArray");
            uint8_t rom[8];
            bound->getDS18B20RomArray(rom);
            for (int j = 0; j < 8; ++j) romArr.add(rom[j]);
            obj["bus"] = getSensorBus(bound);
            
        }
    }

    // PT1000 points
    for (uint8_t i = 0; i < 10; ++i) { //should be 10 instaed of 1
        MeasurementPoint& point = ptPoints[i];
        JsonObject obj = pointsArray.createNestedObject();
        obj["address"] = point.getAddress();
        obj["name"] = point.getName();
        obj["type"] = "PT1000";
        obj["currentTemp"] = point.getCurrentTemp();
        obj["minTemp"] = point.getMinTemp();
        obj["maxTemp"] = point.getMaxTemp();
        obj["lowAlarmThreshold"] = point.getLowAlarmThreshold();
        obj["highAlarmThreshold"] = point.getHighAlarmThreshold();
        obj["alarmStatus"] = point.getAlarmStatus();
        obj["errorStatus"] = point.getErrorStatus();

        Sensor* bound = point.getBoundSensor();
        if (bound && bound->getType() == SensorType::PT1000) {
            obj["sensorType"] = "PT1000";
            obj["chipSelectPin"] = bound->getPT1000ChipSelectPin();
            obj["bus"] = getSensorBus(bound);
        }
    }

    String out;
    serializeJson(doc, out);
    return out;
}

String TemperatureController::getSystemStatusJson() {
    DynamicJsonDocument doc(1024);
    doc["deviceId"] = deviceId;
    doc["firmwareVersion"] = firmwareVersion;
    doc["ds18b20Count"] = getDS18B20Count();
    doc["pt1000Count"] = getPT1000Count();
    doc["measurementPeriod"] = measurementPeriodSeconds;
    doc["uptime"] = millis() / 1000;

    JsonArray statusArray = doc.createNestedArray("deviceStatus");
    for (int i = 4; i <= 10; i++) {
        statusArray.add(registerMap.readHoldingRegister(i));
    }

    String jsonString;
    serializeJson(doc, jsonString);
    return jsonString;
}

void TemperatureController::resetMinMaxValues() {
    LoggerManager::info("SYSTEM", "Min/Max temperature values reset");
    for (uint8_t i = 0; i < 50; ++i)
        dsPoints[i].resetMinMaxTemp();
    for (uint8_t i = 0; i < 10; ++i)
        ptPoints[i].resetMinMaxTemp();
}

void TemperatureController::setDeviceId(uint16_t id) {
    uint16_t oldId = deviceId;
    deviceId = id;
    registerMap.writeHoldingRegister(0, deviceId);
    LoggerManager::info("CONFIG", 
        "Device ID changed from " + String(oldId) + " to " + String(deviceId));
}

uint16_t TemperatureController::getDeviceId() const { return deviceId; }

void TemperatureController::setFirmwareVersion(uint16_t version) {
    firmwareVersion = version;
    registerMap.writeHoldingRegister(1, firmwareVersion);
}

uint16_t TemperatureController::getFirmwareVersion() const { return firmwareVersion; }

void TemperatureController::setMeasurementPeriod(uint16_t seconds) {
    measurementPeriodSeconds = seconds;
    if (measurementPeriodSeconds != seconds) {
        uint16_t oldPeriod = measurementPeriodSeconds;
        measurementPeriodSeconds = seconds;
        LoggerManager::info("CONFIG", 
            "Measurement period changed from " + String(oldPeriod) + 
            "s to " + String(measurementPeriodSeconds) + "s");
    }
}

uint16_t TemperatureController::getMeasurementPeriod() const {
    return measurementPeriodSeconds;
}

void TemperatureController::setOneWireBusPin(uint8_t pin, size_t bus) {
    oneWireBusPin[bus] = pin;
}

int TemperatureController::getDS18B20Count() const {
    int count = 0;
    for (auto sensor : sensors) {
        if (sensor->getType() == SensorType::DS18B20) {
            count++;
        }
    }
    return count;
}

int TemperatureController::getPT1000Count() const {
    int count = 0;
    for (auto sensor : sensors) {
        if (sensor->getType() == SensorType::PT1000) {
            count++;
        }
    }
    return count;
}

void TemperatureController::updateAllSensors() {
    for (auto sensor : sensors) {
        sensor->readTemperature();
    }

    for (auto& sensor : sensors) {
        if (sensor->getErrorStatus() != 0) {
            static std::map<Sensor*, unsigned long> lastErrorLog;
            unsigned long now = millis();
            
            // Only log errors every 5 minutes to avoid spam
            if (lastErrorLog[sensor] == 0 || (now - lastErrorLog[sensor]) > 300000) {
                String sensorId = sensor->getType() == SensorType::DS18B20 ? 
                    sensor->getDS18B20RomString() : 
                    "BUS " + String(getSensorBus(sensor));
                
                LoggerManager::error("SENSOR", 
                    "Sensor error detected: " + sensorId + 
                    " (Error code: " + String(sensor->getErrorStatus()) + ")");
                
                lastErrorLog[sensor] = now;
            }
        }
    }
}

uint8_t TemperatureController::getOneWirePin(size_t bus) {
    return oneWireBusPin[bus];
}

int TemperatureController::getSensorBus(Sensor* sensor) {
    if (sensor->getType() == SensorType::DS18B20){
        uint8_t pin = sensor->getOneWirePin();
        for (int i = 0; i < 4; i++) {
            if (oneWireBusPin[i] == pin) return i;
        } 
    } else if(sensor->getType() == SensorType::PT1000) {
        uint8_t pin = sensor->getPT1000ChipSelectPin();
        for (int i = 0; i < 4; i++) {
            if (chipSelectPin[i] == pin) return i;
        } 
    }

        return -1;

    
}



bool TemperatureController::unbindSensorFromPointBySensor(Sensor* sensor) {
    if (!sensor) return false;
    
    bool anyUnbound = false;
    
    // Search through all DS18B20 points
    for (auto& point : dsPoints) {
        if (point.getBoundSensor() == sensor) {
            point.unbindSensor();
            Serial.printf("Unbound sensor %s from DS18B20 point %d\n", 
                         sensor->getName().c_str(), point.getAddress());
            anyUnbound = true;
        }
    }
    
    // Search through all PT1000 points
    for (auto& point : ptPoints) {
        if (point.getBoundSensor() == sensor) {
            point.unbindSensor();
            Serial.printf("Unbound sensor %s from PT1000 point %d\n", 
                         sensor->getName().c_str(), point.getAddress());
            anyUnbound = true;
        }
    }
    
    return anyUnbound;
}



bool TemperatureController::addAlarm(AlarmType type, uint8_t pointAddress, AlarmPriority priority) {
    MeasurementPoint* point = getMeasurementPoint(pointAddress);
    if (!point) return false;
    
    // Check if alarm already exists
    String configKey = "alarm_" + String(pointAddress) + "_" + String(static_cast<int>(type));
    
    for (auto alarm : _configuredAlarms) {
        if (alarm->getConfigKey() == configKey) {
            // Update existing
            alarm->setPriority(priority);
            alarm->setEnabled(true);
            return true;
        }
    }
    
    // Create new alarm
    Alarm* newAlarm = new Alarm(type, point, priority);
    if (newAlarm) {
        unsigned long delay;
        switch (priority) {
            case AlarmPriority::PRIORITY_CRITICAL:
                delay = _acknowledgedDelayCritical;
                break;
            case AlarmPriority::PRIORITY_HIGH:
                delay = _acknowledgedDelayHigh;
                break;
            case AlarmPriority::PRIORITY_MEDIUM:
                delay = _acknowledgedDelayMedium;
                break;
            case AlarmPriority::PRIORITY_LOW:
                delay = _acknowledgedDelayLow;
                break;
            default:
                delay = _acknowledgedDelayMedium;
                break;
        }
        newAlarm->setAcknowledgedDelay(delay);
    }
    newAlarm->setConfigKey(configKey);
    _configuredAlarms.push_back(newAlarm);
    
    Serial.printf("Added alarm configuration: %s\n", configKey.c_str());
    if (newAlarm) {
        MeasurementPoint* point = getMeasurementPoint(pointAddress);
        String pointName = point ? point->getName() : "Unknown";
        LoggerManager::info("ALARM_CONFIG", 
            "Added " + newAlarm->getTypeString() + " alarm for point " + 
            String(pointAddress) + " (" + pointName + ") with priority " + 
            _getPriorityString(priority));
    } else {
        LoggerManager::warning("ALARM_CONFIG", 
            "Failed to add " + newAlarm->getTypeString() + " alarm for point " + 
            String(pointAddress));
    }
    return true;
}

bool TemperatureController::removeAlarm(const String& configKey) {
    for (auto it = _configuredAlarms.begin(); it != _configuredAlarms.end(); ++it) {
        if ((*it)->getConfigKey() == configKey) {
            
            delete *it;
            _configuredAlarms.erase(it);
            Serial.printf("Removed alarm configuration: %s\n", configKey.c_str());
            LoggerManager::info("ALARM_CONFIG", 
                "Removed alarm configuration: " + String(configKey.c_str()));
            return true;
        }
    }
    return false;
}

bool TemperatureController::updateAlarm(const String& configKey, AlarmPriority priority, bool enabled) {
    Alarm* alarm = findAlarm(configKey);
    if (!alarm) return false;
    
    alarm->setPriority(priority);
    alarm->setEnabled(enabled);
    Serial.printf("Updated alarm configuration: %s\n", configKey.c_str());
    return true;
}

Alarm* TemperatureController::findAlarm(const String& configKey) {
    for (auto alarm : _configuredAlarms) {
        if (alarm->getConfigKey() == configKey) {
            return alarm;
        }
    }
    return nullptr;
}

Alarm* TemperatureController::getAlarmByIndex(int idx) {
    return (idx >= 0 && idx < _configuredAlarms.size()) ? _configuredAlarms[idx] : nullptr;
}



// Placeholder methods for alarm handling scenarios
void TemperatureController::handleCriticalAlarms() {
    // TODO: Implement critical alarm handling scenario
    // - Turn on both relays immediately
    // - Red LED on
    // - Display alarm
    // - Wait for acknowledgment
    // - 5-minute delay logic
}

void TemperatureController::handleHighPriorityAlarms() {
    // TODO: Implement high priority alarm handling scenario
    // - Different behavior than critical
    // - Maybe only one relay, yellow LED
}

void TemperatureController::handleMediumPriorityAlarms() {
    // TODO: Implement medium priority alarm handling scenario
}

void TemperatureController::handleLowPriorityAlarms() {
    // TODO: Implement low priority alarm handling scenario
}


bool TemperatureController::bindSensorToPointByBusNumber(uint8_t busNumber, uint8_t pointAddress) {
    // Find PT1000 sensor on the specified bus
    for (auto sensor : sensors) {
        if (sensor->getType() == SensorType::PT1000) {
            uint8_t sensorBus = getSensorBus(sensor);
            if (sensorBus == busNumber) {
                MeasurementPoint* point = getMeasurementPoint(pointAddress);
                if (point) {
                    point->bindSensor(sensor);
                    return true;
                }
            }
        }
    }
    return false;
}




// Implement the setter methods
void TemperatureController::setAcknowledgedDelayCritical(unsigned long delay) {
    _acknowledgedDelayCritical = delay;
    applyAcknowledgedDelaysToAlarms();
}

void TemperatureController::setAcknowledgedDelayHigh(unsigned long delay) {
    _acknowledgedDelayHigh = delay;
    applyAcknowledgedDelaysToAlarms();
}

void TemperatureController::setAcknowledgedDelayMedium(unsigned long delay) {
    _acknowledgedDelayMedium = delay;
    applyAcknowledgedDelaysToAlarms();
}

void TemperatureController::setAcknowledgedDelayLow(unsigned long delay) {
    _acknowledgedDelayLow = delay;
    applyAcknowledgedDelaysToAlarms();
}

// Implement the getter methods
unsigned long TemperatureController::getAcknowledgedDelayCritical() const {
    return _acknowledgedDelayCritical;
}

unsigned long TemperatureController::getAcknowledgedDelayHigh() const {
    return _acknowledgedDelayHigh;
}

unsigned long TemperatureController::getAcknowledgedDelayMedium() const {
    return _acknowledgedDelayMedium;
}

unsigned long TemperatureController::getAcknowledgedDelayLow() const {
    return _acknowledgedDelayLow;
}

// Method to apply delays to all existing alarms
void TemperatureController::applyAcknowledgedDelaysToAlarms() {
    for (auto alarm : _configuredAlarms) {
        unsigned long delay;
        switch (alarm->getPriority()) {
            case AlarmPriority::PRIORITY_CRITICAL:
                delay = _acknowledgedDelayCritical;
                break;
            case AlarmPriority::PRIORITY_HIGH:
                delay = _acknowledgedDelayHigh;
                break;
            case AlarmPriority::PRIORITY_MEDIUM:
                delay = _acknowledgedDelayMedium;
                break;
            case AlarmPriority::PRIORITY_LOW:
                delay = _acknowledgedDelayLow;
                break;
            default:
                delay = _acknowledgedDelayMedium; // Default fallback
                break;
        }
        alarm->setAcknowledgedDelay(delay);
    }
    
    // Also apply to active alarms
    // for (auto alarm : _activeAlarms) {
    //     unsigned long delay;
    //     switch (alarm->getPriority()) {
    //         case AlarmPriority::PRIORITY_CRITICAL:
    //             delay = _acknowledgedDelayCritical;
    //             break;
    //         case AlarmPriority::PRIORITY_HIGH:
    //             delay = _acknowledgedDelayHigh;
    //             break;
    //         case AlarmPriority::PRIORITY_MEDIUM:
    //             delay = _acknowledgedDelayMedium;
    //             break;
    //         case AlarmPriority::PRIORITY_LOW:
    //             delay = _acknowledgedDelayLow;
    //             break;
    //         default:
    //             delay = _acknowledgedDelayMedium;
    //             break;
    //     }
    //     alarm->setAcknowledgedDelay(delay);
    // }
}

// int TemperatureController::getAlarmCount(AlarmPriority priority) const {
//     int count = 0;
//     for (auto alarm : _configuredAlarms) {
//         if (alarm->isEnabled() && alarm->getPriority() == priority) {
//             count++;
//         }
//     }
//     return count;
// }

// int TemperatureController::getAlarmCount(AlarmStage stage) const {
//     int count = 0;
//     for (auto alarm : _configuredAlarms) {
//         if (alarm->isEnabled() && alarm->getStage() == stage) {
//             count++;
//         }
//     }
//     return count;
// }

int TemperatureController::getAlarmCount(AlarmPriority priority, AlarmStage stage) const {
    int count = 0;
    for (auto alarm : _configuredAlarms) {
        if (alarm->isEnabled() && 
            alarm->getPriority() == priority && 
            alarm->getStage() == stage) {
            count++;
        }
    }
    return count;
}

// Add these method implementations to TemperatureController.cpp
int TemperatureController::getAlarmCount(AlarmPriority priority, const String& comparison) const {
    int count = 0;
    for (auto alarm : _configuredAlarms) {
        if (alarm->isEnabled() && _comparePriority(alarm->getPriority(), priority, comparison)) {
            count++;
        }
    }
    return count;
}

int TemperatureController::getAlarmCount(AlarmStage stage, const String& comparison) const {
    int count = 0;
    for (auto alarm : _configuredAlarms) {
        if (alarm->isEnabled() && _compareStage(alarm->getStage(), stage, comparison)) {
            count++;
        }
    }
    return count;
}

int TemperatureController::getAlarmCount(AlarmPriority priority, AlarmStage stage, 
                                       const String& priorityComparison, 
                                       const String& stageComparison) const {
    int count = 0;
    for (auto alarm : _configuredAlarms) {
        if (alarm->isEnabled() && 
            _comparePriority(alarm->getPriority(), priority, priorityComparison) &&
            _compareStage(alarm->getStage(), stage, stageComparison)) {
            count++;
        }
    }
    return count;
}

// Add these helper method implementations to TemperatureController.cpp
bool TemperatureController::_comparePriority(AlarmPriority alarmPriority, AlarmPriority targetPriority, const String& comparison) const {
    int alarmValue = static_cast<int>(alarmPriority);
    int targetValue = static_cast<int>(targetPriority);
    
    if (comparison == ">" || comparison == "gt") {
        return alarmValue > targetValue;
    } else if (comparison == ">=" || comparison == "gte") {
        return alarmValue >= targetValue;
    } else if (comparison == "<" || comparison == "lt") {
        return alarmValue < targetValue;
    } else if (comparison == "<=" || comparison == "lte") {
        return alarmValue <= targetValue;
    } else if (comparison == "!=" || comparison == "ne") {
        return alarmValue != targetValue;
    } else { // Default to "==" or "eq"
        return alarmValue == targetValue;
    }
}

bool TemperatureController::_compareStage(AlarmStage alarmStage, AlarmStage targetStage, const String& comparison) const {
    int alarmValue = static_cast<int>(alarmStage);
    int targetValue = static_cast<int>(targetStage);
    
    if (comparison == ">" || comparison == "gt") {
        return alarmValue > targetValue;
    } else if (comparison == ">=" || comparison == "gte") {
        return alarmValue >= targetValue;
    } else if (comparison == "<" || comparison == "lt") {
        return alarmValue < targetValue;
    } else if (comparison == "<=" || comparison == "lte") {
        return alarmValue <= targetValue;
    } else if (comparison == "!=" || comparison == "ne") {
        return alarmValue != targetValue;
    } else { // Default to "==" or "eq"
        return alarmValue == targetValue;
    }
}


void TemperatureController::_handleLowPriorityBlinking() {
    unsigned long currentTime = millis();
    unsigned long elapsed = currentTime - _lastLowPriorityBlinkTime;
    
    if (_lowPriorityBlinkState) {
        // Currently ON - check if we should turn OFF
        if (elapsed >= _blinkOnTime) {
            _lowPriorityBlinkState = false;
            _lastLowPriorityBlinkTime = currentTime;
        }
    } else {
        // Currently OFF - check if we should turn ON
        if (elapsed >= _blinkOffTime) {
            _lowPriorityBlinkState = true;
            _lastLowPriorityBlinkTime = currentTime;
        }
    }
}


void TemperatureController::handleAlarmDisplay() {
    // Update alarm queues
    _updateAlarmQueues();
    
    // Handle button press for acknowledgment
    _checkButtonPress();
    
    // Handle alarm display rotation
    _handleAlarmDisplayRotation();
    
    // Update indicator blinking
    indicator.updateBlinking();
}

void TemperatureController::_updateAlarmQueues() {
    _activeAlarmsQueue.clear();
    _acknowledgedAlarmsQueue.clear();
    
    // Get all active alarms from the system
    std::vector<Alarm*> allActiveAlarms = getActiveAlarms();
    
    // Separate alarms into active and acknowledged queues
    for (auto alarm : allActiveAlarms) {
        if (!alarm) continue;
        
        if (alarm->getStage() == AlarmStage::ACTIVE) {
            _activeAlarmsQueue.push_back(alarm);
        } else if (alarm->getStage() == AlarmStage::ACKNOWLEDGED) {
            _acknowledgedAlarmsQueue.push_back(alarm);
        }
    }
    
    // Sort active alarms by priority (highest first), then by timestamp (oldest first)
    std::sort(_activeAlarmsQueue.begin(), _activeAlarmsQueue.end(), 
              [](const Alarm* a, const Alarm* b) {
                  if (a->getPriority() != b->getPriority()) {
                      return static_cast<int>(a->getPriority()) > static_cast<int>(b->getPriority());
                  }
                  return a->getTimestamp() < b->getTimestamp();
              });
    
    // Sort acknowledged alarms by priority (highest first), then by timestamp (oldest first)
    std::sort(_acknowledgedAlarmsQueue.begin(), _acknowledgedAlarmsQueue.end(),
              [](const Alarm* a, const Alarm* b) {
                  if (a->getPriority() != b->getPriority()) {
                      return static_cast<int>(a->getPriority()) > static_cast<int>(b->getPriority());
                  }
                  return a->getTimestamp() < b->getTimestamp();
              });
}
void TemperatureController::_displayNextActiveAlarm() {
    if (_activeAlarmsQueue.empty()) return;
    
    if (_currentActiveAlarmIndex >= _activeAlarmsQueue.size()) {
        _currentActiveAlarmIndex = 0;
    }
    
    _currentDisplayedAlarm = _activeAlarmsQueue[_currentActiveAlarmIndex];
    _showingOK = false;
    
    // Ensure OLED is turned on whenever an alarm is displayed
    indicator.setOLEDOn();
    indicator.setOledMode(2);
    String displayText = _currentDisplayedAlarm->getDisplayText();
    
    int newlineIndex = displayText.indexOf('\n');
    String line1 = displayText.substring(0, newlineIndex);
    String line2 = displayText.substring(newlineIndex + 1);
    
    String displayLines[2] = {line1, line2};
    indicator.printText(displayLines, 2);
    
    Serial.printf("Displaying active alarm: %s\n", displayText.c_str());
}

void TemperatureController::_displayNextAcknowledgedAlarm() {
    if (_acknowledgedAlarmsQueue.empty()) return;
    
    _currentAcknowledgedAlarmIndex = (_currentAcknowledgedAlarmIndex + 1) % _acknowledgedAlarmsQueue.size();
    
    _currentDisplayedAlarm = _acknowledgedAlarmsQueue[_currentAcknowledgedAlarmIndex];
    _lastAlarmDisplayTime = millis();
    _showingOK = false;
    
    // Ensure OLED is turned on whenever an alarm is displayed
    indicator.setOLEDOn();
    indicator.setOledMode(2);
    String displayText = _currentDisplayedAlarm->getDisplayText();
    
    int newlineIndex = displayText.indexOf('\n');
    String line1 = displayText.substring(0, newlineIndex);
    String line2 = displayText.substring(newlineIndex + 1);
    
    String displayLines[2] = {line1, line2};
    indicator.printText(displayLines, 2);
    
    Serial.printf("Displaying acknowledged alarm: %s (%d/%d)\n",
                  displayText.c_str(),
                  _currentAcknowledgedAlarmIndex + 1,
                  _acknowledgedAlarmsQueue.size());
}

void TemperatureController::_handleAlarmDisplayRotation() {
    unsigned long currentTime = millis();
    
    // Priority 1: Display active alarms first
    if (!_activeAlarmsQueue.empty()) {
        _displayingActiveAlarm = true;
        _currentAcknowledgedAlarmIndex = 0;
        
        // Always turn on OLED when there are active alarms
        indicator.setOLEDOn();
        _displayNextActiveAlarm();
        
        if (_currentDisplayedAlarm && _currentDisplayedAlarm->getStage() == AlarmStage::ACKNOWLEDGED) {
            _currentActiveAlarmIndex++;
            if (_currentActiveAlarmIndex >= _activeAlarmsQueue.size()) {
                _currentActiveAlarmIndex = 0;
            }
        }
        return;
    }
    
    // Priority 2: Display acknowledged alarms in round-robin
    if (!_acknowledgedAlarmsQueue.empty()) {
        _displayingActiveAlarm = false;
        
        // Always turn on OLED when there are acknowledged alarms
        indicator.setOLEDOn();
        
        if (_currentDisplayedAlarm == nullptr || 
            _currentDisplayedAlarm->getStage() != AlarmStage::ACKNOWLEDGED ||
            currentTime - _lastAlarmDisplayTime >= _acknowledgedAlarmDisplayDelay) {
            _displayNextAcknowledgedAlarm();
        }
        return;
    }
    
    // No alarms to display - show OK and turn off OLED
    if (_currentDisplayedAlarm && !_showingOK) {
        _showOKAndTurnOffOLED();
    } else if (_showingOK) {
        if (currentTime - _okDisplayStartTime >= 60000) {
            indicator.setOLEDOff();
            _showingOK = false;
            _currentDisplayedAlarm = nullptr;
        }
    } else {
        _updateNormalDisplay();
    }
}

void TemperatureController::_checkButtonPress() {
    // Use the existing indicator interface button reading with built-in debouncing
    bool currentButtonState = indicator.readPort("BUTTON");
    
    // Detect button press (button pressed = true based on your configuration)
    if (currentButtonState && !_lastButtonState) {
        // Button was just pressed
        if (_displayingActiveAlarm && _currentDisplayedAlarm && 
            _currentDisplayedAlarm->getStage() == AlarmStage::ACTIVE) {
            
            _currentDisplayedAlarm->acknowledge();
            
            Serial.printf("Button pressed - Acknowledged alarm: %s\n",
                          _currentDisplayedAlarm->getDisplayText().c_str());
            
            // Move to next active alarm or switch to acknowledged display
            _currentActiveAlarmIndex++;
            if (_currentActiveAlarmIndex >= _activeAlarmsQueue.size()) {
                _currentActiveAlarmIndex = 0;
            }
            
            // Force immediate update of display
            _lastAlarmDisplayTime = 0;
        }
    }
    
    _lastButtonState = currentButtonState;
}

// Helper method to get priority string





    String TemperatureController::_getAlarmTypeString(AlarmType type) const {
        switch (type) {
            case AlarmType::HIGH_TEMPERATURE: return "HIGH_TEMP";
            case AlarmType::LOW_TEMPERATURE: return "LOW_TEMP";
            case AlarmType::SENSOR_ERROR: return "SENSOR_ERROR";
            case AlarmType::SENSOR_DISCONNECTED: return "DISCONNECTED";
            default: return "UNKNOWN";
        }
    }
    
    String TemperatureController::_getPriorityString(AlarmPriority priority) const {
        switch (priority) {
            case AlarmPriority::PRIORITY_LOW: return "LOW";
            case AlarmPriority::PRIORITY_MEDIUM: return "MEDIUM";
            case AlarmPriority::PRIORITY_HIGH: return "HIGH";
            case AlarmPriority::PRIORITY_CRITICAL: return "CRITICAL";
            default: return "UNKNOWN";
        }
    }

-------- [ Separator ] ------

File Name: src/TimeManager.cpp
Size: 11.16 KB
Code:
#include "TimeManager.h"
#include <LittleFS.h>

TimeManager::TimeManager(int sdaPin, int sclPin) 
    : _sdaPin(sdaPin), _sclPin(sclPin), _timezoneOffset(0), 
      _ntpServer("pool.ntp.org"), _ntpUpdateInterval(3600000), // 1 hour
      _ntpSyncEnabled(true), _rtcConnected(false), _timeSet(false),
      _lastNTPSync(0), _lastNTPAttempt(0), _timeClient(nullptr) {
}

TimeManager::~TimeManager() {
    if (_timeClient) {
        delete _timeClient;
    }
}

bool TimeManager::init() {
    // Initialize I2C
    //Wire.begin(_sdaPin, _sclPin);
    
    // Initialize RTC
    if (!_rtc.begin()) {
        Serial.println("TimeManager: Couldn't find RTC");
        _rtcConnected = false;
        return false;
    }
    
    _rtcConnected = true;
    
    // Check if RTC lost power and set compile time if needed
    if (_rtc.lostPower()) {
        Serial.println("TimeManager: RTC lost power, setting compile time");
        setTimeFromCompileTime();
    } else {
        _timeSet = true;
    }
    
    // // Initialize NTP
    // _initializeNTP();
    
    // // Load saved configuration
    // loadConfig();
    
    // Serial.println("TimeManager: Initialized successfully");
    return true;
}

bool TimeManager::begin() {
    // Initialize I2C
    // Wire.begin(_sdaPin, _sclPin);
    
    // // Initialize RTC
    // if (!_rtc.begin()) {
    //     Serial.println("TimeManager: Couldn't find RTC");
    //     _rtcConnected = false;
    //     return false;
    // }
    
    // _rtcConnected = true;
    
    // // Check if RTC lost power and set compile time if needed
    // if (_rtc.lostPower()) {
    //     Serial.println("TimeManager: RTC lost power, setting compile time");
    //     setTimeFromCompileTime();
    // } else {
    //     _timeSet = true;
    // }
    
    // Initialize NTP
    _initializeNTP();
    
    // Load saved configuration
    loadConfig();
    
    Serial.println("TimeManager: Initialized successfully");
    return true;
}

void TimeManager::_initializeNTP() {
    if (_timeClient) {
        delete _timeClient;
    }
    
    _timeClient = new NTPClient(_ntpUDP, _ntpServer.c_str(), _timezoneOffset, _ntpUpdateInterval);
    _timeClient->begin();
}

bool TimeManager::setTimeFromNTP(const char* ntpServer) {
    if (ntpServer) {
        _ntpServer = String(ntpServer);
        _initializeNTP();
    }
    
    if (!_isWiFiConnected()) {
        Serial.println("TimeManager: WiFi not connected for NTP sync");
        return false;
    }
    
    if (_timeClient->update()) {
        unsigned long epochTime = _timeClient->getEpochTime();
        DateTime ntpTime = DateTime(epochTime);
        
        if (_rtcConnected) {
            _rtc.adjust(ntpTime);
        }
        
        _timeSet = true;
        _lastNTPSync = millis();
        
        Serial.printf("TimeManager: Time synchronized with NTP: %s\n", 
                     getFormattedTime().c_str());
        return true;
    }
    
    Serial.println("TimeManager: Failed to get time from NTP");
    return false;
}

bool TimeManager::setTime(int year, int month, int day, int hour, int minute, int second) {
    DateTime newTime(year, month, day, hour, minute, second);
    return setTime(newTime);
}

bool TimeManager::setTime(DateTime dateTime) {
    if (_rtcConnected) {
        _rtc.adjust(dateTime);
        _timeSet = true;
        Serial.printf("TimeManager: Time set to: %s\n", 
                     _formatDateTime(dateTime, "YYYY-MM-DD hh:mm:ss").c_str());
        return true;
    }
    return false;
}

bool TimeManager::setTimeFromUnix(uint32_t unixTime) {
    DateTime newTime(unixTime);
    return setTime(newTime);
}

bool TimeManager::setTimeFromCompileTime() {
    if (_rtcConnected) {
        _rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
        _timeSet = true;
        Serial.println("TimeManager: Time set to compile time");
        return true;
    }
    return false;
}

DateTime TimeManager::getCurrentTime() {
    if (_rtcConnected) {
        DateTime utcTime = _rtc.now();
        return utcTime; //_applyTimezone(utcTime);
    }
    return DateTime((uint32_t)0); // Explicitly cast to uint32_t
}


String TimeManager::getFormattedTime(const String& format) {
    DateTime current = getCurrentTime();
    return _formatDateTime(current, format);
}

String TimeManager::getTimeString() {
    DateTime current = getCurrentTime();
    return _formatDateTime(current, "hh:mm:ss");
}

String TimeManager::getDateString() {
    DateTime current = getCurrentTime();
    return _formatDateTime(current, "YYYY-MM-DD");
}

uint32_t TimeManager::getUnixTime() {
    if (_rtcConnected) {
        return _rtc.now().unixtime();
    }
    return 0;
}

void TimeManager::setTimezone(int offsetHours, int offsetMinutes) {
    _timezoneOffset = (offsetHours * 3600) + (offsetMinutes * 60);
    if (_timeClient) {
        _timeClient->setTimeOffset(_timezoneOffset);
    }
    Serial.printf("TimeManager: Timezone set to GMT%+d:%02d\n", offsetHours, abs(offsetMinutes));
}

void TimeManager::setTimezoneOffset(long offsetSeconds) {
    _timezoneOffset = offsetSeconds;
    if (_timeClient) {
        _timeClient->setTimeOffset(_timezoneOffset);
    }
}

int TimeManager::getTimezoneHours() {
    return _timezoneOffset / 3600;
}

int TimeManager::getTimezoneMinutes() {
    return (_timezoneOffset % 3600) / 60;
}

long TimeManager::getTimezoneOffset() {
    return _timezoneOffset;
}

void TimeManager::setNTPServer(const String& server) {
    _ntpServer = server;
    _initializeNTP();
}

void TimeManager::setNTPUpdateInterval(unsigned long intervalMs) {
    _ntpUpdateInterval = intervalMs;
    if (_timeClient) {
        _timeClient->setUpdateInterval(intervalMs);
    }
}

String TimeManager::getNTPServer() {
    return _ntpServer;
}

void TimeManager::update() {
    // Auto-sync with NTP if enabled and interval elapsed
    if (_ntpSyncEnabled && _isWiFiConnected() && 
        (millis() - _lastNTPSync) > _ntpUpdateInterval &&
        (millis() - _lastNTPAttempt) > 60000) { // Don't attempt more than once per minute
        
        _lastNTPAttempt = millis();
        if (setTimeFromNTP()) {
            Serial.println("TimeManager: Automatic NTP sync successful");
        }
    }
}

bool TimeManager::syncWithNTP() {
    return setTimeFromNTP();
}

bool TimeManager::isNTPSyncEnabled() {
    return _ntpSyncEnabled;
}

void TimeManager::enableNTPSync(bool enable) {
    _ntpSyncEnabled = enable;
}

bool TimeManager::isRTCConnected() {
    return _rtcConnected;
}

bool TimeManager::isTimeSet() {
    return _timeSet;
}

bool TimeManager::hasLostPower() {
    return _rtcConnected ? _rtc.lostPower() : true;
}

unsigned long TimeManager::getLastNTPSync() {
    return _lastNTPSync;
}

float TimeManager::getTemperature() {
    if (_rtcConnected) {
        return _rtc.getTemperature();
    }
    return NAN;
}

bool TimeManager::setAlarm1(DateTime alarmTime, Ds3231Alarm1Mode mode) {
    if (_rtcConnected) {
        return _rtc.setAlarm1(alarmTime, mode);
    }
    return false;
}

bool TimeManager::setAlarm2(DateTime alarmTime, Ds3231Alarm2Mode mode) {
    if (_rtcConnected) {
        return _rtc.setAlarm2(alarmTime, mode);
    }
    return false;
}

bool TimeManager::clearAlarm1() {
    if (_rtcConnected) {
        _rtc.clearAlarm(1);
        return true; // Just return true after calling
    }
    return false;
}

bool TimeManager::clearAlarm2() {
    if (_rtcConnected) {
        _rtc.clearAlarm(2);
        return true; // Just return true after calling
    }
    return false;
}


bool TimeManager::isAlarm1Triggered() {
    if (_rtcConnected) {
        return _rtc.alarmFired(1);
    }
    return false;
}

bool TimeManager::isAlarm2Triggered() {
    if (_rtcConnected) {
        return _rtc.alarmFired(2);
    }
    return false;
}

void TimeManager::enableSquareWave(Ds3231SqwPinMode mode) {
    if (_rtcConnected) {
        _rtc.writeSqwPinMode(mode);
    }
}

void TimeManager::disableSquareWave() {
    if (_rtcConnected) {
        _rtc.writeSqwPinMode(DS3231_OFF);
    }
}

String TimeManager::getTimeJSON() {
    DynamicJsonDocument doc(512);
    
    DateTime current = getCurrentTime();
    doc["timestamp"] = current.unixtime();
    doc["formatted"] = getFormattedTime();
    doc["date"] = getDateString();
    doc["time"] = getTimeString();
    doc["timezone_offset"] = _timezoneOffset;
    doc["timezone_hours"] = getTimezoneHours();
    doc["timezone_minutes"] = getTimezoneMinutes();
    
    String output;
    serializeJson(doc, output);
    return output;
}

String TimeManager::getStatusJSON() {
    DynamicJsonDocument doc(512);
    
    doc["rtc_connected"] = _rtcConnected;
    doc["time_set"] = _timeSet;
    doc["has_lost_power"] = hasLostPower();
    doc["ntp_enabled"] = _ntpSyncEnabled;
    doc["ntp_server"] = _ntpServer;
    doc["last_ntp_sync"] = _lastNTPSync;
    doc["wifi_connected"] = _isWiFiConnected();
    
    if (_rtcConnected) {
        doc["temperature"] = _rtc.getTemperature();
        doc["alarm1_triggered"] = isAlarm1Triggered();
        doc["alarm2_triggered"] = isAlarm2Triggered();
    }
    
    String output;
    serializeJson(doc, output);
    return output;
}

void TimeManager::saveConfig() {
    DynamicJsonDocument doc(256);
    doc["timezone_offset"] = _timezoneOffset;
    doc["ntp_server"] = _ntpServer;
    doc["ntp_update_interval"] = _ntpUpdateInterval;
    doc["ntp_sync_enabled"] = _ntpSyncEnabled;
    
    File file = LittleFS.open("/time_config.json", "w");
    if (file) {
        serializeJson(doc, file);
        file.close();
        Serial.println("TimeManager: Configuration saved");
    }
}

void TimeManager::loadConfig() {
    File file = LittleFS.open("/time_config.json", "r");
    if (file) {
        DynamicJsonDocument doc(256);
        DeserializationError error = deserializeJson(doc, file);
        file.close();
        
        if (!error) {
            _timezoneOffset = doc["timezone_offset"] | 0;
            _ntpServer = doc["ntp_server"] | "pool.ntp.org";
            _ntpUpdateInterval = doc["ntp_update_interval"] | 3600000;
            _ntpSyncEnabled = doc["ntp_sync_enabled"] | true;
            
            // Reinitialize NTP with loaded settings
            _initializeNTP();
            
            Serial.println("TimeManager: Configuration loaded");
        }
    }
}

// Private helper methods
bool TimeManager::_isWiFiConnected() {
    return WiFi.status() == WL_CONNECTED;
}

DateTime TimeManager::_applyTimezone(DateTime utcTime) {
    return DateTime(utcTime.unixtime() + _timezoneOffset);
}

DateTime TimeManager::_removeTimezone(DateTime localTime) {
    return DateTime(localTime.unixtime() - _timezoneOffset);
}

String TimeManager::_formatDateTime(DateTime dt, const String& format) {
    String result = format;
    
    // Replace format tokens
    result.replace("YYYY", String(dt.year()));
    result.replace("MM", String(dt.month()).length() == 1 ? "0" + String(dt.month()) : String(dt.month()));
    result.replace("DD", String(dt.day()).length() == 1 ? "0" + String(dt.day()) : String(dt.day()));
    result.replace("hh", String(dt.hour()).length() == 1 ? "0" + String(dt.hour()) : String(dt.hour()));
    result.replace("mm", String(dt.minute()).length() == 1 ? "0" + String(dt.minute()) : String(dt.minute()));
    result.replace("ss", String(dt.second()).length() == 1 ? "0" + String(dt.second()) : String(dt.second()));
    
    return result;
}

-------- [ Separator ] ------

File Name: src/main.cpp
Size: 5.88 KB
Code:
#include <Arduino.h>
#include "TemperatureController.h"
#include "TempModbusServer.h"
#include "ConfigManager.h"
#include "IndicatorInterface.h"
#include <SPI.h>
#include "TimeManager.h"
#include "LoggerManager.h"



// Create temperature controller

//DS18B20 PINs
#define BUS1_PIN  4
#define BUS2_PIN  5
#define BUS3_PIN  18
#define BUS4_PIN  19

//PT1000 PINs
//SPI PINs
#define SCK_PIN  14
#define MISO_PIN  12
#define MOSI_PIN  13

#define CS1_PIN  32
#define CS2_PIN  33
#define CS3_PIN  26
#define CS4_PIN  27

#define CS5_PIN_TF_CARD  0


//RS485 PINs
#define RX_PIN  22 //to rxd
#define TX_PIN  23 //to txd
#define DE_PIN  -1



// I2C pins for WROVER (avoiding conflicts)
#define I2C_SDA 21  // Default SDA, available
#define I2C_SCL 25  // Alternative SCL (GPIO 22 used by RS485)
#define PCF_INT 34 // PCF expander interupt pin

IndicatorInterface indicator(Wire, 0x20, PCF_INT);  // I2C address 0x20, INT pin 34




uint8_t onwWirePins[4] = {BUS1_PIN,  BUS2_PIN, BUS3_PIN, BUS4_PIN};
uint8_t csPins[4] = {CS1_PIN,  CS2_PIN, CS3_PIN, CS4_PIN};
TemperatureController controller(onwWirePins, csPins, indicator);

// Create configuration manager
ConfigManager* configManager;

// Create Modbus server
TempModbusServer* modbusServer;

TimeManager timeManager(I2C_SDA, I2C_SCL);

LoggerManager logger(controller, timeManager, SD);

void setup() {
    // Initialize serial for debugging
    Serial.begin(115200);
    while (!Serial) {}
        // Initialize I2C
    Wire.begin(I2C_SDA, I2C_SCL);
    Wire.setClock(100000);

    SPI.begin(SCK_PIN, MISO_PIN, MOSI_PIN);  // SCK, MISO, MOSI, SS



    // Initialize time manager
    if (timeManager.init()) {
        Serial.println("TimeManager initialized successfully");
        
        // Set timezone (GMT+3 for Moscow)
        timeManager.setTimezone(3, 0);
        
  
    }

    // Configure logging
    logger.setLogDirectory("/data"); 
    logger.setAlarmStateLogDirectory("/alarms");
    logger.setEventLogDirectory("/events");
    logger.setLogFrequency(2000);  // Log every 30 seconds
    logger.setDailyFiles(true);     // Create new file each day
    logger.setEnabled(true);        // Enable logging

    // Initialize SD card
    if (!SD.begin(CS5_PIN_TF_CARD)) {
        Serial.println("SD Card initialization failed");
        logger.setEnabled(false);
        //return;
    }
    
    // Initialize logger
    if (!logger.init()) {
        Serial.println("Logger initialization failed");
    } else {
        Serial.println("Logger initialized successfully");
    }
    
    logger.info("SYSTEM", "Temperature controller started");




    

    // Configure all CS pins as OUTPUT
    pinMode(CS1_PIN, OUTPUT);
    pinMode(CS2_PIN, OUTPUT); 
    pinMode(CS3_PIN, OUTPUT);
    pinMode(CS4_PIN, OUTPUT);
    //pinMode(CS5_PIN, OUTPUT);
    
    // Set all CS pins HIGH initially (inactive)
    digitalWrite(CS1_PIN, HIGH);
    digitalWrite(CS2_PIN, HIGH);
    digitalWrite(CS3_PIN, HIGH);
    digitalWrite(CS4_PIN, HIGH);
    //digitalWrite(CS5_PIN, HIGH);



    Serial.println("\nIndustrial Temperature Monitoring System");
    Serial.println("--------------------------------------");
    //controller = new TemperatureController(onwWirePins);
    Serial.println("\nController created");
    
    // Initialize controller
    controller.begin();
    Serial.println("\nController begin");
    
    // Initialize configuration manager
    configManager = new ConfigManager(controller);
    if (!configManager->begin()) {
        Serial.println("Failed to initialize configuration manager");
    }
    
    // Apply configuration to controller
    controller.setDeviceId(configManager->getDeviceId());
    Serial.println("controller.setDeviceId(configManager->getDeviceId());");
    controller.setMeasurementPeriod(configManager->getMeasurementPeriod()*1000);
    Serial.println("controller.setMeasurementPeriod(configManager->getMeasurementPeriod());");
    //controller.setOneWireBusPin(configManager->getOneWirePin());
    Serial.println("controller.setOneWireBusPin(configManager->getOneWirePin());");
    
    //Discover DS18B20 sensors
    controller.discoverDS18B20Sensors();
    controller.discoverPTSensors();
    // Initialize Modbus server if enabled in config
    if (configManager->isModbusEnabled()) {
        Serial.println("Init Modbus RTU server...");
        modbusServer = new TempModbusServer(
            controller.getRegisterMap(),
            configManager->getModbusAddress(),
            Serial2,
            RX_PIN,
            TX_PIN,
            DE_PIN,
            configManager->getModbusBaudRate()
        );
        Serial.println("Init Modbus RTU server!");

        
        if (modbusServer->begin()) {
            Serial.println("Modbus RTU server started successfully");
        } else {
            Serial.println("Failed to start Modbus RTU server");
        }
    }


    if(timeManager.begin()){
          // Sync with NTP when WiFi connects
          if (WiFi.status() == WL_CONNECTED) {
            timeManager.setTimeFromNTP();
        }
    }
    
    logger.begin();


    

    
    Serial.println("\nSystem is now running...");
}

void loop() {
    // Update configuration manager
    timeManager.update();
    configManager->update();
    
    // Update controller (reads sensors and updates register map)
    controller.update();
    
    // Print status every 30 seconds if not in portal mode
    static unsigned long lastPrintTime = 0;
    if (!configManager->isPortalActive() && millis() - lastPrintTime > controller.getMeasurementPeriod()) {
        //Serial.println("\nSensors Status:");
        //Serial.println(controller.getSystemStatusJson());
        //Serial.println(controller.getSensorsJson());
        //Serial.println("\nPoints Status:");
        //Serial.println(controller.getSystemStatusJson());
        //Serial.println(controller.getPointsJson());
        
        lastPrintTime = millis();
    }
    logger.update();
    
    // Small delay to prevent CPU hogging
    delay(100);
}

-------- [ Separator ] ------

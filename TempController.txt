Project Overview
===============

Project Statistics:
Total Files: 71
Total Size: 942.88 KB

File Types:
  .cpp: 13 files
  .md: 12 files
  .h: 12 files
  .html: 11 files
  .cpp_: 11 files
  no extension: 3 files
  .json: 2 files
  .html_: 2 files
  .yaml: 1 files
  .pdf: 1 files
  .py: 1 files
  .ini: 1 files
  .csv: 1 files

Detected Technologies:
  - Python

Folder Structure (Tree)
=====================
Legend: ✓ = Included in output, ✗ = Excluded from output

├── .DS_Store (6.00 KB) ✗
├── .claude/
│   └── settings.local.json (895 B) ✓
├── .gitignore (94 B) ✓
├── .mcp.json (1.14 KB) ✓
├── CLAUDE.md (7.88 KB) ✓
├── LICENSE (11.09 KB) ✓
├── README.md (4.27 KB) ✓
├── alarm_handle.md (2.12 KB) ✓
├── config.yaml (1.51 KB) ✓
├── data/
│   ├── alarm-config.html (21.38 KB) ✓
│   ├── alarm-history.html (22.26 KB) ✓
│   ├── alarms.html (21.69 KB) ✓
│   ├── dashboard.html (28.41 KB) ✓
│   ├── download-logs.html (16.94 KB) ✓
│   ├── event-logs.html (22.84 KB) ✓
│   ├── points.html (20.55 KB) ✓
│   └── sensors.html (15.97 KB) ✓
├── docs/
│   ├── DEVELOPMENT_BRIEF.md (12.65 KB) ✓
│   ├── Development_Brief_initial.pdf (123.92 KB) ✗
│   ├── MODBUS_REGISTER_MAP.md (10.21 KB) ✓
│   ├── ONBOARDING_RESULTS.md (9.14 KB) ✓
│   ├── PLANNING_RESULTS.md (34.75 KB) ✓
│   ├── TECHNICAL_DOCUMENTATION.md (16.69 KB) ✓
│   ├── USER_MANUAL_RU.md (19.74 KB) ✓
│   ├── WEB_INTERFACE_SPEC.md (16.47 KB) ✓
│   ├── fix_alarm_config.md (1.99 KB) ✓
│   └── main_requirements.md (3.75 KB) ✓
├── download_fs.py (10.69 KB) ✓
├── include/
│   ├── Alarm.h (4.31 KB) ✓
│   ├── CSVConfigManager.h (1.60 KB) ✓
│   ├── ConfigManager.h (4.10 KB) ✓
│   ├── IndicatorInterface.h (5.91 KB) ✓
│   ├── LoggerManager.h (9.46 KB) ✓
│   ├── MeasurementPoint.h (1.93 KB) ✓
│   ├── RegisterMap.h (3.92 KB) ✓
│   ├── Sensor.h (2.54 KB) ✓
│   ├── SettingsCSVManager.h (826 B) ✓
│   ├── TempModbusServer.h (1.01 KB) ✓
│   ├── TemperatureController.h (7.72 KB) ✓
│   └── TimeManager.h (2.88 KB) ✓
├── platformio.ini (1.02 KB) ✓
├── src/
│   ├── Alarm.cpp (24.84 KB) ✓
│   ├── CSVConfigManager.cpp (12.31 KB) ✓
│   ├── ConfigManager.cpp (72.10 KB) ✓
│   ├── IndicatorInterface.cpp (29.11 KB) ✓
│   ├── LoggerManager.cpp (63.11 KB) ✓
│   ├── MeasurementPoint.cpp (3.92 KB) ✓
│   ├── RegisterMap.cpp (5.20 KB) ✓
│   ├── Sensor.cpp (7.31 KB) ✓
│   ├── SettingsCSVManager.cpp (6.01 KB) ✓
│   ├── TempModbusServer.cpp (14.62 KB) ✓
│   ├── TemperatureController.cpp (64.40 KB) ✓
│   ├── TimeManager.cpp (11.16 KB) ✓
│   └── main.cpp (5.88 KB) ✓
├── test/
│   ├── alarm-history.html_ (22.15 KB) ✓
│   ├── alarm_states_2025-07-09.csv (338 B) ✓
│   ├── d18b10_test.cpp_ (2.07 KB) ✓
│   ├── discover_i2c.cpp_ (3.49 KB) ✓
│   ├── format.cpp_ (637 B) ✓
│   ├── indicator_test.cpp_ (2.27 KB) ✓
│   ├── modbus_test.cpp_ (2.18 KB) ✓
│   ├── oled_test.cpp_ (1.17 KB) ✓
│   ├── pcf_test.cpp_ (4.69 KB) ✓
│   ├── points.html_ (15.46 KB) ✓
│   ├── pttest.cpp_ (2.34 KB) ✓
│   ├── rtc_test.cpp_ (1.03 KB) ✓
│   ├── tf_test.cpp_ (2.25 KB) ✓
│   └── wifi_test.cpp_ (601 B) ✓
└── unpacked_fs/
    ├── dashboard.html (20.11 KB) ✓
    ├── points.html (14.30 KB) ✓
    └── sensors.html (15.65 KB) ✓

==============

File Name: .claude/settings.local.json
Size: 895 B
Code:
{
  "permissions": {
    "allow": [
      "Bash(claude doctor)",
      "mcp__MCP_DOCKER__get_config",
      "mcp__MCP_DOCKER__list_directory",
      "mcp__MCP_DOCKER__start_process",
      "Bash(docker logs:*)",
      "Bash(docker:*)",
      "mcp__n8n-mcp__get_database_statistics",
      "mcp__filesystem__list_allowed_directories",
      "mcp__filesystem__get_file_info",
      "Bash(pio run:*)",
      "Bash(pio device monitor:*)",
      "Bash(pio device:*)",
      "Bash(timeout 20 screen -L -Logfile /tmp/esp32_output.log /dev/cu.usbserial-0001 115200)",
      "Bash(stty:*)",
      "Bash(lsof:*)",
      "mcp__context7__resolve-library-id",
      "mcp__filesystem__list_directory",
      "mcp__filesystem__read_file",
      "mcp__filesystem__search_files"
    ]
  },
  "enableAllProjectMcpServers": true,
  "enabledMcpjsonServers": [
    "filesystem",
    "MCP_DOCKER",
    "n8n-mcp"
  ]
}
-------- [ Separator ] ------

File Name: .gitignore
Size: 94 B
Code:
.pio
.vscode/.browse.c_cpp.db*
.vscode/c_cpp_properties.json
.vscode/launch.json
.vscode/ipch

-------- [ Separator ] ------

File Name: .mcp.json
Size: 1.14 KB
Code:
{
    "mcpServers": {
      "filesystem": {
        "command": "npx",
        "args": [
          "mcp-server-filesystem",
          "/Users/sergeybarabash/robo",
          "/Users/sergeybarabash/robo/Claude_desktop",
          "/Users/sergeybarabash/.platformio"
        ]
      },
      "MCP_DOCKER": {
        "command": "docker",
        "args": ["run", "-i", "--rm", "alpine/socat", "STDIO", "TCP:host.docker.internal:8811"]
      },
      "n8n-mcp": {
      "command": "docker",
      "args": [
        "run",
        "-i",
        "--rm",
        "--init",
        "-e", "MCP_MODE=stdio",
        "-e", "LOG_LEVEL=error",
        "-e", "DISABLE_CONSOLE_OUTPUT=true",
        "-e", "N8N_API_URL=https://vpn.fedoseev.one/",
        "-e", "N8N_API_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIyNTY1NTI3ZS02MDNiLTQ1ZmItOWRjNC1lMGYyZWRiNzA1ZDQiLCJpc3MiOiJuOG4iLCJhdWQiOiJwdWJsaWMtYXBpIiwiaWF0IjoxNzUyODY4ODA2LCJleHAiOjE3NTc5NzAwMDB9.gBU91Tp3Mk_x6QUesN7wQ1xsutnEFI4jpYhxruTdN6E",
        "ghcr.io/czlonkowski/n8n-mcp:latest"
      ]
    },
    "context7": {
      "command": "npx",
      "args": [
        "@upstash/context7-mcp"
      ]
    }
    
    }
  }
-------- [ Separator ] ------

File Name: CLAUDE.md
Size: 7.88 KB
Code:
# Bash commands
- use git CLI (`gh`) to manage git features
- when use any bash commands run it with --help first  to understand how to use it
## Platformio commands
### Project Management
pio project init --board uno                    # Initialize for Arduino Uno
pio project init --board esp32dev --ide vscode  # Initialize for ESP32 with VSCode
pio project config                              # Show current config

### Build and Run
pio run                                         # Build all environments
pio run -e uno                                  # Build only uno environment
pio run -t clean                                # Clean build files
pio run -t upload                               # Build and upload
pio run -t upload -e esp32dev                   # Upload to specific environment
pio run -t monitor                              # Build, upload, and monitor
pio run --list-targets                          # List available targets

### Device Management
pio device list                                 # List connected devices
pio device monitor                              # Open serial monitor
pio device monitor -b 115200                    # Monitor at 115200 baud
pio device monitor -p /dev/ttyUSB0              # Monitor specific port

### Library Management
pio lib search ArduinoJson                      # Search for libraries
pio lib install ArduinoJson                     # Install library
pio lib install 64                              # Install by ID
pio lib uninstall ArduinoJson                   # Remove library
pio lib list                                    # List installed libraries
pio lib update                                  # Update all libraries

### Package Management
pio pkg install                                 # Install project dependencies
pio pkg list                                    # List installed packages
pio pkg outdated                                # Show outdated packages
pio pkg update                                  # Update packages

### Platform Management
pio platform list                              # List installed platforms
pio platform search esp32                      # Search for platforms
pio platform install espressif32               # Install platform
pio platform uninstall espressif32             # Remove platform

### Testing
pio test                                        # Run all tests
pio test -e uno                                 # Run tests for environment
pio test --verbose                              # Verbose test output

### Remote Development
pio remote device list                          # List remote devices
pio remote run -t upload                       # Remote upload

### Debugging
pio debug                                       # Start debugging session
pio debug --interface=gdb                      # Debug with specific interface

### Account & Access
pio account show                                # Show account info
pio account login                               # Login to PlatformIO account
pio account logout                              # Logout from account

### System Info
pio system info                                 # Show system information
pio system prune                                # Clean system cache
pio upgrade                                     # Upgrade PlatformIO Core



# Code style
- **ALWAYS** use doxygen stile comments. The code should be well documented
- OOP aproach is required. Abstract all the phisical devices, data layers and main logic bloks into separate classes.
- use git `claude-branch` branch for work, if it does not exist, create it from the current branch.
- use consistent HTML CSS stiles across all the HTML files

# Workflow
## Onboarding stage
- **DO NOT CODE** during this stage. The purpose of this stage - to study the code base.
- Ask any questions during the stage process you can't clarify from the project files. ALWAYS provide answer options in test-like manner to speed up the process.
- **Check you MCP tools avaliable**. Inform me if something does not work properly and let's fix it together.
- check if `./*/ONBOARDING_RESULTS.md` file already axists. If yes, study it.
- **Explore folder and file structure of the project**
- Explore and `./.pio/libdeps` to understand the libraries used in the project better
- Explore the code. **THINK** about the classes, code logic and user interactions with the device
- Use content7 to understand libraries used in the code.
- Explore the `./docs` and other project directories for the projects documentation. `docs/main_requirements.md` - the file you should base your decissions when there are any conflict requirements across the documentation.
- Put a summary of the stage in a `./docs/<TASK>_ONBOARDING_RESULTS.md` file (change or create)

## Planning 
- **DO NOT CODE** during this stage. The purpose of this stage - to create a plan of how to change the code to meet the requirements from the briefs.
- check if `./docs/<TASK>_PLANNING_RESULTS.md` and `./docs/GLOBAL_PLANNING_RESULTS.md` files already axist. If yes, study them.
- **THINK HARD** about the plan of the changing in the code to meet requirements from the task or brief files. The plan shoud contain **step-by-step** implementation with intermediate testing of the code.
- **ALWAYS** put item `Find and resolve TODO and simmilar placeholders in the code` to each stage of the plan.
- **THINK** about a series of unit tests, what debug output do you need to run the tests and to make the debug process easy in general.
- Ask any questions during the stage process you can't clarify from the project files. ALWAYS provide answer options in test-like manner to speed up the process.
- Create or update a global plan with high level steps if there are any and put it into `./docs/GLOBAL_PLANNING_RESULTS.md` file. It Should include both `code` and `tests` sections for each phase. It should be short and concise. Do not include any development timings etc.
- Create or update a working plan and put it into `./docs/<TASK>_PLANNING_RESULTS.md` file. It Should include both `code` and `tests` sections for each phase.

## Code changing
- **Implement the code chanhes** from the plan file `./docs/PLANNING_RESULTS.md` of the previous step. Before any changes study the libraries usage and examples to use the right implementation.
- **Step-by-step** implementation required. 
- After improving an old or introducing some new feature or creating new class check the code for consistancy.
- **DO NOT leave any placeholders like TODO or It will be changed later***. Complete the task of emplementing or changing the feature completely.
- if for any reason you have to place the `TODO` placeholder, **ALWAYS** update the plan file.
- Try to run the build process and check for any compiler errors and warnings
- Iterate thrugh the code to make the build process clean.
- **ALWAYS** check for TODO plaseholders and comments and try to fix this right away
- **Use MCP tools** to extend you abbilities.
- Check if any boards are avaliable (plugged) to the computer. You can ask me to connect the device. Ask me for permission to upload the firmware. If yes, upload and monotor the firmware, apply tests. If you do need any inteructions from the physical world, ask me for them, as well as if you need some help to read from the OLED etc. You can ask me for some images etc.
- If for some reasons you can't run any command, **THINK** about how to solve it, create a plan and provide me with this solution.
- Be sure to typecheck when you’re done making a series of code changes
- Prefer running single tests, and not the whole test suite, for performance.
- If the test passed - go to the next step of the implementation plan.
- **ALWAYS** Mark the completed point in the plan with an appropriate statuses (e.g. CREATED, TESTED, COMPLETED etc.)

## Documentation and GIT
- Change `README.md` of the project and any files form the `./docs` directory to keep the documentation relevant to changes you've made.
- If the test passed, commit to `claude-branch` git branch.

-------- [ Separator ] ------

File Name: LICENSE
Size: 11.09 KB
Code:
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

-------- [ Separator ] ------

File Name: README.md
Size: 4.27 KB
Code:
# Industrial ESP32 Temperature Monitoring System

## Device Description

This industrial-grade ESP32-based device is designed for precision temperature monitoring in industrial environments. It collects temperature data from multiple sensors, including DS18B20 digital temperature sensors and PT1000/PT100 RTD sensors connected via MAX31865 modules. The system supports up to 50 DS18B20 sensors and 10 PT1000/PT100 sensors, with expansion capability for future sensor types.

### Key Features:
- Multi-sensor support (DS18B20 and PT1000/PT100)
- MODBUS-RTU communication over RS485
- Web interface for configuration and monitoring
- Configurable alarm thresholds for each sensor
- Error detection and reporting
- Temperature range: -40°C to +200°C (integer Celsius values)
- Industrial-grade reliability and accuracy

### Communication Interfaces:
- RS485 MODBUS-RTU for industrial system integration
- Web interface for configuration and monitoring
- Temperature data accessible via both interfaces

## MODBUS Register Map

### Device Information Registers (0-99)
| Register | Description | Data Type | Access |
|----------|-------------|-----------|--------|
| 0 | Device ID/Model Number | UINT16 | R |
| 1 | Firmware Version | UINT16 | R |
| 2 | Number of Active DS18B20 Sensors | UINT16 | R |
| 3 | Number of Active PT1000/PT100 Sensors | UINT16 | R |
| 4-10 | Device Status and Diagnostics | UINT16 | R |
| 11-99 | Reserved for Future Use | - | - |

### Temperature Data Registers (100-299)
| Register Range | Description | Data Type | Access |
|----------------|-------------|-----------|--------|
| 100-149 | Current Temperature Readings - DS18B20 (addresses 0-49) | INT16 | R |
| 150-159 | Current Temperature Readings - PT1000/PT100 (addresses 50-59) | INT16 | R |
| 160-199 | Reserved for Future Sensor Types | - | - |
| 200-249 | Min Temperature Readings - DS18B20 (addresses 0-49) | INT16 | R |
| 250-259 | Min Temperature Readings - PT1000/PT100 (addresses 50-59) | INT16 | R |
| 260-299 | Reserved for Future Sensor Types | - | - |

### Max Temperature Registers (300-399)
| Register Range | Description | Data Type | Access |
|----------------|-------------|-----------|--------|
| 300-349 | Max Temperature Readings - DS18B20 (addresses 0-49) | INT16 | R |
| 350-359 | Max Temperature Readings - PT1000/PT100 (addresses 50-59) | INT16 | R |
| 360-399 | Reserved for Future Sensor Types | - | - |

### Alarm and Error Registers (400-599)
| Register Range | Description | Data Type | Access |
|----------------|-------------|-----------|--------|
| 400-449 | Alarm Status - DS18B20 (addresses 0-49) | UINT16 | R |
| 450-459 | Alarm Status - PT1000/PT100 (addresses 50-59) | UINT16 | R |
| 460-499 | Reserved for Future Sensor Types | - | - |
| 500-549 | Error Status - DS18B20 (addresses 0-49) | UINT16 | R |
| 550-559 | Error Status - PT1000/PT100 (addresses 50-59) | UINT16 | R |
| 560-599 | Reserved for Future Sensor Types | - | - |

### Configuration Registers (600-799)
| Register Range | Description | Data Type | Access |
|----------------|-------------|-----------|--------|
| 600-649 | Low Temperature Alarm Thresholds - DS18B20 (addresses 0-49) | INT16 | R/W |
| 650-659 | Low Temperature Alarm Thresholds - PT1000/PT100 (addresses 50-59) | INT16 | R/W |
| 660-699 | Reserved for Future Sensor Types | - | - |
| 700-749 | High Temperature Alarm Thresholds - DS18B20 (addresses 0-49) | INT16 | R/W |
| 750-759 | High Temperature Alarm Thresholds - PT1000/PT100 (addresses 50-59) | INT16 | R/W |
| 760-799 | Reserved for Future Sensor Types | - | - |

## Alarm Status Bit Definitions
Each alarm status register contains the following bit flags:
- Bit 0: Low Temperature Alarm
- Bit 1: High Temperature Alarm
- Bits 2-15: Reserved for future alarm types

## Error Status Bit Definitions
Each error status register contains the following bit flags:
- Bit 0: Sensor Communication Error
- Bit 1: Sensor Out of Range
- Bit 2: Sensor Disconnected
- Bits 3-15: Reserved for future error types

## Notes
- All temperature values are in integer degrees Celsius
- Valid temperature range: -40°C to +200°C
- MODBUS function code 0x03 (Read Holding Registers) for reading values
- MODBUS function code 0x06 (Write Single Register) for writing configuration
- MODBUS function code 0x10 (Write Multiple Registers) for writing multiple configuration values

-------- [ Separator ] ------

File Name: alarm_handle.md
Size: 2.12 KB
Code:
Ok. Now it works excellent. Thank you.
The next step - we need to handle alarms properly. In the device the "loud" indication is with relays 1 and 2 - there is a siren  on the relay 1 and a blinking beacon on relay2, green, yellow, blue and red LEDs are on teh device, so we need to use two kinds of indication separately and there are different scenarios for different alarm priorities as well. Lets solve the loud notification first. I think we should put all the alarms into a sort of stack sorted by priority and a stage within each priority. If there are any alarms within the group, we handle the loud notification this way (for example):
1. Critical unacknowledged - both siren and beacon are ON constantly
2. High priority unacknowledged, or Critical not cleared but acknowledged - beacon is ON constantly
3. All Critical alarms are resolved, but High priority not cleared but acknowledged, or Medium priority is either active or acknowleged - beacon is getting on from time to time (for 10 secconds once in a few minutes - this also should be a setting)

So actually we need a scenario for each alarm priority with standard options
ACTIVE - siren action, beacon action
ACKNOWLEDGED - siren action, beacon action


Also we should display and handle acknolagement of uresolved alarms in a different way. We should display the highest priority alarm in ACTIVE status. After acknowlegment if there are any unacknowleged alarms we should show next unacknowledged alarm etc. When all the alarms in active status got acknowledged we need to show them in a cycle with some delay (10 secconds - it should be a setting). We should also turn on one of the LEDs - Red for CRITICAL, Yellow for HIGH and Blue for MEDIUM priority.

So, all the alarms should be sorted by priority and status and the loud notification should act according the groups which are not empty. We should start to display alerms in a cycle when all the alarms got acknowledged. We should have settings for the scenario of each alarm priority. We should be able to move acknowledged alarm to active by timer.

This all should be done by TemperatureController class or a new class if it is advisable.

-------- [ Separator ] ------

File Name: config.yaml
Size: 1.51 KB
Code:
Wifi settings:
  - st_ssid:
      label: WiFi SSID
      default: ''
  - st_pass:
      label: WiFi Password
      default: ''
  - host_name:
      label: Device Hostname
      default: 'temp-monitor-{mac}'

Device settings:
  - device_id:
      label: Device ID
      type: number
      min: 1
      max: 9999
      default: 1000
  - firmware_version:
      label: Firmware Version
      default: '1.0'
      readonly: true
  - measurement_period:
      label: Measurement Period (seconds)
      type: number
      min: 1
      max: 3600
      default: 10

Modbus settings:
  - modbus_enabled:
      label: Enable Modbus RTU
      checked: true
  - modbus_address:
      label: Modbus Device Address
      type: number
      min: 1
      max: 247
      default: 1
  - modbus_baud_rate:
      label: Baud Rate
      options: '4800', '9600', '19200', '38400', '57600', '115200'
      default: '9600'
  - rs485_rx_pin:
      label: RS485 RX Pin
      type: number
      min: 0
      max: 39
      default: 22
  - rs485_tx_pin:
      label: RS485 TX Pin
      type: number
      min: 0
      max: 39
      default: 23
  - rs485_de_pin:
      label: RS485 DE/RE Pin
      type: number
      min: 0
      max: 39
      default: 18

Sensor settings:
  - onewire_pin:
      label: OneWire Bus Pin
      type: number
      min: 0
      max: 39
      default: 4
  - auto_discover:
      label: Auto-discover sensors on startup
      checked: true
  - reset_min_max:
      label: Reset Min/Max Values
      type: button
      attribs: onClick="resetMinMax()"

-------- [ Separator ] ------

File Name: data/alarm-config.html
Size: 21.38 KB
Code:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temperature Controller - Alarm Configuration</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
            color: #343a40;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        nav {
            margin-bottom: 30px;
            padding: 15px;
            background: linear-gradient(135deg, #2196F3, #1976D2);
            border-radius: 8px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        nav a {
            color: white;
            text-decoration: none;
            padding: 10px 15px;
            border-radius: 6px;
            font-weight: 500;
            transition: background-color 0.3s;
        }
        
        nav a:hover, nav a.active {
            background: rgba(255,255,255,0.2);
        }
        
        h1 {
            color: #2196F3;
            margin-bottom: 10px;
            font-size: 2.2em;
            font-weight: 300;
        }
        
        .subtitle {
            color: #6c757d;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        
        .controls {
            margin-bottom: 25px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            border-left: 4px solid #2196F3;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: #2196F3;
            color: white;
        }
        
        .btn-primary:hover {
            background: #1976D2;
            transform: translateY(-1px);
        }
        
        .btn-success {
            background: #4CAF50;
            color: white;
        }
        
        .btn-success:hover {
            background: #45a049;
            transform: translateY(-1px);
        }
        
        .btn-warning {
            background: #FF9800;
            color: white;
        }
        
        .btn-warning:hover {
            background: #F57C00;
            transform: translateY(-1px);
        }
        
        .table-container {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border: 1px solid #dee2e6;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        thead th {
            background: linear-gradient(135deg, #343a40, #495057);
            color: white;
            padding: 15px 10px;
            text-align: center;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        tbody td {
            padding: 12px 10px;
            text-align: center;
            border-bottom: 1px solid #dee2e6;
            vertical-align: middle;
        }
        
        tbody tr:hover {
            background-color: #f8f9fa;
        }
        
        .point-name {
            font-weight: 600;
            color: #2196F3;
        }
        
        .temp-display {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            padding: 6px 12px;
            border-radius: 4px;
            background: #e3f2fd;
            color: #1976d2;
        }
        
        .temp-normal {
            background: #e8f5e8;
            color: #2e7d32;
        }
        
        .temp-warning {
            background: #fff3e0;
            color: #ef6c00;
        }
        
        .temp-danger {
            background: #ffebee;
            color: #c62828;
        }
        
        .input-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .threshold-input {
            width: 80px;
            padding: 6px 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            text-align: center;
            font-size: 13px;
        }
        
        .threshold-input:focus {
            border-color: #2196F3;
            outline: none;
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
        }
        
        .priority-select {
            width: 100px;
            padding: 6px 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .priority-select:focus {
            border-color: #2196F3;
            outline: none;
        }
        
        .priority-disabled { background: #f8f9fa; color: #6c757d; }
        .priority-low { background: #e8f5e8; color: #2e7d32; }
        .priority-medium { background: #fff3e0; color: #ef6c00; }
        .priority-high { background: #ffebee; color: #c62828; }
        .priority-critical { background: #3f1a1a; color: white; }
        
        .sensor-status {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }
        
        .sensor-bound {
            background: #e8f5e8;
            color: #2e7d32;
        }
        
        .sensor-unbound {
            background: #ffebee;
            color: #c62828;
        }
        
        .loading {
            text-align: center;
            padding: 50px;
            color: #6c757d;
        }
        
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #2196F3;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .status-message {
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-weight: 500;
        }
        
        .status-success {
            background: #e8f5e8;
            color: #2e7d32;
            border-left: 4px solid #4CAF50;
        }
        
        .status-error {
            background: #ffebee;
            color: #c62828;
            border-left: 4px solid #f44336;
        }
        
        .status-info {
            background: #e3f2fd;
            color: #1976d2;
            border-left: 4px solid #2196F3;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            table {
                font-size: 12px;
            }
            
            .threshold-input {
                width: 60px;
            }
            
            .priority-select {
                width: 80px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="/dashboard.html">🏠 Dashboard</a>
            <a href="/points.html">📍 Points</a>
            <a href="/sensors.html">🌡️ Sensors</a>
            <a href="/alarms.html">🚨 Active Alarms</a>
            <a href="/alarm-config.html" class="active">⚙️ Alarm Config</a>
            <a href="/alarm-history.html">📊 History</a>
            <a href="/event-logs.html">📝 Event Logs</a>
            <a href="/config">🔧 System Config</a>
        </nav>

        <h1>Alarm Configuration</h1>
        <p class="subtitle">Configure alarm thresholds, priorities, and hysteresis for all measurement points</p>

        <div id="statusMessage" style="display: none;"></div>

        <div class="controls">
            <button class="btn btn-primary" onclick="loadConfiguration()">
                🔄 Refresh Configuration
            </button>
            <button class="btn btn-success" onclick="applyAllChanges()">
                ✅ Apply All Changes
            </button>
            <button class="btn btn-warning" onclick="resetToDefaults()">
                🔄 Reset to Defaults
            </button>
            <span style="margin-left: auto; color: #6c757d; font-size: 13px;">
                Changes are saved automatically when you click "Apply All Changes"
            </span>
        </div>

        <div class="table-container">
            <div id="loading" class="loading">
                <div class="spinner"></div>
                Loading alarm configuration...
            </div>
            
            <table id="configTable" style="display: none;">
                <thead>
                    <tr>
                        <th>Point</th>
                        <th>Name</th>
                        <th>Current Temp</th>
                        <th>Sensor Status</th>
                        <th>Low Threshold</th>
                        <th>Low Priority</th>
                        <th>High Threshold</th>
                        <th>High Priority</th>
                        <th>Error Priority</th>
                        <th>Hysteresis</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="configTableBody">
                    <!-- Dynamic content will be inserted here -->
                </tbody>
            </table>
        </div>
    </div>

    <script>
        let configData = [];
        let hasUnsavedChanges = false;

        // Load configuration on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadConfiguration();
        });

        async function loadConfiguration() {
            try {
                showLoading(true);
                showStatus('Loading alarm configuration...', 'info');
                
                const response = await fetch('/api/alarm-config');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                configData = data.points || [];
                
                displayConfiguration();
                showStatus(`Loaded configuration for ${configData.length} measurement points`, 'success');
                
            } catch (error) {
                console.error('Error loading configuration:', error);
                showStatus('Error loading alarm configuration: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        function displayConfiguration() {
            const tbody = document.getElementById('configTableBody');
            tbody.innerHTML = '';

            if (configData.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="11" style="text-align: center; padding: 40px; color: #6c757d;">
                            No measurement points found
                        </td>
                    </tr>
                `;
                return;
            }

            configData.forEach(point => {
                const row = createConfigurationRow(point);
                tbody.appendChild(row);
            });
        }

        function createConfigurationRow(point) {
            const row = document.createElement('tr');
            
            // Determine temperature status
            const tempClass = getTempStatusClass(point.currentTemp, point.lowThreshold, point.highThreshold);
            
            row.innerHTML = `
                <td><strong>${point.address}</strong></td>
                <td class="point-name">
                    <input type="text" value="${point.name || 'Point ' + point.address}" 
                           style="border: none; background: transparent; font-weight: 600; color: #2196F3; width: 100%;"
                           onchange="updatePointConfig(${point.address}, 'name', this.value)">
                </td>
                <td>
                    <span class="temp-display ${tempClass}">
                        ${point.currentTemp !== null ? point.currentTemp.toFixed(1) + '°C' : 'N/A'}
                    </span>
                </td>
                <td>
                    <span class="sensor-status ${point.sensorBound ? 'sensor-bound' : 'sensor-unbound'}">
                        ${point.sensorBound ? '✅ Bound' : '❌ Unbound'}
                    </span>
                </td>
                <td>
                    <input type="number" class="threshold-input" 
                           value="${point.lowThreshold || 0}" step="0.1"
                           onchange="updatePointConfig(${point.address}, 'lowThreshold', parseFloat(this.value))">
                </td>
                <td>
                    <select class="priority-select priority-${getPriorityClass(point.lowPriority)}"
                            onchange="updatePointConfig(${point.address}, 'lowPriority', parseInt(this.value)); this.className = 'priority-select priority-' + getPriorityClass(parseInt(this.value))">
                        ${generatePriorityOptions(point.lowPriority)}
                    </select>
                </td>
                <td>
                    <input type="number" class="threshold-input" 
                           value="${point.highThreshold || 50}" step="0.1"
                           onchange="updatePointConfig(${point.address}, 'highThreshold', parseFloat(this.value))">
                </td>
                <td>
                    <select class="priority-select priority-${getPriorityClass(point.highPriority)}"
                            onchange="updatePointConfig(${point.address}, 'highPriority', parseInt(this.value)); this.className = 'priority-select priority-' + getPriorityClass(parseInt(this.value))">
                        ${generatePriorityOptions(point.highPriority)}
                    </select>
                </td>
                <td>
                    <select class="priority-select priority-${getPriorityClass(point.errorPriority)}"
                            onchange="updatePointConfig(${point.address}, 'errorPriority', parseInt(this.value)); this.className = 'priority-select priority-' + getPriorityClass(parseInt(this.value))">
                        ${generatePriorityOptions(point.errorPriority)}
                    </select>
                </td>
                <td>
                    <input type="number" class="threshold-input" 
                           value="${point.hysteresis || 2}" step="0.1" min="0"
                           onchange="updatePointConfig(${point.address}, 'hysteresis', parseFloat(this.value))">
                </td>
                <td>
                    <button class="btn btn-warning" style="font-size: 11px; padding: 4px 8px;" 
                            onclick="resetPointToDefaults(${point.address})">
                        Reset
                    </button>
                </td>
            `;
            
            return row;
        }

        function generatePriorityOptions(selectedValue) {
            const priorities = [
                { value: 0, label: 'Disabled' },
                { value: 1, label: 'Low' },
                { value: 2, label: 'Medium' },
                { value: 3, label: 'High' },
                { value: 4, label: 'Critical' }
            ];
            
            return priorities.map(p => 
                `<option value="${p.value}" ${p.value === selectedValue ? 'selected' : ''}>${p.label}</option>`
            ).join('');
        }

        function getPriorityClass(priority) {
            const classes = ['disabled', 'low', 'medium', 'high', 'critical'];
            return classes[priority] || 'disabled';
        }

        function getTempStatusClass(temp, low, high) {
            if (temp === null) return '';
            if (temp < low || temp > high) return 'temp-danger';
            if (temp < low + 5 || temp > high - 5) return 'temp-warning';
            return 'temp-normal';
        }

        function updatePointConfig(address, field, value) {
            const point = configData.find(p => p.address === address);
            if (point) {
                point[field] = value;
                hasUnsavedChanges = true;
                
                // Update temperature status if threshold changed
                if (field === 'lowThreshold' || field === 'highThreshold') {
                    const row = event.target.closest('tr');
                    const tempDisplay = row.querySelector('.temp-display');
                    if (tempDisplay && point.currentTemp !== null) {
                        tempDisplay.className = 'temp-display ' + getTempStatusClass(point.currentTemp, point.lowThreshold, point.highThreshold);
                    }
                }
            }
        }

        async function applyAllChanges() {
            if (!hasUnsavedChanges) {
                showStatus('No changes to apply', 'info');
                return;
            }

            try {
                showStatus('Applying configuration changes...', 'info');
                
                const response = await fetch('/api/alarm-config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        changes: configData.map(point => ({
                            address: point.address,
                            name: point.name,
                            lowThreshold: point.lowThreshold,
                            highThreshold: point.highThreshold,
                            lowPriority: point.lowPriority,
                            highPriority: point.highPriority,
                            errorPriority: point.errorPriority,
                            hysteresis: point.hysteresis
                        }))
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                showStatus('Configuration applied successfully!', 'success');
                hasUnsavedChanges = false;
                
                // Reload to get fresh data
                setTimeout(loadConfiguration, 1000);
                
            } catch (error) {
                console.error('Error applying configuration:', error);
                showStatus('Error applying configuration: ' + error.message, 'error');
            }
        }

        function resetPointToDefaults(address) {
            const point = configData.find(p => p.address === address);
            if (point) {
                point.lowThreshold = 5;
                point.highThreshold = 50;
                point.lowPriority = 2; // Medium
                point.highPriority = 3; // High
                point.errorPriority = 3; // High
                point.hysteresis = 2;
                
                hasUnsavedChanges = true;
                displayConfiguration();
                showStatus(`Reset Point ${address} to default values`, 'info');
            }
        }

        function resetToDefaults() {
            if (confirm('Are you sure you want to reset ALL points to default alarm settings?')) {
                configData.forEach(point => {
                    point.lowThreshold = 5;
                    point.highThreshold = 50;
                    point.lowPriority = 2; // Medium
                    point.highPriority = 3; // High
                    point.errorPriority = 3; // High
                    point.hysteresis = 2;
                });
                
                hasUnsavedChanges = true;
                displayConfiguration();
                showStatus('All points reset to default values. Click "Apply All Changes" to save.', 'info');
            }
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
            document.getElementById('configTable').style.display = show ? 'none' : 'table';
        }

        function showStatus(message, type) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.textContent = message;
            statusDiv.className = `status-message status-${type}`;
            statusDiv.style.display = 'block';
            
            // Auto-hide after 5 seconds for success/info messages
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }

        // Warn about unsaved changes when leaving the page
        window.addEventListener('beforeunload', function(e) {
            if (hasUnsavedChanges) {
                e.preventDefault();
                e.returnValue = '';
            }
        });
    </script>
</body>
</html>
-------- [ Separator ] ------

File Name: data/alarm-history.html
Size: 22.26 KB
Code:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temperature Controller - Alarm History</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        nav {
            margin-bottom: 20px;
            padding: 10px;
            background: #007bff;
            border-radius: 5px;
        }
        nav a {
            color: white;
            text-decoration: none;
            margin-right: 15px;
            padding: 5px 10px;
            border-radius: 3px;
        }
        nav a:hover {
            background: rgba(255,255,255,0.2);
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .controls button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-success {
            background-color: #28a745;
            color: white;
        }
        .btn-warning {
            background-color: #ffc107;
            color: black;
        }
        .btn-danger {
            background-color: #dc3545;
            color: white;
        }
        .btn:hover {
            opacity: 0.8;
        }
        .filter-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .filter-group label {
            font-weight: bold;
            margin-right: 5px;
        }
        .filter-group select, .filter-group input {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        .date-range {
            display: flex;
            gap: 10px;
            align-items: center;
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        th:hover {
            background-color: #e9ecef;
        }
        th.sortable::after {
            content: " ↕";
            color: #999;
            font-size: 12px;
        }
        th.sort-asc::after {
            content: " ↑";
            color: #007bff;
            font-weight: bold;
        }
        th.sort-desc::after {
            content: " ↓";
            color: #007bff;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .priority-critical {
            background-color: #f8d7da;
            color: #721c24;
            font-weight: bold;
        }
        .priority-high {
            background-color: #ffeaa7;
            color: #856404;
            font-weight: bold;
        }
        .priority-medium {
            background-color: #d1ecf1;
            color: #0c5460;
        }
        .priority-low {
            background-color: #d4edda;
            color: #155724;
        }
        .alarm-type {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .type-high-temp {
            background-color: #ff6b6b;
            color: white;
        }
        .type-low-temp {
            background-color: #4ecdc4;
            color: white;
        }
        .type-sensor-error {
            background-color: #ffe66d;
            color: black;
        }
        .type-sensor-disconnected {
            background-color: #a8e6cf;
            color: black;
        }
        .no-history {
            text-align: center;
            padding: 40px;
            color: #6c757d;
            font-style: italic;
        }
        .timestamp {
            font-size: 12px;
            color: #6c757d;
        }
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
        }
        .pagination button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            border-radius: 4px;
        }
        .pagination button:hover {
            background: #f8f9fa;
        }
        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .pagination .current-page {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        .state-transition {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .state-arrow {
            color: #6c757d;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="/dashboard.html">Home</a>
            <a href="/sensors.html">Sensors</a>
            <a href="/points.html">Points</a>
            <a href="/alarms.html">Alarms</a>
            <a href="/alarm-history.html">Alarm History</a>
            <a href="/event-logs.html">Event Logs</a>
            <a href="/config">Configuration</a>
        </nav>

        <h1>Alarm History</h1>

        <!-- Controls -->
        <div class="controls">
            <div class="date-range">
                <label>Date Range:</label>
                <input type="date" id="startDate">
                <span>to</span>
                <input type="date" id="endDate">
                <button class="btn btn-primary" onclick="loadHistory()">🔍 Load History</button>
            </div>
            
            <button class="btn btn-success" onclick="exportHistory()">📥 Export CSV</button>
            
            <div class="filter-group">
                <label>Filter by Point:</label>
                <select id="pointFilter" onchange="filterTable()">
                    <option value="">All Points</option>
                </select>
            </div>

            <div class="filter-group">
                <label>Filter by Type:</label>
                <select id="typeFilter" onchange="filterTable()">
                    <option value="">All Types</option>
                    <option value="HIGH_TEMP">High Temperature</option>
                    <option value="LOW_TEMP">Low Temperature</option>
                    <option value="SENSOR_ERROR">Sensor Error</option>
                    <option value="DISCONNECTED">Sensor Disconnected</option>
                </select>
            </div>

            <div class="filter-group">
                <label>Filter by Priority:</label>
                <select id="priorityFilter" onchange="filterTable()">
                    <option value="">All Priorities</option>
                    <option value="CRITICAL">Critical</option>
                    <option value="HIGH">High</option>
                    <option value="MEDIUM">Medium</option>
                    <option value="LOW">Low</option>
                </select>
            </div>

            <div class="filter-group">
                <label>Filter by State:</label>
                <select id="stateFilter" onchange="filterTable()">
                    <option value="">All States</option>
                    <option value="NEW">New</option>
                    <option value="ACTIVE">Active</option>
                    <option value="ACKNOWLEDGED">Acknowledged</option>
                    <option value="CLEARED">Cleared</option>
                    <option value="RESOLVED">Resolved</option>
                </select>
            </div>
        </div>

        <!-- History Table -->
        <table id="historyTable">
            <thead>
                <tr>
                    <th class="sortable" onclick="sortTable(0)">Timestamp</th>
                    <th class="sortable" onclick="sortTable(1)">Point</th>
                    <th class="sortable" onclick="sortTable(2)">Point Name</th>
                    <th class="sortable" onclick="sortTable(3)">Type</th>
                    <th class="sortable" onclick="sortTable(4)">Priority</th>
                    <th class="sortable" onclick="sortTable(5)">State Change</th>
                    <th class="sortable" onclick="sortTable(6)">Temperature</th>
                    <th class="sortable" onclick="sortTable(7)">Threshold</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td colspan="8" class="no-history">Select a date range and click "Load History" to view alarm events</td>
                </tr>
            </tbody>
        </table>

        <!-- Pagination -->
        <div class="pagination" id="pagination" style="display: none;">
            <button id="prevPage" onclick="changePage(-1)">← Previous</button>
            <span id="pageInfo">Page 1 of 1</span>
            <button id="nextPage" onclick="changePage(1)">Next →</button>
        </div>
    </div>

    <script>
        let historyData = [];
        let filteredData = [];
        let sortColumn = -1;
        let sortDirection = 'asc';
        let currentPage = 1;
        const itemsPerPage = 100;

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            // Set default date range (last 7 days)
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 7);
            
            document.getElementById('endDate').value = endDate.toISOString().split('T')[0];
            document.getElementById('startDate').value = startDate.toISOString().split('T')[0];
            
            loadPointsForFilter();
        });

        // Load points for filter dropdown
        async function loadPointsForFilter() {
            try {
                const response = await fetch('/api/points');
                const data = await response.json();
                const pointFilter = document.getElementById('pointFilter');
                
                // Clear existing options except "All Points"
                pointFilter.innerHTML = '<option value="">All Points</option>';
                
                if (data.points) {
                    data.points.forEach(point => {
                        const option = document.createElement('option');
                        option.value = point.address;
                        option.textContent = `${point.address} - ${point.name || 'Unnamed'}`;
                        pointFilter.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Error loading points:', error);
            }
        }

        // Load alarm history from API
        async function loadHistory() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            if (!startDate || !endDate) {
                alert('Please select both start and end dates');
                return;
            }
            
            if (new Date(startDate) > new Date(endDate)) {
                alert('Start date must be before end date');
                return;
            }

            try {
                const response = await fetch(`/api/alarm-history?start=${startDate}&end=${endDate}`);
                const data = await response.json();
                
                if (data.success) {
                    historyData = data.history || [];
                    currentPage = 1;
                    displayHistory();
                } else {
                    throw new Error(data.error || 'Failed to load history');
                }
            } catch (error) {
                console.error('Error loading alarm history:', error);
                document.querySelector('#historyTable tbody').innerHTML = 
                    '<tr><td colspan="8" class="no-history">Error loading alarm history: ' + error.message + '</td></tr>';
            }
        }

        // Display history in table
        function displayHistory() {
            const tbody = document.querySelector('#historyTable tbody');
            
            if (historyData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" class="no-history">No alarm history found for the selected date range</td></tr>';
                document.getElementById('pagination').style.display = 'none';
                return;
            }

            // Apply filters
            filterTable();
        }

        // Create table row for history entry
        function createHistoryRow(entry) {
            const row = document.createElement('tr');
            
            row.innerHTML = `
                <td><span class="timestamp">${entry.timestamp}</span></td>
                <td>${entry.pointNumber}</td>
                <td>${entry.pointName || 'Unknown'}</td>
                <td><span class="alarm-type ${getTypeClass(entry.alarmType)}">${entry.alarmType}</span></td>
                <td><span class="priority-${entry.alarmPriority.toLowerCase()}">${entry.alarmPriority}</span></td>
                <td>
                    <div class="state-transition">
                        <span class="status-${entry.previousState.toLowerCase()}">${entry.previousState}</span>
                        <span class="state-arrow">→</span>
                        <span class="status-${entry.newState.toLowerCase()}">${entry.newState}</span>
                    </div>
                </td>
                <td>${entry.currentTemperature !== undefined ? entry.currentTemperature + '°C' : 'N/A'}</td>
                <td>${entry.threshold !== undefined ? entry.threshold + '°C' : 'N/A'}</td>
            `;
            
            // Set data attributes for filtering
            row.dataset.point = entry.pointNumber;
            row.dataset.type = entry.alarmType;
            row.dataset.priority = entry.alarmPriority;
            row.dataset.previousState = entry.previousState;
            row.dataset.newState = entry.newState;
            
            return row;
        }

        // Helper functions
        function getTypeClass(type) {
            const typeClasses = {
                'HIGH_TEMP': 'type-high-temp',
                'LOW_TEMP': 'type-low-temp',
                'SENSOR_ERROR': 'type-sensor-error',
                'DISCONNECTED': 'type-sensor-disconnected'
            };
            return typeClasses[type] || '';
        }

        // Filter table function
        function filterTable() {
            const pointFilter = document.getElementById('pointFilter').value;
            const typeFilter = document.getElementById('typeFilter').value;
            const priorityFilter = document.getElementById('priorityFilter').value;
            const stateFilter = document.getElementById('stateFilter').value;
            
            filteredData = historyData.filter(entry => {
                const pointMatch = !pointFilter || entry.pointNumber == pointFilter;
                const typeMatch = !typeFilter || entry.alarmType === typeFilter;
                const priorityMatch = !priorityFilter || entry.alarmPriority === priorityFilter;
                const stateMatch = !stateFilter || entry.previousState === stateFilter || entry.newState === stateFilter;
                
                return pointMatch && typeMatch && priorityMatch && stateMatch;
            });
            
            currentPage = 1;
            displayFilteredData();
        }

        // Display filtered and paginated data
        function displayFilteredData() {
            const tbody = document.querySelector('#historyTable tbody');
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageData = filteredData.slice(startIndex, endIndex);
            
            if (pageData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" class="no-history">No alarm history matches the current filters</td></tr>';
                document.getElementById('pagination').style.display = 'none';
                return;
            }
            
            tbody.innerHTML = '';
            pageData.forEach(entry => {
                tbody.appendChild(createHistoryRow(entry));
            });
            
            // Update pagination
            const totalPages = Math.ceil(filteredData.length / itemsPerPage);
            if (totalPages > 1) {
                document.getElementById('pagination').style.display = 'flex';
                document.getElementById('pageInfo').textContent = `Page ${currentPage} of ${totalPages} (${filteredData.length} entries)`;
                document.getElementById('prevPage').disabled = currentPage === 1;
                document.getElementById('nextPage').disabled = currentPage === totalPages;
            } else {
                document.getElementById('pagination').style.display = 'none';
            }
        }

        // Pagination functions
        function changePage(direction) {
            const totalPages = Math.ceil(filteredData.length / itemsPerPage);
            const newPage = currentPage + direction;
            
            if (newPage >= 1 && newPage <= totalPages) {
                currentPage = newPage;
                displayFilteredData();
            }
        }

        // Table sorting function
        function sortTable(columnIndex) {
            const table = document.getElementById('historyTable');
            
            // Update sort direction
            if (sortColumn === columnIndex) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortDirection = 'asc';
                sortColumn = columnIndex;
            }

            // Clear previous sort indicators
            table.querySelectorAll('th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });

            // Add current sort indicator
            const currentHeader = table.querySelector(`th:nth-child(${columnIndex + 1})`);
            currentHeader.classList.add(sortDirection === 'asc' ? 'sort-asc' : 'sort-desc');

            // Sort the filtered data
            filteredData.sort((a, b) => {
                let aValue, bValue;
                
                switch (columnIndex) {
                    case 0: // Timestamp
                        aValue = new Date(a.timestamp);
                        bValue = new Date(b.timestamp);
                        break;
                    case 1: // Point
                        aValue = a.pointNumber;
                        bValue = b.pointNumber;
                        break;
                    case 2: // Point Name
                        aValue = a.pointName || '';
                        bValue = b.pointName || '';
                        break;
                    case 3: // Type
                        aValue = a.alarmType;
                        bValue = b.alarmType;
                        break;
                    case 4: // Priority
                        aValue = a.alarmPriority;
                        bValue = b.alarmPriority;
                        break;
                    case 5: // State Change
                        aValue = a.newState;
                        bValue = b.newState;
                        break;
                    case 6: // Temperature
                        aValue = a.currentTemperature || 0;
                        bValue = b.currentTemperature || 0;
                        break;
                    case 7: // Threshold
                        aValue = a.threshold || 0;
                        bValue = b.threshold || 0;
                        break;
                    default:
                        return 0;
                }
                
                let comparison = 0;
                if (typeof aValue === 'number' && typeof bValue === 'number') {
                    comparison = aValue - bValue;
                } else if (aValue instanceof Date && bValue instanceof Date) {
                    comparison = aValue - bValue;
                } else {
                    comparison = String(aValue).localeCompare(String(bValue));
                }
                
                return sortDirection === 'asc' ? comparison : -comparison;
            });
            
            displayFilteredData();
        }

        // Export history to CSV
        async function exportHistory() {
            if (filteredData.length === 0) {
                alert('No data to export. Please load history first.');
                return;
            }
            
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            try {
                const response = await fetch(`/api/alarm-history/export?start=${startDate}&end=${endDate}`, {
                    method: 'GET'
                });
                
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `alarm_history_${startDate}_to_${endDate}.csv`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                } else {
                    throw new Error('Export failed');
                }
            } catch (error) {
                console.error('Error exporting history:', error);
                alert('Failed to export history: ' + error.message);
            }
        }
    </script>
</body>
</html>
-------- [ Separator ] ------

File Name: data/alarms.html
Size: 21.69 KB
Code:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temperature Controller - Alarms</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        nav {
            margin-bottom: 20px;
            padding: 10px;
            background: #007bff;
            border-radius: 5px;
        }
        nav a {
            color: white;
            text-decoration: none;
            margin-right: 15px;
            padding: 5px 10px;
            border-radius: 3px;
        }
        nav a:hover {
            background: rgba(255,255,255,0.2);
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .controls button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-success {
            background-color: #28a745;
            color: white;
        }
        .btn-warning {
            background-color: #ffc107;
            color: black;
        }
        .btn-danger {
            background-color: #dc3545;
            color: white;
        }
        .btn:hover {
            opacity: 0.8;
        }
        .filter-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .filter-group label {
            font-weight: bold;
            margin-right: 5px;
        }
        .filter-group select {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        th:hover {
            background-color: #e9ecef;
        }
        th.sortable::after {
            content: " ↕";
            color: #999;
            font-size: 12px;
        }
        th.sort-asc::after {
            content: " ↑";
            color: #007bff;
            font-weight: bold;
        }
        th.sort-desc::after {
            content: " ↓";
            color: #007bff;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .status-new {
            color: #6f42c1;
            font-weight: bold;
        }
        .status-active {
            color: #dc3545;
            font-weight: bold;
        }
        .status-acknowledged {
            color: #fd7e14;
            font-weight: bold;
        }
        .status-cleared {
            color: #20c997;
            font-weight: bold;
        }
        .status-resolved {
            color: #6c757d;
        }
        .priority-critical {
            background-color: #f8d7da;
            color: #721c24;
            font-weight: bold;
        }
        .priority-high {
            background-color: #ffeaa7;
            color: #856404;
            font-weight: bold;
        }
        .priority-medium {
            background-color: #d1ecf1;
            color: #0c5460;
        }
        .priority-low {
            background-color: #d4edda;
            color: #155724;
        }
        .alarm-type {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .type-high-temp {
            background-color: #ff6b6b;
            color: white;
        }
        .type-low-temp {
            background-color: #4ecdc4;
            color: white;
        }
        .type-sensor-error {
            background-color: #ffe66d;
            color: black;
        }
        .type-sensor-disconnected {
            background-color: #a8e6cf;
            color: black;
        }
        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .stat-card {
            flex: 1;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            color: white;
            font-weight: bold;
        }
        .stat-critical {
            background-color: #dc3545;
        }
        .stat-high {
            background-color: #fd7e14;
        }
        .stat-medium {
            background-color: #ffc107;
            color: black;
        }
        .stat-low {
            background-color: #28a745;
        }
        .no-alarms {
            text-align: center;
            padding: 40px;
            color: #6c757d;
            font-style: italic;
        }
        .timestamp {
            font-size: 12px;
            color: #6c757d;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="/dashboard.html">Home</a>
            <a href="/sensors.html">Sensors</a>
            <a href="/points.html">Points</a>
            <a href="/alarms.html">Alarms</a>
            <a href="/alarm-history.html">Alarm History</a>
            <a href="/event-logs.html">Event Logs</a>
            <a href="/config">Configuration</a>
        </nav>

        <h1>Alarm Management</h1>

        <!-- Statistics -->
        <div class="stats">
            <div class="stat-card stat-critical">
                <div id="criticalCount">0</div>
                <div>Critical</div>
            </div>
            <div class="stat-card stat-high">
                <div id="highCount">0</div>
                <div>High</div>
            </div>
            <div class="stat-card stat-medium">
                <div id="mediumCount">0</div>
                <div>Medium</div>
            </div>
            <div class="stat-card stat-low">
                <div id="lowCount">0</div>
                <div>Low</div>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <button class="btn btn-primary" onclick="refreshAlarms()">🔄 Refresh</button>
            <button class="btn btn-success" onclick="acknowledgeAllActive()">✓ Acknowledge All Active</button>
            <button class="btn btn-warning" onclick="clearResolved()">🗑 Clear Resolved</button>
            
            <div class="filter-group">
                <label>Filter by Status:</label>
                <select id="statusFilter" onchange="filterTable()">
                    <option value="">All Statuses</option>
                    <option value="NEW">New</option>
                    <option value="CLEARED">Cleared</option>
                    <option value="RESOLVED">Resolved</option>
                    <option value="ACKNOWLEDGED">Acknowledged</option>
                    <option value="ACTIVE">Active</option>


                </select>
            </div>

            <div class="filter-group">
                <label>Filter by Priority:</label>
                <select id="priorityFilter" onchange="filterTable()">
                    <option value="">All Priorities</option>
                    <option value="3">Critical</option>
                    <option value="2">High</option>
                    <option value="1">Medium</option>
                    <option value="0">Low</option>
                </select>
            </div>

            <div class="filter-group">
                <label>Filter by Type:</label>
                <select id="typeFilter" onchange="filterTable()">
                    <option value="">All Types</option>
                    <option value="0">High Temperature</option>
                    <option value="1">Low Temperature</option>
                    <option value="2">Sensor Error</option>
                    <option value="3">Sensor Disconnected</option>
                </select>
            </div>
        </div>

        <!-- Alarms Table -->
        <table id="alarmsTable">
            <thead>
                <tr>
                    <th class="sortable" onclick="sortTable(0)">Point</th>
                    <th class="sortable" onclick="sortTable(1)">Point Name</th>
                    <th class="sortable" onclick="sortTable(2)">Type</th>
                    <th class="sortable" onclick="sortTable(3)">Priority</th>
                    <th class="sortable" onclick="sortTable(4)">Status</th>
                    <th class="sortable" onclick="sortTable(5)">Current Temp</th>
                    <th class="sortable" onclick="sortTable(6)">Threshold</th>
                    <th class="sortable" onclick="sortTable(7)">Created</th>
                    <th class="sortable" onclick="sortTable(8)">Acknowledged</th>
                    <th class="sortable" onclick="sortTable(9)">Time Left</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td colspan="11" class="no-alarms">Loading alarms...</td>
                </tr>
            </tbody>
        </table>
    </div>

    <script>
        const UPDATE_INTERVAL = 5000;
        let alarmsData = [];
        let sortColumn = -1;
        let sortDirection = 'asc';

        // Load alarms on page load
        document.addEventListener('DOMContentLoaded', function() {
            refreshAlarms();
            setInterval(refreshAlarms, UPDATE_INTERVAL); // Auto-refresh every 30 seconds
        });

        // Load alarms from API
        async function refreshAlarms() {
            try {
                const response = await fetch('/api/alarms');
                const data = await response.json();
                alarmsData = data.alarms || [];
                updateStatistics();
                displayAlarms();
            } catch (error) {
                console.error('Error loading alarms:', error);
                document.querySelector('#alarmsTable tbody').innerHTML = 
                    '<tr><td colspan="10" class="no-alarms">Error loading alarms</td></tr>';
            }
        }

        // Update statistics
        function updateStatistics() {
            const stats = {
                critical: 0,
                high: 0,
                medium: 0,
                low: 0
            };

            alarmsData.forEach(alarm => {
                if (alarm.enabled && (alarm.stage === 1 || alarm.stage === 2)) { // ACTIVE or ACKNOWLEDGED
                    switch (alarm.priority) {
                        case 3: stats.critical++; break;
                        case 2: stats.high++; break;
                        case 1: stats.medium++; break;
                        case 0: stats.low++; break;
                    }
                }
            });

            document.getElementById('criticalCount').textContent = stats.critical;
            document.getElementById('highCount').textContent = stats.high;
            document.getElementById('mediumCount').textContent = stats.medium;
            document.getElementById('lowCount').textContent = stats.low;
        }

        // Display alarms in table
        
        function displayAlarms() {
            const tbody = document.querySelector('#alarmsTable tbody');
            
            if (alarmsData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="11" class="no-alarms">No alarms configured</td></tr>';
                return;
            }

            tbody.innerHTML = alarmsData.map(alarm => createAlarmRow(alarm)).join('');
            filterTable(); // Apply current filters
        }


        // Create table row for alarm
        function createAlarmRow(alarm) {
            const createdDate = new Date(alarm.timestamp).toLocaleString();
            const acknowledgedDate = alarm.acknowledgedTime ? 
                new Date(alarm.acknowledgedTime).toLocaleString() : '-';
            
            // Format time left for acknowledged alarms
            const timeLeft = formatTimeLeft(alarm.acknowledgedTimeLeft, alarm.stage);

            return `
                <tr data-priority="${alarm.priority}" data-status="${getStageText(alarm.stage)}" data-type="${alarm.type}">
                    <td>${alarm.pointAddress}</td>
                    <td>${alarm.pointName || 'Unknown'}</td>
                    <td><span class="alarm-type ${getTypeClass(alarm.type)}">${getTypeText(alarm.type)}</span></td>
                    <td><span class="priority-${getPriorityClass(alarm.priority)}">${getPriorityText(alarm.priority)}</span></td>
                    <td><span class="status-${getStageText(alarm.stage).toLowerCase()}">${getStageText(alarm.stage)}</span></td>
                    <td>${alarm.currentTemp !== undefined ? alarm.currentTemp + '°C' : 'N/A'}</td>
                    <td>${alarm.threshold !== undefined ? alarm.threshold + '°C' : 'N/A'}</td>
                    <td><span class="timestamp">${createdDate}</span></td>
                    <td><span class="timestamp">${acknowledgedDate}</span></td>
                    <td><span class="timestamp">${timeLeft}</span></td>
                    <td>
                        ${alarm.isActive && !alarm.isAcknowledged ? 
                            `<button class="btn btn-warning" onclick="acknowledgeAlarm('${alarm.configKey}')">Acknowledge</button>` : 
                            ''}
                        ${`<button class="btn btn-danger" onclick="deleteAlarm('${alarm.configKey}')">Delete</button>`}
                    </td>
                </tr>
            `;
        }


        // Helper functions
        function getTypeText(type) {
            const types = ['High Temp', 'Low Temp', 'Sensor Error', 'Disconnected'];
            return types[type] || 'Unknown';
        }

        function getTypeClass(type) {
            const classes = ['type-high-temp', 'type-low-temp', 'type-sensor-error', 'type-sensor-disconnected'];
            return classes[type] || '';
        }

        function getPriorityText(priority) {
            const priorities = ['Low', 'Medium', 'High', 'Critical'];
            return priorities[priority] || 'Unknown';
        }

        function getPriorityClass(priority) {
            const classes = ['low', 'medium', 'high', 'critical'];
            return classes[priority] || 'low';
        }

        function getStageText(stage) {
            const stages = ['NEW', 'CLEARED', 'RESOLVED', 'ACKNOWLEDGED', 'ACTIVE'];
            return stages[stage] || 'UNKNOWN';
        }

        // Table sorting function
        function sortTable(columnIndex) {
            const table = document.getElementById('alarmsTable');
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr')).filter(row => 
                !row.querySelector('.no-alarms'));

            // Update sort direction
            if (sortColumn === columnIndex) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortDirection = 'asc';
                sortColumn = columnIndex;
            }

            // Clear previous sort indicators
            table.querySelectorAll('th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });

            // Add current sort indicator
            const currentHeader = table.querySelector(`th:nth-child(${columnIndex + 1})`);
            currentHeader.classList.add(sortDirection === 'asc' ? 'sort-asc' : 'sort-desc');

            // Sort rows
            rows.sort((a, b) => {
                const aValue = a.cells[columnIndex].textContent.trim();
                const bValue = b.cells[columnIndex].textContent.trim();

                let comparison = 0;
                
                // Handle numeric columns
                if (columnIndex === 0 || columnIndex === 5 || columnIndex === 6) { // Point, Current Temp, Threshold
                    const aNum = parseFloat(aValue) || 0;
                    const bNum = parseFloat(bValue) || 0;
                    comparison = aNum - bNum;
                } else if (columnIndex === 3) { // Priority
                    const priorityOrder = { 'Critical': 3, 'High': 2, 'Medium': 1, 'Low': 0 };
                    comparison = (priorityOrder[aValue] || 0) - (priorityOrder[bValue] || 0);
                } else if (columnIndex === 7 || columnIndex === 8) { // Timestamps
                    const aDate = new Date(aValue);
                    const bDate = new Date(bValue);
                    comparison = aDate - bDate;
                } else {
                    // String comparison
                    comparison = aValue.localeCompare(bValue);
                }

                return sortDirection === 'asc' ? comparison : -comparison;
            });

            // Re-append sorted rows
            rows.forEach(row => tbody.appendChild(row));
        }

        // Filter table function
        function filterTable() {
            const statusFilter = document.getElementById('statusFilter').value;
            const priorityFilter = document.getElementById('priorityFilter').value;
            const typeFilter = document.getElementById('typeFilter').value;
            
            const rows = document.querySelectorAll('#alarmsTable tbody tr');
            
            rows.forEach(row => {
                if (row.querySelector('.no-alarms')) return;
                
                const status = row.dataset.status;
                const priority = row.dataset.priority;
                const type = row.dataset.type;
                
                const statusMatch = !statusFilter || status === statusFilter;
                const priorityMatch = !priorityFilter || priority === priorityFilter;
                const typeMatch = !typeFilter || type === typeFilter;
                
                row.style.display = (statusMatch && priorityMatch && typeMatch) ? '' : 'none';
            });
        }

        // Acknowledge alarm
        async function acknowledgeAlarm(configKey) {
            try {
                const response = await fetch('/api/alarms/acknowledge', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ configKey: configKey })
                });

                if (response.ok) {
                    refreshAlarms();
                } else {
                    alert('Error acknowledging alarm');
                }
            } catch (error) {
                console.error('Error acknowledging alarm:', error);
                alert('Error acknowledging alarm');
            }
        }

        // Acknowledge all active alarms
        async function acknowledgeAllActive() {
            if (!confirm('Acknowledge all active alarms?')) return;

            try {
                const response = await fetch('/api/alarms/acknowledge-all', {
                    method: 'POST'
                });

                if (response.ok) {
                    refreshAlarms();
                } else {
                    alert('Error acknowledging alarms');
                }
            } catch (error) {
                console.error('Error acknowledging alarms:', error);
                alert('Error acknowledging alarms');
            }
        }

        // Delete resolved alarm
        async function deleteAlarm(configKey) {
            if (!confirm('Delete this resolved alarm?')) return;

            try {
                const response = await fetch(`/api/alarms?configKey=${encodeURIComponent(configKey)}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    refreshAlarms();
                } else {
                    alert('Error deleting alarm');
                }
            } catch (error) {
                console.error('Error deleting alarm:', error);
                alert('Error deleting alarm');
            }
        }

        // Clear all resolved alarms
        async function clearResolved() {
            if (!confirm('Clear all resolved alarms?')) return;

            try {
                const response = await fetch('/api/alarms/clear-resolved', {
                    method: 'POST'
                });

                if (response.ok) {
                    refreshAlarms();
                } else {
                    alert('Error clearing resolved alarms');
                }
            } catch (error) {
                console.error('Error clearing resolved alarms:', error);
                alert('Error clearing resolved alarms');
            }
        }


        function formatTimeLeft(timeLeftMs, stage) {
            // Only show time left for acknowledged alarms
            if (stage !== 2 || !timeLeftMs || timeLeftMs <= 0) { // 2 = ACKNOWLEDGED
                return '-';
            }
            
            // Convert milliseconds to seconds
            const totalSeconds = Math.floor(timeLeftMs / 1000);
            
            // Calculate hours, minutes, and seconds
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            // Format as HH:MM:SS
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        
    </script>
</body>
</html>

-------- [ Separator ] ------

File Name: data/dashboard.html
Size: 28.41 KB
Code:
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Temperature Monitoring System</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

.status-ok {
            color: #388e3c;
            font-weight: bold;
        }
        .status-error, .status-alarm, .status-unbound {
            color: #d32f2f;
            font-weight: bold;
        }
        .status-bound {
            color: #388e3c;
            font-weight: bold;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 10;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 8% auto;
            padding: 24px;
            border: 1px solid #888;
            width: 100%;
            max-width: 400px;
            border-radius: 6px;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover,
        .close:focus {
            color: #d32f2f;
            text-decoration: none;
            cursor: pointer;
        }
        .form-group {
            margin-bottom: 18px;
        }
        .form-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .form-group input[type="text"],
        .form-group input[type="number"] {
            width: 95%;
            padding: 6px;
            font-size: 1em;
        }
        .form-actions {
            text-align: right;
        }
        .form-actions button {
            margin-left: 10px;
            padding: 5px 15px;
        }
        
        /* Use styles from index.html */
        body {
            font-family: Arial, sans-serif;
            background: #f7f7f7;
            margin: 0;
            padding: 0;
        }
        header {
            background: #3f51b5;
            color: #fff;
            padding: 1em 2em;
            text-align: center;
            font-size: 1.5em;
            letter-spacing: 2px;
        }
        nav {
            background: #263238;
            padding: 0.5em 2em;
        }
        nav a {
            color: #fff;
            text-decoration: none;
            margin-right: 2em;
            font-weight: bold;
            transition: color 0.2s;
        }
        nav a:hover {
            color: #ffeb3b;
        }
        main {
            max-width: 1200px;
            margin: 2em auto;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            padding: 2em;
        }
        h2 {
            margin-top: 1em;
            color: #3f51b5;
            font-size: 1.2em;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.25em;
        }
        .actions {
            margin-bottom: 1.5em;
        }
        button {
            background: #3f51b5;
            color: #fff;
            border: none;
            padding: 0.5em 1.2em;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            margin-right: 0.5em;
            transition: background 0.2s;
        }
        button:hover {
            background: #283593;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 2em;
        }
        th, td {
            padding: 0.6em 0.8em;
            border-bottom: 1px solid #eee;
            text-align: left;
        }
        th {
            background: #f0f4ff;
            color: #3f51b5;
        }
        tr:last-child td {
            border-bottom: none;
        }
        .status-bound {
            color: #388e3c;
            font-weight: bold;
        }
        .status-unbound {
            color: #b71c1c;
            font-weight: bold;
        }
        .rom, .chip-select {
            font-family: monospace;
            font-size: 0.98em;
            color: #333;
        }
        @media (max-width: 800px) {
            main { padding: 1em; }
            th, td { font-size: 0.95em; }
        }
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            margin-top: 0;
        }
        .navbar {
            background-color: #333;
            overflow: hidden;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        .navbar a {
            float: left;
            display: block;
            color: white;
            text-align: center;
            padding: 14px 16px;
            text-decoration: none;
        }
        .navbar a:hover {
            background-color: #ddd;
            color: black;
        }
        .dashboard {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        .card {
            flex: 1;
            min-width: 300px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            background-color: #fff;
        }
        .card h2 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #f5f5f5;
        }
        .status-label {
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>Temperature Monitoring System</header>
        <nav>
            <a href="/dashboard.html">Home</a>
            <a href="/sensors.html">Sensors</a>
            <a href="/points.html">Points</a>
            <a href="/alarms.html">Alarms</a>
            <a href="/alarm-history.html">Alarm History</a>
            <a href="/event-logs.html">Event Logs</a>
            <a href="/config">Configuration</a>
    
        </nav>
        <!-- CSV Import/Export Section -->
        <div class="csv-section" style="margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px;">
            <h3>Configuration Backup/Restore</h3>
            
            <!-- Export Button -->
            <button id="exportCsvBtn" class="btn btn-primary" style="margin-right: 10px;">
                📥 Export Configuration to CSV
            </button>
            
            <!-- Import Section -->
            <input type="file" id="csvFileInput" accept=".csv" style="display: none;">
            <button id="importCsvBtn" class="btn btn-secondary">
                📤 Import Configuration from CSV
            </button>
            
            <div id="csvStatus" style="margin-top: 10px; font-weight: bold;"></div>
        </div>

        <!-- Settings CSV Import/Export Section -->
        <div class="settings-csv-section" style="margin: 20px 0; padding: 15px; border: 1px solid #ccc; border-radius: 5px; background-color: #f9f9f9;">
            <h3>Device Settings Backup/Restore</h3>
            
            <!-- Export Button -->
            <button id="exportSettingsBtn" class="btn btn-success" style="margin-right: 10px;">
                📥 Export Device Settings to CSV
            </button>
            
            <!-- Import Section -->
            <input type="file" id="settingsFileInput" accept=".csv" style="display: none;">
            <button id="importSettingsBtn" class="btn btn-warning">
                📤 Import Device Settings from CSV
            </button>
            
            <div id="settingsStatus" style="margin-top: 10px; font-weight: bold;"></div>
            
            <div style="margin-top: 10px; font-size: 12px; color: #666;">
                <strong>Note:</strong> Device will restart automatically after importing settings to apply changes.
            </div>
        </div>


        
        <div class="dashboard">
            <div class="card">
                <h2>System Status</h2>
                <div id="system-status">
                    <p>Loading system status...</p>
                </div>
            </div>
            
            <div class="card">
                <h2>Sensor Overview</h2>
                <div id="sensor-overview">
                    <p>Loading sensor data...</p>
                </div>
            </div>
        </div>
    </div>


    <main>
    <h2>DS18B20 Points</h2>
    
        <table>
            <thead>
                <tr>
                    <th>Address</th>
                    <th>Name</th>
                    <th>Current Temp</th>
                    <th>Min Temp</th>
                    <th>Max Temp</th>
                    <th>Alarm Status</th>
                    <th>Error Status</th>

                </tr>
            </thead>
            <tbody id="dsPointsTbody">
                <tr><td colspan="11">Loading DS18B20 points...</td></tr>
            </tbody>
        </table>

        <h2>PT1000 Points</h2>
        <table>
            <thead>
                <tr>
                    <th>Address</th>
                    <th>Name</th>
                    <th>Current Temp</th>
                    <th>Min Temp</th>
                    <th>Max Temp</th>
                    <th>Alarm Status</th>
                    <th>Error Status</th>
                </tr>
            </thead>
            <tbody id="ptPointsTbody">
                <tr><td colspan="11">Loading PT1000 points...</td></tr>
            </tbody>
        </table>
    </main>

    <!-- Modal -->
    <div id="pointConfigModal" class="modal">
        <div class="modal-content">
            <span class="close" id="modalCloseBtn">&times;</span>
            <h2>Edit Point</h2>
            <form id="pointConfigForm">
                <input type="hidden" id="modalPointAddress">
                <div class="form-group">
                    <label for="modalPointName">Name</label>
                    <input type="text" id="modalPointName" required>
                </div>
                <div class="form-group">
                    <label for="modalLowAlarm">Low Alarm Threshold (°C)</label>
                    <input type="number" id="modalLowAlarm" step="0.1" required>
                </div>
                <div class="form-group">
                    <label for="modalHighAlarm">High Alarm Threshold (°C)</label>
                    <input type="number" id="modalHighAlarm" step="0.1" required>
                </div>
                <div class="form-actions">
                    <button type="submit" class="button">Save</button>
                    <button type="button" class="button" id="modalCancelBtn" style="background:#888;">Cancel</button>
                </div>
            </form>
        </div>
    </div>




    <script>

        // Auto-update interval (ms)
        const UPDATE_INTERVAL = 5000;
        // Fetch system status
        function fetchSystemStatus() {
            fetch('/api/status')
                .then(response => response.json())
                .then(data => {
                    displaySystemStatus(data);
                })
                .catch(error => {
                    console.error('Error fetching system status:', error);
                    document.getElementById('system-status').innerHTML = 
                        '<p>Error loading system status. Please try again.</p>';
                });
        }
        
        // Display system status
        function displaySystemStatus(data) {
            const container = document.getElementById('system-status');
            
            let html = '';
            html += `<div class="status-item"><span class="status-label">Device ID:</span> <span>${data.deviceId}</span></div>`;
            html += `<div class="status-item"><span class="status-label">Firmware Version:</span> <span>${(data.firmwareVersion >> 8)}.${data.firmwareVersion & 0xFF}</span></div>`;
            html += `<div class="status-item"><span class="status-label">Measurement Period:</span> <span>${data.measurementPeriod} seconds</span></div>`;
            html += `<div class="status-item"><span class="status-label">Uptime:</span> <span>${formatUptime(data.uptime)}</span></div>`;
            
            container.innerHTML = html;
        }
        
        // Format uptime in a human-readable way
        function formatUptime(seconds) {
            const days = Math.floor(seconds / 86400);
            seconds %= 86400;
            const hours = Math.floor(seconds / 3600);
            seconds %= 3600;
            const minutes = Math.floor(seconds / 60);
            seconds %= 60;
            
            let result = '';
            if (days > 0) result += `${days}d `;
            if (hours > 0 || days > 0) result += `${hours}h `;
            if (minutes > 0 || hours > 0 || days > 0) result += `${minutes}m `;
            result += `${seconds}s`;
            
            return result;
        }
        
        // Fetch sensor overview
        function fetchSensorOverview() {
            fetch('/api/sensors')
                .then(response => response.json())
                .then(data => {
                    displaySensorOverview(data);
                })
                .catch(error => {
                    console.error('Error fetching sensors:', error);
                    document.getElementById('sensor-overview').innerHTML = 
                        '<p>Error loading sensor data. Please try again.</p>';
                });
        }
        
        // Display sensor overview
        function displaySensorOverview(data) {
            const container = document.getElementById('sensor-overview');
            
            if (!data.sensors || data.sensors.length === 0) {
                container.innerHTML = '<p>No sensors found. Go to the Sensors page to discover and configure sensors.</p>';
                return;
            }
            
            let html = '';
            html += `<div class="status-item"><span class="status-label">Total Sensors:</span> <span>${data.sensors.length}</span></div>`;
            
            const ds18b20Count = data.sensors.filter(s => s.type === 'DS18B20').length;
            const pt1000Count = data.sensors.filter(s => s.type === 'PT1000').length;
            
            html += `<div class="status-item"><span class="status-label">DS18B20 Sensors:</span> <span>${ds18b20Count}</span></div>`;
            html += `<div class="status-item"><span class="status-label">PT1000 Sensors:</span> <span>${pt1000Count}</span></div>`;
            
            const alarmsCount = data.sensors.filter(s => s.alarmStatus > 0).length;
            const errorsCount = data.sensors.filter(s => s.errorStatus > 0).length;
            
            html += `<div class="status-item"><span class="status-label">Sensors in Alarm:</span> <span>${alarmsCount}</span></div>`;
            html += `<div class="status-item"><span class="status-label">Sensors with Errors:</span> <span>${errorsCount}</span></div>`;
            
            html += `<p><a href="/sensors.html">View all sensors</a></p>`;
            
            container.innerHTML = html;
        }
        
        // Load data when page loads
        document.addEventListener('DOMContentLoaded', () => {
            fetchSystemStatus();
            fetchSensorOverview();
        });
        
        // Refresh data every 5 seconds
        setInterval(() => {
            fetchSystemStatus();
            fetchSensorOverview();
        }, UPDATE_INTERVAL);



        // Helper functions for status rendering
        function getAlarmText(alarmStatus) {
            if (alarmStatus === 0) return '<span class="status-ok">OK</span>';
            const alarms = [];
            if (alarmStatus & 0x01) alarms.push('Low Temp');
            if (alarmStatus & 0x02) alarms.push('High Temp');
            return `<span class="status-alarm">${alarms.join(', ')}</span>`;
        }
        function getErrorText(errorStatus) {
            if (errorStatus === 0) return '<span class="status-ok">OK</span>';
            const errors = [];
            if (errorStatus & 0x01) errors.push('Comm');
            if (errorStatus & 0x02) errors.push('OutOfRange');
            if (errorStatus & 0x04) errors.push('Disconnected');
            return `<span class="status-error">${errors.join(', ')}</span>`;
        }
        function getSensorStatus(bound) {
            return bound
                ? '<span class="status-bound">Bound</span>'
                : '<span class="status-unbound">Unbound</span>';
        }

        // Modal logic
        const modal = document.getElementById('pointConfigModal');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        const modalCancelBtn = document.getElementById('modalCancelBtn');
        const pointConfigForm = document.getElementById('pointConfigForm');
        let currentEditPoint = null;

        function openModal(point) {
            currentEditPoint = point;
            document.getElementById('modalPointAddress').value = point.address;
            document.getElementById('modalPointName').value = point.name || '';
            document.getElementById('modalLowAlarm').value = point.lowAlarmThreshold;
            document.getElementById('modalHighAlarm').value = point.highAlarmThreshold;
            modal.style.display = "block";
        }
        function closeModal() {
            modal.style.display = "none";
            currentEditPoint = null;
        }
        modalCloseBtn.onclick = closeModal;
        modalCancelBtn.onclick = closeModal;
        window.onclick = function(event) {
            if (event.target === modal) closeModal();
        };

        // Fetch and render points
        function fetchAndRenderPoints() {
            fetch('/api/points')
                .then(res => res.json())
                .then(data => renderPointsTables(data.points))
                .catch(() => {
                    document.getElementById('dsPointsTbody').innerHTML = '<tr><td colspan="11">Failed to load points.</td></tr>';
                    document.getElementById('ptPointsTbody').innerHTML = '<tr><td colspan="11">Failed to load points.</td></tr>';
                });
        }

        function renderPointsTables(points) {
            const dsTbody = document.getElementById('dsPointsTbody');
            const ptTbody = document.getElementById('ptPointsTbody');
            dsTbody.innerHTML = '';
            ptTbody.innerHTML = '';

            const dsPoints = points.filter(p => p.type === "DS18B20");
            const ptPoints = points.filter(p => p.type === "PT1000");

            if (dsPoints.length === 0) {
                dsTbody.innerHTML = '<tr><td colspan="11">No DS18B20 points found.</td></tr>';
            } else {
                dsPoints.forEach(point => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${point.address}</td>
                        <td>${point.name || ''}</td>
                        <td>${point.currentTemp !== undefined ? point.currentTemp : ''}</td>
                        <td>${point.minTemp !== undefined ? point.minTemp : ''}</td>
                        <td>${point.maxTemp !== undefined ? point.maxTemp : ''}</td>
                        <td>${getAlarmText(point.alarmStatus)}</td>
                        <td>${getErrorText(point.errorStatus)}</td>
                       
                    `;
                    dsTbody.appendChild(row);
                });
            }

            if (ptPoints.length === 0) {
                ptTbody.innerHTML = '<tr><td colspan="11">No PT1000 points found.</td></tr>';
            } else {
                ptPoints.forEach(point => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${point.address}</td>
                        <td>${point.name || ''}</td>
                        <td>${point.currentTemp !== undefined ? point.currentTemp : ''}</td>
                        <td>${point.minTemp !== undefined ? point.minTemp : ''}</td>
                        <td>${point.maxTemp !== undefined ? point.maxTemp : ''}</td>
                        <td>${getAlarmText(point.alarmStatus)}</td>
                        <td>${getErrorText(point.errorStatus)}</td>
                      
                    `;
                    ptTbody.appendChild(row);
                });
            }
        }

        // Edit handler
        function onEditPoint(address) {
            fetch('/api/points')
                .then(res => res.json())
                .then(data => {
                    const point = data.points.find(p => p.address === address);
                    if (point) openModal(point);
                });
        }
        window.onEditPoint = onEditPoint;

        // Handle form submit
        pointConfigForm.onsubmit = function(e) {
            e.preventDefault();
            const address = parseInt(document.getElementById('modalPointAddress').value, 10);
            const name = document.getElementById('modalPointName').value;
            const lowAlarm = parseFloat(document.getElementById('modalLowAlarm').value);
            const highAlarm = parseFloat(document.getElementById('modalHighAlarm').value);

            fetch('/api/points', {
                method: 'PUT',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ address, name, lowAlarmThreshold: lowAlarm, highAlarmThreshold: highAlarm })
            })
            .then(res => {
                if (!res.ok) throw new Error('Failed to update point');
                closeModal();
                fetchAndRenderPoints();
            })
            .catch(() => alert('Failed to update point!'));
        };

        // Initial load
        setInterval(fetchAndRenderPoints, UPDATE_INTERVAL);
        window.onload = fetchAndRenderPoints();
        // Optionally, set up periodic refresh if needed
        // setInterval(fetchAndRenderPoints, 10000);

        // Export CSV functionality
        document.getElementById('exportCsvBtn').addEventListener('click', function() {
            fetch('/api/csv/export', {
                method: 'GET'
            })
            .then(response => {
                if (response.ok) {
                    return response.blob();
                }
                throw new Error('Export failed');
            })
            .then(blob => {
                // Create download link
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'temperature_config_' + new Date().toISOString().split('T')[0] + '.csv';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                
                document.getElementById('csvStatus').innerHTML = '<span style="color: green;">✓ Configuration exported successfully</span>';
            })
            .catch(error => {
                document.getElementById('csvStatus').innerHTML = '<span style="color: red;">✗ Export failed: ' + error.message + '</span>';
            });
        });

        // Import CSV functionality
        document.getElementById('importCsvBtn').addEventListener('click', function() {
            document.getElementById('csvFileInput').click();
        });

        document.getElementById('csvFileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.toLowerCase().endsWith('.csv')) {
                document.getElementById('csvStatus').innerHTML = '<span style="color: red;">✗ Please select a CSV file</span>';
                return;
            }
            
            const formData = new FormData();
            formData.append('csvFile', file);
            
            document.getElementById('csvStatus').innerHTML = '<span style="color: blue;">⏳ Importing configuration...</span>';
            
            fetch('/api/csv/import', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    document.getElementById('csvStatus').innerHTML = '<span style="color: green;">✓ Configuration imported successfully</span>';
                    // Refresh the page to show updated data
                    setTimeout(() => {
                        location.reload();
                    }, 2000);
                } else {
                    document.getElementById('csvStatus').innerHTML = '<span style="color: red;">✗ Import failed: ' + data.error + '</span>';
                }
            })
            .catch(error => {
                document.getElementById('csvStatus').innerHTML = '<span style="color: red;">✗ Import failed: ' + error.message + '</span>';
            });
            
            // Reset file input
            event.target.value = '';
        });

        // Export Settings CSV functionality
        document.getElementById('exportSettingsBtn').addEventListener('click', function() {
            fetch('/api/settings/export', {
                method: 'GET'
            })
            .then(response => {
                if (response.ok) {
                    return response.blob();
                }
                throw new Error('Settings export failed');
            })
            .then(blob => {
                // Create download link
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'device_settings_' + new Date().toISOString().split('T')[0] + '.csv';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                
                document.getElementById('settingsStatus').innerHTML = '<span style="color: green;">✓ Device settings exported successfully</span>';
            })
            .catch(error => {
                document.getElementById('settingsStatus').innerHTML = '<span style="color: red;">✗ Export failed: ' + error.message + '</span>';
            });
        });

        // Import Settings CSV functionality
        document.getElementById('importSettingsBtn').addEventListener('click', function() {
            document.getElementById('settingsFileInput').click();
        });

        document.getElementById('settingsFileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.toLowerCase().endsWith('.csv')) {
                document.getElementById('settingsStatus').innerHTML = '<span style="color: red;">✗ Please select a CSV file</span>';
                return;
            }
            
            if (!confirm('Importing settings will restart the device. Continue?')) {
                event.target.value = '';
                return;
            }
            
            const formData = new FormData();
            formData.append('settingsFile', file);
            
            document.getElementById('settingsStatus').innerHTML = '<span style="color: blue;">⏳ Importing settings...</span>';
            
            fetch('/api/settings/import', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    document.getElementById('settingsStatus').innerHTML = '<span style="color: green;">✓ Settings imported successfully. Device restarting...</span>';
                } else {
                    document.getElementById('settingsStatus').innerHTML = '<span style="color: red;">✗ Import failed: ' + data.error + '</span>';
                }
            })
            .catch(error => {
                document.getElementById('settingsStatus').innerHTML = '<span style="color: red;">✗ Import failed: ' + error.message + '</span>';
            });
            
            // Reset file input
            event.target.value = '';
        });
    </script>
</body>
</html>

-------- [ Separator ] ------

File Name: data/download-logs.html
Size: 16.94 KB
Code:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Download Logs - Temperature Controller</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .nav-links {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .nav-links a {
            color: #667eea;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .nav-links a:hover {
            background-color: #f0f0f0;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .card-header {
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .card-header h3 {
            color: #333;
            font-size: 1.2em;
        }

        .filters {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
        }

        .filter-group label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
        }

        .filter-group select,
        .filter-group input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .btn:hover {
            background: #5a6fd8;
        }

        .btn-success {
            background: #28a745;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-sm {
            padding: 5px 10px;
            font-size: 12px;
        }

        .table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .table th,
        .table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #555;
        }

        .table tr:hover {
            background: #f8f9fa;
        }

        .status {
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
        }

        .status.loading {
            background: #d1ecf1;
            color: #0c5460;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
        }

        .file-type-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .file-type-data {
            background: #e3f2fd;
            color: #1976d2;
        }

        .file-type-event {
            background: #fff3e0;
            color: #f57c00;
        }

        .file-type-alarm {
            background: #ffebee;
            color: #d32f2f;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        @media (max-width: 768px) {
            .filters {
                grid-template-columns: 1fr;
            }
            
            .nav-links {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📥 Download Log Files</h1>
            <div class="nav-links">
                <a href="/">🏠 Home</a>
                <a href="/sensors.html">🌡️ Sensors</a>
                <a href="/points.html">📍 Points</a>
                <a href="/alarms.html">🚨 Alarms</a>
                <a href="/alarm-history.html">📊 Alarm History</a>
                <a href="/event-logs.html">📋 Event Logs</a>
                <a href="/configuration.html">⚙️ Configuration</a>
            </div>
        </div>

        <!-- Statistics -->
        <div class="card">
            <div class="card-header">
                <h3>📊 File Statistics</h3>
            </div>
            <div class="stats" id="fileStats">
                <div class="stat-card">
                    <div class="stat-number" id="totalFiles">0</div>
                    <div class="stat-label">Total Files</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="dataFiles">0</div>
                    <div class="stat-label">Data Files</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="eventFiles">0</div>
                    <div class="stat-label">Event Files</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="alarmFiles">0</div>
                    <div class="stat-label">Alarm Files</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalSize">0 KB</div>
                    <div class="stat-label">Total Size</div>
                </div>
            </div>
        </div>

        <!-- Filters -->
        <div class="card">
            <div class="card-header">
                <h3>🔍 Filter Files</h3>
            </div>
            <div class="filters">
                <div class="filter-group">
                    <label for="logTypeFilter">Log Type:</label>
                    <select id="logTypeFilter">
                        <option value="all">All Types</option>
                        <option value="data">Temperature Data</option>
                        <option value="event">Event Logs</option>
                        <option value="alarm">Alarm States</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="dateFromFilter">Date From:</label>
                    <input type="date" id="dateFromFilter">
                </div>
                <div class="filter-group">
                    <label for="dateToFilter">Date To:</label>
                    <input type="date" id="dateToFilter">
                </div>
                <div class="filter-group">
                    <label for="sizeFilter">Min Size (KB):</label>
                    <input type="number" id="sizeFilter" min="0" placeholder="0">
                </div>
                <div class="filter-group">
                    <label>&nbsp;</label>
                    <button class="btn" onclick="applyFilters()">🔍 Apply Filters</button>
                </div>
                <div class="filter-group">
                    <label>&nbsp;</label>
                    <button class="btn" onclick="clearFilters()">🔄 Clear Filters</button>
                </div>
            </div>
        </div>

        <!-- File List -->
        <div class="card">
            <div class="card-header">
                <h3>📁 Available Files</h3>
                <button class="btn" onclick="refreshFileList()" style="float: right;">🔄 Refresh</button>
            </div>
            
            <div id="statusMessage"></div>
            
            <div id="fileListContainer">
                <p>Click "Refresh" to load available files</p>
            </div>
        </div>
    </div>

    <script>
        let allFiles = [];
        let filteredFiles = [];

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            // Set default date range (last 30 days)
            const today = new Date();
            const thirtyDaysAgo = new Date(today.getTime() - (30 * 24 * 60 * 60 * 1000));
            
            document.getElementById('dateToFilter').value = today.toISOString().split('T')[0];
            document.getElementById('dateFromFilter').value = thirtyDaysAgo.toISOString().split('T')[0];
            
            refreshFileList();
        });

        function showStatus(message, type = 'loading') {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function hideStatus() {
            document.getElementById('statusMessage').innerHTML = '';
        }

        async function refreshFileList() {
            showStatus('🔄 Loading file list...', 'loading');
            
            try {
                // Load all file types
                const [dataFiles, eventFiles, alarmFiles] = await Promise.all([
                    fetch('/api/data-log-files').then(r => r.json()),
                    fetch('/api/event-log-files').then(r => r.json()),
                    fetch('/api/alarm-log-files').then(r => r.json())
                ]);

                allFiles = [];

                // Process data files
                if (dataFiles.success) {
                    dataFiles.files.forEach(file => {
                        allFiles.push({
                            ...file,
                            type: 'data',
                            typeLabel: 'Temperature Data'
                        });
                    });
                }

                // Process event files
                if (eventFiles.success) {
                    eventFiles.files.forEach(file => {
                        allFiles.push({
                            ...file,
                            type: 'event',
                            typeLabel: 'Event Log'
                        });
                    });
                }

                // Process alarm files
                if (alarmFiles.success) {
                    alarmFiles.files.forEach(file => {
                        allFiles.push({
                            ...file,
                            type: 'alarm',
                            typeLabel: 'Alarm State'
                        });
                    });
                }

                updateStatistics();
                applyFilters();
                hideStatus();

            } catch (error) {
                console.error('Error loading file list:', error);
                showStatus('❌ Error loading file list', 'error');
            }
        }

        function updateStatistics() {
            const stats = {
                total: allFiles.length,
                data: allFiles.filter(f => f.type === 'data').length,
                event: allFiles.filter(f => f.type === 'event').length,
                alarm: allFiles.filter(f => f.type === 'alarm').length,
                totalSize: allFiles.reduce((sum, f) => sum + (f.size || 0), 0)
            };

            document.getElementById('totalFiles').textContent = stats.total;
            document.getElementById('dataFiles').textContent = stats.data;
            document.getElementById('eventFiles').textContent = stats.event;
            document.getElementById('alarmFiles').textContent = stats.alarm;
            document.getElementById('totalSize').textContent = Math.round(stats.totalSize / 1024) + ' KB';
        }

        function applyFilters() {
            const typeFilter = document.getElementById('logTypeFilter').value;
            const dateFrom = document.getElementById('dateFromFilter').value;
            const dateTo = document.getElementById('dateToFilter').value;
            const minSize = parseInt(document.getElementById('sizeFilter').value) || 0;

            filteredFiles = allFiles.filter(file => {
                // Type filter
                if (typeFilter !== 'all' && file.type !== typeFilter) {
                    return false;
                }

                // Date filter
                if (file.date) {
                    if (dateFrom && file.date < dateFrom) return false;
                    if (dateTo && file.date > dateTo) return false;
                }

                // Size filter
                if (file.size && (file.size / 1024) < minSize) {
                    return false;
                }

                return true;
            });

            displayFileList();
        }

        function clearFilters() {
            document.getElementById('logTypeFilter').value = 'all';
            document.getElementById('dateFromFilter').value = '';
            document.getElementById('dateToFilter').value = '';
            document.getElementById('sizeFilter').value = '';
            
            filteredFiles = [...allFiles];
            displayFileList();
        }

        function displayFileList() {
            const container = document.getElementById('fileListContainer');
            
            if (filteredFiles.length === 0) {
                container.innerHTML = '<p>No files match the current filters</p>';
                return;
            }

            // Sort files by date (newest first)
            filteredFiles.sort((a, b) => {
                if (a.date && b.date) {
                    return b.date.localeCompare(a.date);
                }
                return b.filename.localeCompare(a.filename);
            });

            let html = '<table class="table">';
            html += '<thead><tr><th>Type</th><th>Date</th><th>Filename</th><th>Size</th><th>Action</th></tr></thead>';
            html += '<tbody>';

            filteredFiles.forEach(file => {
                const sizeKB = file.size ? Math.round(file.size / 1024) : 0;
                const typeClass = `file-type-${file.type}`;
                
                html += `<tr>
                    <td><span class="file-type-badge ${typeClass}">${file.typeLabel}</span></td>
                    <td>${file.date || 'Unknown'}</td>
                    <td>${file.filename}</td>
                    <td>${sizeKB} KB</td>
                    <td>
                        <button onclick="downloadFile('${file.filename}', '${file.type}')" 
                                class="btn btn-sm btn-success">📥 Download</button>
                    </td>
                </tr>`;
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function downloadFile(filename, type) {
            let downloadUrl;
            
            switch(type) {
                case 'data':
                    downloadUrl = `/api/data-log-download?file=${encodeURIComponent(filename)}`;
                    break;
                case 'event':
                    downloadUrl = `/api/event-log-download?file=${encodeURIComponent(filename)}`;
                    break;
                case 'alarm':
                    downloadUrl = `/api/alarm-log-download?file=${encodeURIComponent(filename)}`;
                    break;
                default:
                    console.error('Unknown file type:', type);
                    return;
            }

            // Create temporary link and trigger download
            const link = document.createElement('a');
            link.href = downloadUrl;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            console.log(`Downloading ${type} file: ${filename}`);
            showStatus(`📥 Downloading ${filename}...`, 'success');
            
            // Hide status after 3 seconds
            setTimeout(hideStatus, 3000);
        }
    </script>
</body>
</html>

-------- [ Separator ] ------

File Name: data/event-logs.html
Size: 22.84 KB
Code:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temperature Controller - Event Logs</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        nav {
            margin-bottom: 20px;
            padding: 10px;
            background: #007bff;
            border-radius: 5px;
        }
        nav a {
            color: white;
            text-decoration: none;
            margin-right: 15px;
            padding: 5px 10px;
            border-radius: 3px;
        }
        nav a:hover {
            background: rgba(255,255,255,0.2);
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .controls button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-success {
            background-color: #28a745;
            color: white;
        }
        .btn-info {
            background-color: #17a2b8;
            color: white;
        }
        .btn:hover {
            opacity: 0.8;
        }
        .filter-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .filter-group label {
            font-weight: bold;
            margin-right: 5px;
        }
        .filter-group select, .filter-group input {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        .date-range {
            display: flex;
            gap: 10px;
            align-items: center;
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        th:hover {
            background-color: #e9ecef;
        }
        th.sortable::after {
            content: " ↕";
            color: #999;
            font-size: 12px;
        }
        th.sort-asc::after {
            content: " ↑";
            color: #007bff;
            font-weight: bold;
        }
        th.sort-desc::after {
            content: " ↓";
            color: #007bff;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .priority-critical {
            background-color: #f8d7da;
            color: #721c24;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
        }
        .priority-error {
            background-color: #f8d7da;
            color: #721c24;
            padding: 4px 8px;
            border-radius: 4px;
        }
        .priority-warning {
            background-color: #fff3cd;
            color: #856404;
            padding: 4px 8px;
            border-radius: 4px;
        }
        .priority-info {
            background-color: #d1ecf1;
            color: #0c5460;
            padding: 4px 8px;
            border-radius: 4px;
        }
        .no-logs {
            text-align: center;
            padding: 40px;
            color: #6c757d;
            font-style: italic;
        }
        .timestamp {
            font-size: 12px;
            color: #6c757d;
        }
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
        }
        .pagination button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            border-radius: 4px;
        }
        .pagination button:hover {
            background: #f8f9fa;
        }
        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .pagination .current-page {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        .search-box {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .search-box input {
            width: 300px;
            padding: 5px 10px;
        }
        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .stat-card {
            flex: 1;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            color: white;
        }
        .stat-total {
            background-color: #6c757d;
        }
        .stat-critical {
            background-color: #dc3545;
        }
        .stat-error {
            background-color: #dc3545;
        }
        .stat-warning {
            background-color: #ffc107;
            color: black;
        }
        .stat-info {
            background-color: #17a2b8;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
        }
        .stat-label {
            font-size: 14px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="/dashboard.html">Home</a>
            <a href="/sensors.html">Sensors</a>
            <a href="/points.html">Points</a>
            <a href="/alarms.html">Alarms</a>
            <a href="/alarm-history.html">Alarm History</a>
            <a href="/event-logs.html">Event Logs</a>
            <a href="/config">Configuration</a>
        </nav>

        <h1>System Event Logs</h1>

        <!-- Statistics -->
        <div class="stats" id="statsContainer">
            <div class="stat-card stat-total">
                <div class="stat-value" id="totalCount">0</div>
                <div class="stat-label">Total Events</div>
            </div>
            <div class="stat-card stat-critical">
                <div class="stat-value" id="criticalCount">0</div>
                <div class="stat-label">Critical</div>
            </div>
            <div class="stat-card stat-error">
                <div class="stat-value" id="errorCount">0</div>
                <div class="stat-label">Errors</div>
            </div>
            <div class="stat-card stat-warning">
                <div class="stat-value" id="warningCount">0</div>
                <div class="stat-label">Warnings</div>
            </div>
            <div class="stat-card stat-info">
                <div class="stat-value" id="infoCount">0</div>
                <div class="stat-label">Info</div>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <div class="date-range">
                <label>Date Range:</label>
                <input type="date" id="startDate">
                <span>to</span>
                <input type="date" id="endDate">
                <button class="btn btn-primary" onclick="loadLogs()">🔍 Load Logs</button>
            </div>
            
            <button class="btn btn-success" onclick="exportLogs()">📥 Export CSV</button>
            <button class="btn btn-info" onclick="refreshLogs()">🔄 Refresh</button>
            
            <div class="filter-group">
                <label>Filter by Priority:</label>
                <select id="priorityFilter" onchange="filterTable()">
                    <option value="">All Priorities</option>
                    <option value="CRITICAL">Critical</option>
                    <option value="ERROR">Error</option>
                    <option value="WARNING">Warning</option>
                    <option value="INFO">Info</option>
                </select>
            </div>

            <div class="filter-group">
                <label>Filter by Source:</label>
                <select id="sourceFilter" onchange="filterTable()">
                    <option value="">All Sources</option>
                </select>
            </div>
        </div>

        <!-- Search Box -->
        <div class="controls">
            <div class="search-box">
                <label>Search Description:</label>
                <input type="text" id="searchBox" placeholder="Enter keywords..." onkeyup="filterTable()">
                <button class="btn btn-primary" onclick="clearSearch()">Clear</button>
            </div>
        </div>

        <!-- Event Logs Table -->
        <table id="logsTable">
            <thead>
                <tr>
                    <th class="sortable" onclick="sortTable(0)">Timestamp</th>
                    <th class="sortable" onclick="sortTable(1)">Source</th>
                    <th class="sortable" onclick="sortTable(2)">Description</th>
                    <th class="sortable" onclick="sortTable(3)">Priority</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td colspan="4" class="no-logs">Select a date range and click "Load Logs" to view system events</td>
                </tr>
            </tbody>
        </table>

        <!-- Pagination -->
        <div class="pagination" id="pagination" style="display: none;">
            <button id="prevPage" onclick="changePage(-1)">← Previous</button>
            <span id="pageInfo">Page 1 of 1</span>
            <button id="nextPage" onclick="changePage(1)">Next →</button>
        </div>
    </div>

    <script>
        let logsData = [];
        let filteredData = [];
        let sortColumn = -1;
        let sortDirection = 'desc'; // Default to newest first
        let currentPage = 1;
        const itemsPerPage = 100;
        let uniqueSources = new Set();

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            // Set default date range (last 7 days)
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 7);
            
            document.getElementById('endDate').value = endDate.toISOString().split('T')[0];
            document.getElementById('startDate').value = startDate.toISOString().split('T')[0];
            
            // Load logs automatically on page load
            loadLogs();
        });

        // Load event logs from API
        async function loadLogs() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            if (!startDate || !endDate) {
                alert('Please select both start and end dates');
                return;
            }
            
            if (new Date(startDate) > new Date(endDate)) {
                alert('Start date must be before end date');
                return;
            }

            try {
                const response = await fetch(`/api/event-logs?start=${startDate}&end=${endDate}`);
                const data = await response.json();
                
                if (data.success) {
                    logsData = data.logs || [];
                    currentPage = 1;
                    
                    // Extract unique sources
                    uniqueSources.clear();
                    logsData.forEach(log => {
                        if (log.source) {
                            uniqueSources.add(log.source);
                        }
                    });
                    
                    // Update source filter dropdown
                    updateSourceFilter();
                    
                    // Sort by timestamp descending by default
                    sortColumn = 0;
                    sortDirection = 'desc';
                    
                    displayLogs();
                    updateStatistics();
                } else {
                    throw new Error(data.error || 'Failed to load logs');
                }
            } catch (error) {
                console.error('Error loading event logs:', error);
                document.querySelector('#logsTable tbody').innerHTML = 
                    '<tr><td colspan="4" class="no-logs">Error loading event logs: ' + error.message + '</td></tr>';
            }
        }

        // Update source filter dropdown
        function updateSourceFilter() {
            const sourceFilter = document.getElementById('sourceFilter');
            sourceFilter.innerHTML = '<option value="">All Sources</option>';
            
            // Sort sources alphabetically
            const sortedSources = Array.from(uniqueSources).sort();
            
            sortedSources.forEach(source => {
                const option = document.createElement('option');
                option.value = source;
                option.textContent = source;
                sourceFilter.appendChild(option);
            });
        }

        // Update statistics
        function updateStatistics() {
            const stats = {
                total: 0,
                critical: 0,
                error: 0,
                warning: 0,
                info: 0
            };

            filteredData.forEach(log => {
                stats.total++;
                switch (log.priority) {
                    case 'CRITICAL': stats.critical++; break;
                    case 'ERROR': stats.error++; break;
                    case 'WARNING': stats.warning++; break;
                    case 'INFO': stats.info++; break;
                }
            });

            document.getElementById('totalCount').textContent = stats.total;
            document.getElementById('criticalCount').textContent = stats.critical;
            document.getElementById('errorCount').textContent = stats.error;
            document.getElementById('warningCount').textContent = stats.warning;
            document.getElementById('infoCount').textContent = stats.info;
        }

        // Display logs in table
        function displayLogs() {
            const tbody = document.querySelector('#logsTable tbody');
            
            if (logsData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" class="no-logs">No event logs found for the selected date range</td></tr>';
                document.getElementById('pagination').style.display = 'none';
                return;
            }

            // Apply filters
            filterTable();
        }

        // Create table row for log entry
        function createLogRow(entry) {
            const row = document.createElement('tr');
            
            row.innerHTML = `
                <td><span class="timestamp">${entry.timestamp}</span></td>
                <td>${entry.source || 'Unknown'}</td>
                <td>${entry.description || ''}</td>
                <td><span class="priority-${entry.priority.toLowerCase()}">${entry.priority}</span></td>
            `;
            
            // Set data attributes for filtering
            row.dataset.priority = entry.priority;
            row.dataset.source = entry.source || '';
            row.dataset.description = (entry.description || '').toLowerCase();
            
            return row;
        }

        // Filter table function
        function filterTable() {
            const priorityFilter = document.getElementById('priorityFilter').value;
            const sourceFilter = document.getElementById('sourceFilter').value;
            const searchText = document.getElementById('searchBox').value.toLowerCase();
            
            filteredData = logsData.filter(entry => {
                const priorityMatch = !priorityFilter || entry.priority === priorityFilter;
                const sourceMatch = !sourceFilter || entry.source === sourceFilter;
                const searchMatch = !searchText || 
                    (entry.description && entry.description.toLowerCase().includes(searchText)) ||
                    (entry.source && entry.source.toLowerCase().includes(searchText));
                
                return priorityMatch && sourceMatch && searchMatch;
            });
            
            // Apply current sorting
            if (sortColumn >= 0) {
                applySorting();
            }
            
            currentPage = 1;
            displayFilteredData();
            updateStatistics();
        }

        // Apply sorting to filtered data
        function applySorting() {
            filteredData.sort((a, b) => {
                let aValue, bValue;
                
                switch (sortColumn) {
                    case 0: // Timestamp
                        aValue = new Date(a.timestamp);
                        bValue = new Date(b.timestamp);
                        break;
                    case 1: // Source
                        aValue = a.source || '';
                        bValue = b.source || '';
                        break;
                    case 2: // Description
                        aValue = a.description || '';
                        bValue = b.description || '';
                        break;
                    case 3: // Priority
                        const priorityOrder = { 'CRITICAL': 0, 'ERROR': 1, 'WARNING': 2, 'INFO': 3 };
                        aValue = priorityOrder[a.priority] || 999;
                        bValue = priorityOrder[b.priority] || 999;
                        break;
                    default:
                        return 0;
                }
                
                let comparison = 0;
                if (typeof aValue === 'number' && typeof bValue === 'number') {
                    comparison = aValue - bValue;
                } else if (aValue instanceof Date && bValue instanceof Date) {
                    comparison = aValue - bValue;
                } else {
                    comparison = String(aValue).localeCompare(String(bValue));
                }
                
                return sortDirection === 'asc' ? comparison : -comparison;
            });
        }

        // Display filtered and paginated data
        function displayFilteredData() {
            const tbody = document.querySelector('#logsTable tbody');
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageData = filteredData.slice(startIndex, endIndex);
            
            if (pageData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" class="no-logs">No event logs match the current filters</td></tr>';
                document.getElementById('pagination').style.display = 'none';
                return;
            }
            
            tbody.innerHTML = '';
            pageData.forEach(entry => {
                tbody.appendChild(createLogRow(entry));
            });
            
            // Update pagination
            const totalPages = Math.ceil(filteredData.length / itemsPerPage);
            if (totalPages > 1) {
                document.getElementById('pagination').style.display = 'flex';
                document.getElementById('pageInfo').textContent = `Page ${currentPage} of ${totalPages} (${filteredData.length} entries)`;
                document.getElementById('prevPage').disabled = currentPage === 1;
                document.getElementById('nextPage').disabled = currentPage === totalPages;
            } else {
                document.getElementById('pagination').style.display = 'none';
            }
        }

        // Pagination functions
        function changePage(direction) {
            const totalPages = Math.ceil(filteredData.length / itemsPerPage);
            const newPage = currentPage + direction;
            
            if (newPage >= 1 && newPage <= totalPages) {
                currentPage = newPage;
                displayFilteredData();
            }
        }

        // Table sorting function
        function sortTable(columnIndex) {
            const table = document.getElementById('logsTable');
            
            // Update sort direction
            if (sortColumn === columnIndex) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortDirection = columnIndex === 0 ? 'desc' : 'asc'; // Default newest first for timestamp
                sortColumn = columnIndex;
            }

            // Clear previous sort indicators
            table.querySelectorAll('th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });

            // Add current sort indicator
            const currentHeader = table.querySelector(`th:nth-child(${columnIndex + 1})`);
            currentHeader.classList.add(sortDirection === 'asc' ? 'sort-asc' : 'sort-desc');

            // Apply sorting and redisplay
            applySorting();
            displayFilteredData();
        }

        // Export logs to CSV
        async function exportLogs() {
            if (filteredData.length === 0) {
                alert('No data to export. Please load logs first.');
                return;
            }
            
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            try {
                const response = await fetch(`/api/event-logs/export?start=${startDate}&end=${endDate}`, {
                    method: 'GET'
                });
                
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `event_logs_${startDate}_to_${endDate}.csv`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                } else {
                    throw new Error('Export failed');
                }
            } catch (error) {
                console.error('Error exporting logs:', error);
                alert('Failed to export logs: ' + error.message);
            }
        }

        // Refresh logs
        function refreshLogs() {
            loadLogs();
        }

        // Clear search
        function clearSearch() {
            document.getElementById('searchBox').value = '';
            filterTable();
        }
    </script>
</body>
</html>
-------- [ Separator ] ------

File Name: data/points.html
Size: 20.55 KB
Code:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temperature Controller - Points</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        nav {
            margin-bottom: 20px;
            padding: 10px;
            background: #007bff;
            border-radius: 5px;
        }
        nav a {
            color: white;
            text-decoration: none;
            margin-right: 15px;
            padding: 5px 10px;
            border-radius: 3px;
        }
        nav a:hover {
            background: rgba(255,255,255,0.2);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .btn {
            padding: 5px 10px;
            margin: 2px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-warning {
            background-color: #ffc107;
            color: black;
        }
        .btn-danger {
            background-color: #dc3545;
            color: white;
        }
        .btn:hover {
            opacity: 0.8;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            border-radius: 8px;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover {
            color: black;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input, .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        .alarm-list {
            margin-top: 20px;
        }
        .alarm-item {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
        }
        .alarm-item.critical {
            border-left: 4px solid #dc3545;
        }
        .alarm-item.high {
            border-left: 4px solid #fd7e14;
        }
        .alarm-item.medium {
            border-left: 4px solid #ffc107;
        }
        .alarm-item.low {
            border-left: 4px solid #28a745;
        }
        .status-active {
            color: #dc3545;
            font-weight: bold;
        }
        .status-inactive {
            color: #6c757d;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="/dashboard.html">Home</a>
            <a href="/sensors.html">Sensors</a>
            <a href="/points.html">Points</a>
            <a href="/alarms.html">Alarms</a>
            <a href="/alarm-history.html">Alarm History</a>
            <a href="/event-logs.html">Event Logs</a>
            <a href="/config">Configuration</a>
        </nav>

        <h1>Temperature Measurement Points</h1>

        ## DS18B20 Points
        <table id="ds18b20Table">
            <thead>
                <tr>
                    <th>Address</th>
                    <th>Bus</th>
                    <th>Name</th>
                    <th>Current Temp</th>
                    <th>Min Temp</th>
                    <th>Max Temp</th>
                    <th>Low Alarm</th>
                    <th>High Alarm</th>
                    <th>Alarm Status</th>
                    <th>Error Status</th>
                    <th>Sensor Status</th>
                    <th>Edit Point</th>
                    <th>Edit Alarm</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td colspan="13">Loading DS18B20 points...</td>
                </tr>
            </tbody>
        </table>

        ## PT1000 Points
        <table id="pt1000Table">
            <thead>
                <tr>
                    <th>Address</th>
                    <th>Bus</th>
                    <th>Name</th>
                    <th>Current Temp</th>
                    <th>Min Temp</th>
                    <th>Max Temp</th>
                    <th>Low Alarm</th>
                    <th>High Alarm</th>
                    <th>Alarm Status</th>
                    <th>Error Status</th>
                    <th>Sensor Status</th>
                    <th>Edit Point</th>
                    <th>Edit Alarm</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td colspan="13">Loading PT1000 points...</td>
                </tr>
            </tbody>
        </table>
    </div>

    <!-- Point Edit Modal -->
    <div id="pointModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closePointModal()">&times;</span>
            <h2>Edit Point</h2>
            <form id="pointForm">
                <div class="form-group">
                    <label for="pointAddress">Address:</label>
                    <input type="number" id="pointAddress" readonly>
                </div>
                <div class="form-group">
                    <label for="pointName">Name:</label>
                    <input type="text" id="pointName" required>
                </div>
                <div class="form-group">
                    <label for="lowAlarm">Low Alarm Threshold:</label>
                    <input type="number" id="lowAlarm" step="0.1">
                </div>
                <div class="form-group">
                    <label for="highAlarm">High Alarm Threshold:</label>
                    <input type="number" id="highAlarm" step="0.1">
                </div>
                <button type="submit" class="btn btn-primary">Save Point</button>
                <button type="button" class="btn" onclick="closePointModal()">Cancel</button>
            </form>
        </div>
    </div>

    <!-- Alarm Configuration Modal -->
    <div id="alarmModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeAlarmModal()">&times;</span>
            <h2>Alarm Configuration for Point <span id="alarmPointInfo"></span></h2>
            
            <div class="form-group">
                <h3>Add New Alarm</h3>
                <form id="alarmForm">
                    <div class="form-group">
                        <label for="alarmType">Alarm Type:</label>
                        <select id="alarmType" required>
                            <option value="0">High Temperature</option>
                            <option value="1">Low Temperature</option>
                            <option value="2">Sensor Error</option>
                            <option value="3">Sensor Disconnected</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="alarmPriority">Priority:</label>
                        <select id="alarmPriority" required>
                            <option value="0">Low</option>
                            <option value="1">Medium</option>
                            <option value="2">High</option>
                            <option value="3">Critical</option>
                        </select>
                    </div>
                    <button type="submit" class="btn btn-primary">Add Alarm</button>
                </form>
            </div>

            <div class="alarm-list">
                <h3>Configured Alarms</h3>
                <div id="alarmsList">
                    <!-- Alarms will be loaded here -->
                </div>
            </div>

            <div style="margin-top: 20px;">
                <button type="button" class="btn" onclick="closeAlarmModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        const UPDATE_INTERVAL = 5000;
        let currentPointAddress = null;
        let pointsData = [];
        let alarmsData = [];

        // Load points data on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadPoints();
            loadAlarms();
        });

        // Load points from API
        async function loadPoints() {
            try {
                const response = await fetch('/api/points');
                const data = await response.json();
                pointsData = data.points || [];
                displayPoints();
            } catch (error) {
                console.error('Error loading points:', error);
            }
        }

        // Load alarms from API
        async function loadAlarms() {
            try {
                const response = await fetch('/api/alarms');
                const data = await response.json();
                alarmsData = data.alarms || [];
            } catch (error) {
                console.error('Error loading alarms:', error);
            }
        }

        // Display points in tables
        function displayPoints() {
            const ds18b20Table = document.getElementById('ds18b20Table').getElementsByTagName('tbody')[0];
            const pt1000Table = document.getElementById('pt1000Table').getElementsByTagName('tbody')[0];
            
            // Clear existing rows
            ds18b20Table.innerHTML = '';
            pt1000Table.innerHTML = '';

            pointsData.forEach(point => {
                const row = createPointRow(point);
                
                if (point.type === 'DS18B20') {
                    ds18b20Table.appendChild(row);
                } else if (point.type === 'PT1000') {
                    pt1000Table.appendChild(row);
                }
            });
        }

        // Create table row for a point
        function createPointRow(point) {
            const row = document.createElement('tr');
            
            const alarmCount = getAlarmCountForPoint(point.address);
            const alarmStatus = alarmCount > 0 ? `${alarmCount} configured` : 'None';
            
            row.innerHTML = `
                <td>${point.address}</td>
                <td>${point.bus || 'N/A'}</td>
                <td>${point.name}</td>
                <td>${point.currentTemp}°C</td>
                <td>${point.minTemp}°C</td>
                <td>${point.maxTemp}°C</td>
                <td>${point.lowAlarmThreshold}°C</td>
                <td>${point.highAlarmThreshold}°C</td>
                <td>${alarmStatus}</td>
                <td>${point.errorStatus || 'OK'}</td>
                <td>${point.sensorType || 'No Sensor'}</td>
                <td><button class="btn btn-primary" onclick="editPoint(${point.address})">Edit</button></td>
                <td><button class="btn btn-warning" onclick="editAlarms(${point.address})">Alarms</button></td>
            `;
            
            return row;
        }

        // Get alarm count for a specific point
        function getAlarmCountForPoint(pointAddress) {
            return alarmsData.filter(alarm => alarm.pointAddress === pointAddress).length;
        }

        // Edit point function
        function editPoint(address) {
            const point = pointsData.find(p => p.address === address);
            if (!point) return;

            document.getElementById('pointAddress').value = point.address;
            document.getElementById('pointName').value = point.name;
            document.getElementById('lowAlarm').value = point.lowAlarmThreshold;
            document.getElementById('highAlarm').value = point.highAlarmThreshold;
            
            document.getElementById('pointModal').style.display = 'block';
        }

        // Edit alarms function
        function editAlarms(address) {
            currentPointAddress = address;
            const point = pointsData.find(p => p.address === address);
            if (!point) return;

            document.getElementById('alarmPointInfo').textContent = `${address} (${point.name})`;
            displayAlarmsForPoint(address);
            document.getElementById('alarmModal').style.display = 'block';
        }

        // Display alarms for specific point
        function displayAlarmsForPoint(pointAddress) {
            const alarmsList = document.getElementById('alarmsList');
            const pointAlarms = alarmsData.filter(alarm => alarm.pointAddress === pointAddress);
            
            if (pointAlarms.length === 0) {
                alarmsList.innerHTML = '<p>No alarms configured for this point.</p>';
                return;
            }

            alarmsList.innerHTML = pointAlarms.map(alarm => `
                <div class="alarm-item ${getPriorityClass(alarm.priority)}">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong>${getAlarmTypeText(alarm.type)}</strong> - 
                            <span class="${alarm.enabled ? 'status-active' : 'status-inactive'}">
                                ${alarm.enabled ? 'Enabled' : 'Disabled'}
                            </span>
                            <br>
                            <small>Priority: ${getPriorityText(alarm.priority)}</small>
                            ${alarm.isActive ? '<br><small class="status-active">Currently Active</small>' : ''}
                        </div>
                        <div>
                            <button class="btn btn-warning" onclick="toggleAlarm('${alarm.configKey}', ${!alarm.enabled})">
                                ${alarm.enabled ? 'Disable' : 'Enable'}
                            </button>
                            <button class="btn btn-danger" onclick="deleteAlarm('${alarm.configKey}')">Delete</button>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // Helper functions for alarm display
        function getAlarmTypeText(type) {
            const types = ['High Temperature', 'Low Temperature', 'Sensor Error', 'Sensor Disconnected'];
            return types[type] || 'Unknown';
        }

        function getPriorityText(priority) {
            const priorities = ['Low', 'Medium', 'High', 'Critical'];
            return priorities[priority] || 'Unknown';
        }

        function getPriorityClass(priority) {
            const classes = ['low', 'medium', 'high', 'critical'];
            return classes[priority] || 'low';
        }

        // Form submission handlers
        document.getElementById('pointForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const pointData = {
                address: parseInt(document.getElementById('pointAddress').value),
                name: document.getElementById('pointName').value,
                lowAlarmThreshold: parseFloat(document.getElementById('lowAlarm').value),
                highAlarmThreshold: parseFloat(document.getElementById('highAlarm').value)
            };

            try {
                const response = await fetch('/api/points', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(pointData)
                });

                if (response.ok) {
                    closePointModal();
                    loadPoints();
                } else {
                    alert('Error updating point');
                }
            } catch (error) {
                console.error('Error updating point:', error);
                alert('Error updating point');
            }
        });

        document.getElementById('alarmForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const alarmData = {
                type: parseInt(document.getElementById('alarmType').value),
                pointAddress: currentPointAddress,
                priority: parseInt(document.getElementById('alarmPriority').value)
            };

            try {
                const response = await fetch('/api/alarms', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(alarmData)
                });

                if (response.ok) {
                    document.getElementById('alarmForm').reset();
                    loadAlarms();
                    displayAlarmsForPoint(currentPointAddress);
                    loadPoints(); // Refresh points to update alarm count
                } else {
                    alert('Error adding alarm');
                }
            } catch (error) {
                console.error('Error adding alarm:', error);
                alert('Error adding alarm');
            }
        });

        // Alarm management functions
        async function toggleAlarm(configKey, enabled) {
            const alarm = alarmsData.find(a => a.configKey === configKey);
            if (!alarm) return;

            try {
                const response = await fetch('/api/alarms', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        configKey: configKey,
                        priority: alarm.priority,
                        enabled: enabled
                    })
                });

                if (response.ok) {
                    loadAlarms();
                    displayAlarmsForPoint(currentPointAddress);
                    loadPoints();
                } else {
                    alert('Error updating alarm');
                }
            } catch (error) {
                console.error('Error updating alarm:', error);
                alert('Error updating alarm');
            }
        }

        async function deleteAlarm(configKey) {
            if (!confirm('Are you sure you want to delete this alarm?')) return;

            try {
                const response = await fetch(`/api/alarms?configKey=${encodeURIComponent(configKey)}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    loadAlarms();
                    displayAlarmsForPoint(currentPointAddress);
                    loadPoints();
                } else {
                    alert('Error deleting alarm');
                }
            } catch (error) {
                console.error('Error deleting alarm:', error);
                alert('Error deleting alarm');
            }
        }

        // Modal control functions
        function closePointModal() {
            document.getElementById('pointModal').style.display = 'none';
        }

        function closeAlarmModal() {
            document.getElementById('alarmModal').style.display = 'none';
            currentPointAddress = null;
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            const pointModal = document.getElementById('pointModal');
            const alarmModal = document.getElementById('alarmModal');
            
            if (event.target === pointModal) {
                closePointModal();
            }
            if (event.target === alarmModal) {
                closeAlarmModal();
            }
        }

        // Auto-refresh data every 30 seconds
        setInterval(() => {
            loadPoints();
            loadAlarms();
        }, UPDATE_INTERVAL);
    </script>
</body>
</html>

-------- [ Separator ] ------

File Name: data/sensors.html
Size: 15.97 KB
Code:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sensors Management</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        /* Use styles from index.html */
        body {
            font-family: Arial, sans-serif;
            background: #f7f7f7;
            margin: 0;
            padding: 0;
        }
        header {
            background: #3f51b5;
            color: #fff;
            padding: 1em 2em;
            text-align: center;
            font-size: 1.5em;
            letter-spacing: 2px;
        }
        nav {
            background: #263238;
            padding: 0.5em 2em;
        }
        nav a {
            color: #fff;
            text-decoration: none;
            margin-right: 2em;
            font-weight: bold;
            transition: color 0.2s;
        }
        nav a:hover {
            color: #ffeb3b;
        }
        main {
            max-width: 1200px;
            margin: 2em auto;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            padding: 2em;
        }
        h2 {
            margin-top: 1em;
            color: #3f51b5;
            font-size: 1.2em;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.25em;
        }
        .actions {
            margin-bottom: 1.5em;
        }
        button {
            background: #3f51b5;
            color: #fff;
            border: none;
            padding: 0.5em 1.2em;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            margin-right: 0.5em;
            transition: background 0.2s;
        }
        button:hover {
            background: #283593;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 2em;
        }
        th, td {
            padding: 0.6em 0.8em;
            border-bottom: 1px solid #eee;
            text-align: left;
        }
        th {
            background: #f0f4ff;
            color: #3f51b5;
        }
        tr:last-child td {
            border-bottom: none;
        }
        .status-bound {
            color: #388e3c;
            font-weight: bold;
        }
        .status-unbound {
            color: #b71c1c;
            font-weight: bold;
        }
        .rom, .chip-select {
            font-family: monospace;
            font-size: 0.98em;
            color: #333;
        }
        @media (max-width: 800px) {
            main { padding: 1em; }
            th, td { font-size: 0.95em; }
        }
    </style>
</head>
<body>
    <header>Temperature Monitoring System</header>
    <nav>
        <a href="/dashboard.html">Home</a>
        <a href="/sensors.html">Sensors</a>
        <a href="/points.html">Points</a>
        <a href="/alarms.html">Alarms</a>
        <a href="/alarm-history.html">Alarm History</a>
        <a href="/event-logs.html">Event Logs</a>
        <a href="/config">Configuration</a>

    </nav>
    <main>
        <div class="actions">
            <button id="discoverBtn">Discover</button>
            <button id="resetMinMaxBtn">Reset Min/Max</button>
        </div>

        <h2>DS18B20 Sensors</h2>
        <table id="dsTable">
            <thead>
                <tr>
                    <th>#</th>
                    <th>Name</th>
                    <th>ROM Address</th>
                    <th>Bus</th>
                    <th>Current Temp (°C)</th>
                    <th>Min Temp (°C)</th>
                    <th>Max Temp (°C)</th>
                    <th>Measurement Point</th>
                    <th>Errors</th>
                    <th>Alarms</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="dsTbody">
                <tr><td colspan="8">Loading DS18B20 sensors...</td></tr>
            </tbody>
        </table>

        <h2>PT1000 Sensors</h2>
        <table id="ptTable">
            <thead>
                <tr>
                    <th>#</th>
                    <th>Name</th>
                    <th>Chip Select Pin</th>
                    <th>Bus</th>
                    <th>Current Temp (°C)</th>
                    <th>Min Temp (°C)</th>
                    <th>Max Temp (°C)</th>
                    <th>Measurement Point</th>
                    <th>Errors</th>
                    <th>Alarms</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="ptTbody">
                <tr><td colspan="8">Loading PT1000 sensors...</td></tr>
            </tbody>
        </table>
    </main>
    <script>
        // Auto-update interval (ms)
        const UPDATE_INTERVAL = 5000;

        function fetchSensors() {
            fetch('/api/sensors')
                .then(res => res.json())
                .then(data => {
                    renderSensorTables(data.sensors || []);
                });
        }

        // function renderSensorTables(sensors) {
        //     // Separate DS and PT
        //     const dsSensors = sensors.filter(s => s.type === "DS18B20");
        //     const ptSensors = sensors.filter(s => s.type === "PT1000");

        //     // DS Table
        //     const dsTbody = document.getElementById('dsTbody');
        //     dsTbody.innerHTML = '';
        //     if (dsSensors.length === 0) {
        //         dsTbody.innerHTML = '<tr><td colspan="8">No DS18B20 sensors found.</td></tr>';
        //     } else {
        //         dsSensors.forEach((sensor, idx) => {
        //             const row = document.createElement('tr');
        //             row.innerHTML = `
        //                 <td>${idx+1}</td>
        //                 <td>${sensor.name || ''}</td>
        //                 <td class="rom">${sensor.romString || ''}</td>
        //                 <td>${sensor.currentTemp !== undefined ? sensor.currentTemp : ''}</td>
        //                 <td>${sensor.minTemp !== undefined ? sensor.minTemp : ''}</td>
        //                 <td>${sensor.maxTemp !== undefined ? sensor.maxTemp : ''}</td>
        //                 <td>
        //                     ${sensor.boundPoint !== null && sensor.boundPoint !== undefined
        //                         ? `<span class="status-bound">#${sensor.boundPoint}</span>`
        //                         : `<span class="status-unbound">Unbound</span>`}
        //                 </td>
        //                 <td>
        //                     ${sensor.boundPoint === null || sensor.boundPoint === undefined
        //                         ? `<button onclick="bindPrompt('DS18B20','${sensor.romString}')">Bind</button>`
        //                         : `<button onclick="unbindSensor('DS18B20','${sensor.romString}')">Unbind</button>`}
        //                 </td>
        //             `;
        //             dsTbody.appendChild(row);
        //         });
        //     }

        //     // PT Table
        //     const ptTbody = document.getElementById('ptTbody');
        //     ptTbody.innerHTML = '';
        //     if (ptSensors.length === 0) {
        //         ptTbody.innerHTML = '<tr><td colspan="8">No PT1000 sensors found.</td></tr>';
        //     } else {
        //         ptSensors.forEach((sensor, idx) => {
        //             const row = document.createElement('tr');
        //             row.innerHTML = `
        //                 <td>${idx+1}</td>
        //                 <td>${sensor.name || ''}</td>
        //                 <td class="chip-select">${sensor.chipSelectPin !== undefined ? sensor.chipSelectPin : ''}</td>
        //                 <td>${sensor.currentTemp !== undefined ? sensor.currentTemp : ''}</td>
        //                 <td>${sensor.minTemp !== undefined ? sensor.minTemp : ''}</td>
        //                 <td>${sensor.maxTemp !== undefined ? sensor.maxTemp : ''}</td>
        //                 <td>
        //                     ${sensor.boundPoint !== null && sensor.boundPoint !== undefined
        //                         ? `<span class="status-bound">#${sensor.boundPoint}</span>`
        //                         : `<span class="status-unbound">Unbound</span>`}
        //                 </td>
        //                 <td>
        //                     ${sensor.boundPoint === null || sensor.boundPoint === undefined
        //                         ? `<button onclick="bindPrompt('PT1000','${sensor.chipSelectPin}')">Bind</button>`
        //                         : `<button onclick="unbindSensor('PT1000','${sensor.chipSelectPin}')">Unbind</button>`}
        //                 </td>
        //             `;
        //             ptTbody.appendChild(row);
        //         });
        //     }
        // }

        function renderSensorTables(sensors) {
    // Separate DS and PT
    const dsSensors = sensors.filter(s => s.type === "DS18B20");
    const ptSensors = sensors.filter(s => s.type === "PT1000");

    // Helper functions to interpret status bitmasks
    function getErrorText(errorStatus) {
        if (errorStatus === 0) return '';
        
        const errors = [];
        if (errorStatus & 0x01) errors.push('Communication Error');
        if (errorStatus & 0x02) errors.push('Out of Range');
        if (errorStatus & 0x04) errors.push('Disconnected');
        
        return errors.join(', ');
    }
    
    function getAlarmText(alarmStatus) {
        if (alarmStatus === 0) return '';
        
        const alarms = [];
        if (alarmStatus & 0x01) alarms.push('Low Temperature');
        if (alarmStatus & 0x02) alarms.push('High Temperature');
        
        return alarms.join(', ');
    }
    
    function getStatusClass(errorStatus, alarmStatus) {
        if (errorStatus > 0) return 'status-error';
        if (alarmStatus > 0) return 'status-alarm';
        return 'status-normal';
    }

    // DS Table
    const dsTbody = document.getElementById('dsTbody');
    dsTbody.innerHTML = '';
    if (dsSensors.length === 0) {
        dsTbody.innerHTML = '<tr><td colspan="10">No DS18B20 sensors found.</td></tr>';
    } else {
        dsSensors.forEach((sensor, idx) => {
            const errorText = getErrorText(sensor.errorStatus);
            const alarmText = getAlarmText(sensor.alarmStatus);
            const statusClass = getStatusClass(sensor.errorStatus, sensor.alarmStatus);
            
            const row = document.createElement('tr');
            row.className = statusClass;
            row.innerHTML = `
                <td>${idx+1}</td>
                <td>${sensor.name || ''}</td>
                <td class="rom">${sensor.romString || ''}</td>
                <td>${sensor.bus !== undefined && sensor.bus !== null ? sensor.bus : ''}</td>
                <td>${sensor.currentTemp !== undefined ? sensor.currentTemp : ''}</td>
                <td>${sensor.minTemp !== undefined ? sensor.minTemp : ''}</td>
                <td>${sensor.maxTemp !== undefined ? sensor.maxTemp : ''}</td>
                <td>
                    ${sensor.boundPoint !== null && sensor.boundPoint !== undefined
                        ? `<span class="status-bound">#${sensor.boundPoint}</span>`
                        : `<span class="status-unbound">Unbound</span>`}
                </td>
                <td class="${errorText ? 'error-cell' : ''}">${errorText}</td>
                <td class="${alarmText ? 'alarm-cell' : ''}">${alarmText}</td>
                <td>
                    ${sensor.boundPoint === null || sensor.boundPoint === undefined
                        ? `<button onclick="bindPrompt('DS18B20','${sensor.romString}')">Bind</button>`
                        : `<button onclick="unbindSensor('DS18B20','${sensor.romString}')">Unbind</button>`}
                </td>
            `;
            dsTbody.appendChild(row);
        });
    }

    // PT Table
    const ptTbody = document.getElementById('ptTbody');
    ptTbody.innerHTML = '';
    if (ptSensors.length === 0) {
        ptTbody.innerHTML = '<tr><td colspan="10">No PT1000 sensors found.</td></tr>';
    } else {
        ptSensors.forEach((sensor, idx) => {
            const errorText = getErrorText(sensor.errorStatus);
            const alarmText = getAlarmText(sensor.alarmStatus);
            const statusClass = getStatusClass(sensor.errorStatus, sensor.alarmStatus);
            
            const row = document.createElement('tr');
            row.className = statusClass;
            row.innerHTML = `
                <td>${idx+1}</td>
                <td>${sensor.name || ''}</td>
                <td class="chip-select">${sensor.chipSelectPin !== undefined ? sensor.chipSelectPin : ''}</td>
                <td>${sensor.bus !== undefined && sensor.bus !== null ? sensor.bus : ''}</td>
                <td>${sensor.currentTemp !== undefined ? sensor.currentTemp : ''}</td>
                <td>${sensor.minTemp !== undefined ? sensor.minTemp : ''}</td>
                <td>${sensor.maxTemp !== undefined ? sensor.maxTemp : ''}</td>
                <td>
                    ${sensor.boundPoint !== null && sensor.boundPoint !== undefined
                        ? `<span class="status-bound">#${sensor.boundPoint}</span>`
                        : `<span class="status-unbound">Unbound</span>`}
                </td>
                <td class="${errorText ? 'error-cell' : ''}">${errorText}</td>
                <td class="${alarmText ? 'alarm-cell' : ''}">${alarmText}</td>
                <td>
                    ${sensor.boundPoint === null || sensor.boundPoint === undefined
                        ? `<button onclick="bindPrompt('PT1000','${sensor.chipSelectPin}')">Bind</button>`
                        : `<button onclick="unbindSensor('PT1000','${sensor.chipSelectPin}')">Unbind</button>`}
                </td>
            `;
            ptTbody.appendChild(row);
        });
    }
}


        // Prompt user for measurement point to bind
        function bindPrompt(type, id) {
            let point = prompt("Enter Measurement Point address to bind:");
            if (point === null || point.trim() === "") return;
            point = parseInt(point, 10);
            if (isNaN(point)) {
                alert("Invalid address!");
                return;
            }
            bindSensor(type, id, point);
        }

        // Bind sensor to point
        function bindSensor(type, id, pointAddress) {
            let payload = { pointAddress };
            if (type === "DS18B20") payload.romString = id;
            else if (type === "PT1000") payload.chipSelect = parseInt(id, 10);
            fetch('/api/sensor-bind', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            }).then(res => {
                if (res.ok) fetchSensors();
                else alert("Failed to bind sensor");
            });
        }

        // Unbind sensor
        function unbindSensor(type, id) {
            let payload = {};
            if (type === "DS18B20") payload.romString = id;
            else if (type === "PT1000") payload.chipSelect = parseInt(id, 10);
            fetch('/api/sensor-unbind', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            }).then(res => {
                if (res.ok) fetchSensors();
                else alert("Failed to unbind sensor");
            });
        }

        // Discover sensors
        document.getElementById('discoverBtn').onclick = function() {
            fetch('/api/discover', { method: 'POST' })
                .then(res => {
                    if (res.ok) fetchSensors();
                    else alert("Discovery failed");
                });
        };

        // Reset min/max
        document.getElementById('resetMinMaxBtn').onclick = function() {
            fetch('/api/reset-minmax', { method: 'POST' })
                .then(res => {
                    if (res.ok) fetchSensors();
                    else alert("Reset failed");
                });
        };

        // Auto-update
        setInterval(fetchSensors, UPDATE_INTERVAL);
        window.onload = fetchSensors;
    </script>
</body>
</html>

-------- [ Separator ] ------

File Name: docs/DEVELOPMENT_BRIEF.md
Size: 12.65 KB
Code:
# Temperature Controller Development Brief

## Table of Contents
1. [Overview](#overview)
2. [Alarm System Redesign](#alarm-system-redesign)
3. [Web Interface Redesign](#web-interface-redesign)
4. [OLED Display & LED Indicators](#oled-display--led-indicators)
5. [Modbus RTU Implementation](#modbus-rtu-implementation)
6. [System Architecture](#system-architecture)
7. [Documentation Requirements](#documentation-requirements)

## Overview

This document provides comprehensive specifications for rewriting the Temperature Controller system while maintaining hardware compatibility and core functionality. The main goals are:

- Improved alarm handling with configurable priorities and hysteresis
- Consistent and modern web interface with enhanced features
- Better OLED display and LED indication logic
- Enhanced Modbus RTU implementation with explicit configuration triggers
- Clear separation between sensors and measurement points
- Comprehensive documentation in English and Russian

### Key Constraints
- **Pin definitions must remain unchanged** (hardware is already assembled)
- **Libraries and basic class structure should remain the same**
- **ConfigAssist library's file handling must be preserved**
- **PCF8575 logic must remain as proven**
- **Logger system works well - minimize changes**

## Alarm System Redesign

### 1. Alarm Structure
All alarms should exist from initialization but can be disabled through configuration:

```cpp
class AlarmConfig {
    AlarmType type;           // HIGH_TEMP, LOW_TEMP, SENSOR_ERROR, SENSOR_DISCONNECTED
    AlarmPriority priority;   // CRITICAL, HIGH, MEDIUM, LOW, DISABLED
    bool enabled;             // true/false
    int16_t threshold;        // Temperature threshold
    int16_t hysteresis;       // Hysteresis value (e.g., 2°C)
    uint32_t acknowledgedDelay; // Time before re-activation after acknowledgment
};
```

### 2. Alarm Priority Configuration

#### Via Web Interface
- Single comprehensive table showing all measurement points
- Columns: Point Name, Current Temp, Low Threshold, High Threshold, Low Priority, High Priority, Sensor Error Priority
- Dropdown menus for priority selection: Critical, High, Medium, Low, Disabled
- Apply changes button with confirmation

#### Via Config File
Already implemented in CSV format - maintain current structure

#### Via Modbus RTU
- Use register 800-899 for alarm configuration
- 8-bit register per point: 
  - Bits 0-2: Low temp alarm priority (0-4, where 4=disabled)
  - Bits 3-5: High temp alarm priority
  - Bits 6-7: Sensor error priority
- **Important**: Configuration should only apply when master writes to specific trigger register (e.g., 899)

### 3. Alarm State Management

```cpp
enum class AlarmStage {
    NEW,          // Just triggered
    ACTIVE,       // Confirmed active (after delay)
    ACKNOWLEDGED, // Operator acknowledged
    CLEARED,      // Condition cleared but in hysteresis
    RESOLVED      // Fully resolved
};
```

### 4. Relay Control Logic

#### Hardware Configuration
- Relay 1: Siren
- Relay 2: Flash beacon
- Relay 3: Spare

#### Notification Scenarios

| Priority | Active State | Acknowledged State |
|----------|-------------|-------------------|
| CRITICAL | Siren ON + Beacon ON (constant) | Beacon ON (constant) |
| HIGH | Beacon ON (constant) | Beacon ON (blink 2s on/30s off) |
| MEDIUM | Beacon ON (blink 2s on/30s off) | Beacon OFF |
| LOW | No relay action | No relay action |

### 5. Hysteresis Implementation

```cpp
// Example for high temperature alarm
if (temperature > (highThreshold + hysteresis)) {
    // Trigger alarm
} else if (temperature < highThreshold && alarmActive) {
    // Clear alarm
}
```

### 6. Acknowledged Alarm Re-activation
- Configurable delays per priority level
- After acknowledgment, alarm moves to ACKNOWLEDGED state
- Timer starts, and after delay expires, alarm returns to ACTIVE if condition still exists

## Web Interface Redesign

### 1. Navigation Structure
```
- Dashboard (Main page with all points overview)
- Alarms
  - Active Alarms
  - Alarm Configuration
  - Alarm History
- Points
  - Point Configuration
  - Sensor Binding
- System
  - General Settings
  - Network Settings
  - Time Settings
  - Modbus Settings
- Logs
  - Event Logs
  - Temperature Logs
  - Download Logs
```

### 2. Dashboard Page
- Table with all measurement points
- Columns: Point #, Name, Current Temp, Min, Max, Status, Trend Icon
- Color coding: Red (alarm), Yellow (warning), Green (normal), Gray (no sensor)
- Click trend icon to open modal with temperature chart
- Auto-refresh every 5 seconds

### 3. Alarm Configuration Page
Single table showing all configurable parameters:
```html
<table>
  <tr>
    <th>Point</th>
    <th>Name</th>
    <th>Low Threshold</th>
    <th>Low Priority</th>
    <th>High Threshold</th>
    <th>High Priority</th>
    <th>Error Priority</th>
    <th>Hysteresis</th>
  </tr>
  <!-- Dynamic rows for each point -->
</table>
```

### 4. Temperature Trend Modal
- Chart.js implementation showing last 24 hours
- Markers for alarm events with tooltips
- Data from log files
- Y-axis: Temperature, X-axis: Time
- Show threshold lines

### 5. Sensor Binding Interface
- Replace point number input with dropdown showing point names
- Add autocomplete functionality if possible
- Show current binding status clearly
- Validate point type matches sensor type

### 6. Russian Translation
All pages must support Russian language with toggle in header:
```javascript
const translations = {
  en: { 
    "dashboard": "Dashboard",
    "temperature": "Temperature",
    // ... 
  },
  ru: { 
    "dashboard": "Панель управления",
    "temperature": "Температура",
    // ...
  }
};
```

### 7. Consistent Styling
- Use modern CSS framework (Bootstrap 5 or similar)
- Dark mode support
- Consistent color scheme:
  - Primary: #2196F3 (blue)
  - Success: #4CAF50 (green)
  - Warning: #FF9800 (orange)
  - Danger: #F44336 (red)
- Responsive design for mobile access

## OLED Display & LED Indicators

### 1. Display States

#### Sleep Mode
- Display off after configurable timeout (default 60s)
- Wake on:
  - Button press
  - New alarm
  - System status request

#### Normal Operation Mode
- Cycle through points with bound sensors only
- Format:
  ```
  Point 01: Room A
  Temp: 23.5°C
  Min: 20.1  Max: 25.3
  Status: Normal
  ```
- 10-second display per point

#### Alarm Display Mode
- Show highest priority unacknowledged alarm first
- Format:
  ```
  ALARM: HIGH TEMP
  Point 05: Server Room
  Temp: 45.2°C (>40°C)
  Priority: CRITICAL
  Time: 14:23:15
  ```
- No cycling until acknowledged
- After all acknowledged, cycle through acknowledged alarms

#### System Status Mode
- Enter: Long button press (>3s)
- Exit: Another long press or timeout (30s)
- Pages (cycle with short press):
  1. Network info (IP, WiFi status)
  2. System stats (Points configured, Active sensors)
  3. Alarm summary (by priority)
  4. Modbus status

### 2. LED Indicator Logic

| LED Color | Purpose | Behavior |
|-----------|---------|----------|
| RED | Critical alarm | Solid when active, blink when acknowledged |
| YELLOW | High priority alarm | Solid when active, slow blink when acknowledged |
| BLUE | Medium priority alarm | Slow blink when active, off when acknowledged |
| GREEN | System OK | Solid when no alarms, off otherwise |

### 3. Button Handling
- **Short press (<1s)**:
  - Acknowledge current alarm
  - Navigate in system status mode
  - Wake display
- **Long press (>3s)**:
  - Enter/exit system status mode

### 4. Scrolling Improvement
Current scrolling should be circular:
```
"This is a long text that needs scrolling     This is a long text..."
```
Not jumping back to start.

## Modbus RTU Implementation

### 1. Extended Register Map

| Register Range | Description | Type | Access |
|----------------|-------------|------|--------|
| 0-799 | Existing registers | Various | R/R+W |
| 800-859 | Alarm configuration | UINT8 | R+W |
| 860-889 | Relay control | UINT16 | R+W |
| 890-899 | System commands | UINT16 | W |
| 900-959 | Point names (2 chars/register) | UINT16 | R |
| 960-999 | Extended status | UINT16 | R |

### 2. Alarm Configuration Registers (800-859)
One register per measurement point, 8-bit configuration:
```
Bit 7-6: Sensor error priority (0-3)
Bit 5-3: High temp alarm priority (0-4, 4=disabled)
Bit 2-0: Low temp alarm priority (0-4, 4=disabled)
```

### 3. Relay Control Registers (860-862)
- 860: Relay 1 control (0=Auto, 1=Force Off, 2=Force On)
- 861: Relay 2 control
- 862: Relay 3 control

### 4. System Command Register (899)
Write-only trigger register:
- 0x0001: Apply alarm configuration
- 0x0002: Reset min/max values
- 0x0003: Acknowledge all alarms
- 0x0004: Reboot system

### 5. Configuration Safety
- Configuration changes are buffered
- Only applied when command register triggered
- Validate all values before applying
- Log all configuration changes

## System Architecture

### 1. Class Hierarchy
```
TemperatureController
├── MeasurementPoint (60 instances)
│   ├── Sensor* (bound sensor reference)
│   └── AlarmConfig[] (configured alarms)
├── Sensor[] (discovered sensors)
├── Alarm[] (active alarms)
├── RegisterMap
└── AlarmManager (new class)
    ├── Relay control
    ├── LED control
    └── Priority handling
```

### 2. Data Flow
1. Sensors read temperature → Update MeasurementPoint
2. MeasurementPoint checks thresholds → Create/update Alarms
3. AlarmManager processes alarms → Control outputs
4. RegisterMap reflects current state
5. Web/Modbus interfaces read/write through controller

### 3. Key Principles
- **Separation of Concerns**: Sensors measure, Points aggregate, Alarms notify
- **Single Source of Truth**: MeasurementPoint holds authoritative data
- **Event-Driven**: Changes trigger updates, not polling
- **Fail-Safe**: Sensor errors disable temperature alarms for that point

## Documentation Requirements

### 1. Technical Documentation (English)
- **System Architecture**: Class diagrams, data flow
- **API Reference**: All public methods and interfaces
- **Modbus Register Map**: Complete table with examples
- **Configuration Guide**: All configuration options
- **Troubleshooting Guide**: Common issues and solutions

### 2. User Manual (Russian)
- **Руководство по установке**: Hardware connections, initial setup
- **Веб-интерфейс**: Screenshots and descriptions
- **Настройка сигнализации**: Alarm configuration guide
- **Работа с Modbus**: Integration examples
- **Обслуживание**: Maintenance procedures

### 3. Code Documentation
- All classes with Doxygen-style comments
- Complex algorithms explained inline
- Configuration file examples
- README files in each major directory

### 4. Log File Documentation
Current structure (maintain):
- `/data/YYYY-MM-DD_temps.csv`: Temperature readings
- `/alarms/YYYY-MM-DD_alarms.csv`: Alarm state changes
- `/events/YYYY-MM-DD_events.log`: System events

## Implementation Notes

### 1. ConfigAssist Integration
- Study existing implementation in ConfigManager.cpp
- Maintain YAML configuration structure
- Use ConfigAssist's file handling for all config files

### 2. Event Log Optimization
Current issue: "20 alarms created" generates 20 log entries
Solution: Batch similar events within 1-second window:
```cpp
logger.info("ALARM", "Multiple alarms created: HIGH_TEMP(5), LOW_TEMP(3), SENSOR_ERROR(2)");
```

### 3. Display Sleep/Wake
- Use hardware timer for reliable timeout
- Store display state to handle wake events properly
- Smooth transitions (fade in/out if OLED supports)

### 4. Web Interface Modularity
- Separate HTML, CSS, JS files
- Use template system for consistent headers/footers
- Implement API endpoints for all data access
- Cache static resources

### 5. Testing Considerations
- Unit tests for alarm logic
- Integration tests for Modbus commands
- Web interface testing on multiple browsers
- Stress testing with maximum sensors/alarms

## Version Control and Migration

### 1. Database Migration
- Preserve existing sensor bindings
- Convert alarm settings to new format
- Backup before migration

### 2. Configuration Compatibility
- Support old config format temporarily
- Automatic conversion on first boot
- Log all conversions

### 3. Firmware Update Process
- OTA update support
- Rollback capability
- Version checking in web interface

## Performance Requirements

- Web interface response: <500ms
- Sensor reading cycle: <5s for all 60 points
- Alarm detection latency: <1s
- Modbus response time: <100ms
- Display update rate: 10Hz minimum
- Log write buffering: Batch writes every 10s

## Security Considerations

- Web interface authentication (basic auth minimum)
- Modbus write protection (optional password)
- Configuration backup encryption
- Secure OTA updates
- Rate limiting on API endpoints

-------- [ Separator ] ------

File Name: docs/MODBUS_REGISTER_MAP.md
Size: 10.21 KB
Code:
# Modbus RTU Register Map Documentation

## Overview
This document describes the complete Modbus RTU register map for the Temperature Controller system. All registers use Modbus function codes 03 (Read Holding Registers), 06 (Write Single Register), and 16 (Write Multiple Registers).

## Connection Parameters
- **Protocol**: Modbus RTU
- **Interface**: RS-485
- **Default Address**: 1 (configurable 1-247)
- **Baud Rate**: 9600 (configurable: 4800, 9600, 19200, 38400, 57600, 115200)
- **Data Bits**: 8
- **Parity**: None
- **Stop Bits**: 1

## Register Map

### Device Information (Registers 0-99) - Read Only

| Register | Description | Data Type | Range | Notes |
|----------|-------------|-----------|-------|-------|
| 0 | Device ID/Model | UINT16 | 0-65535 | User configurable |
| 1 | Firmware Version | UINT16 | 0-9999 | Format: XXYY = XX.YY |
| 2 | Active DS18B20 Count | UINT16 | 0-50 | Currently bound sensors |
| 3 | Active PT1000 Count | UINT16 | 0-10 | Currently bound sensors |
| 4 | System Status | UINT16 | Bitmap | See status bits below |
| 5 | Total Alarm Count | UINT16 | 0-65535 | All active alarms |
| 6 | Critical Alarm Count | UINT16 | 0-65535 | Active critical alarms |
| 7 | High Priority Alarm Count | UINT16 | 0-65535 | Active high alarms |
| 8 | Medium Priority Alarm Count | UINT16 | 0-65535 | Active medium alarms |
| 9 | Low Priority Alarm Count | UINT16 | 0-65535 | Active low alarms |
| 10 | System Uptime (Hours) | UINT16 | 0-65535 | Hours since boot |
| 11-99 | Reserved | - | - | Future use |

#### System Status Bits (Register 4)
- Bit 0: WiFi Connected (1=connected)
- Bit 1: SD Card Present (1=present)
- Bit 2: RTC Valid (1=valid time)
- Bit 3: Any Alarm Active (1=active)
- Bit 4: Configuration Error (1=error)
- Bit 5-15: Reserved

### Temperature Data (Registers 100-399)

#### Current Temperature (100-199)
| Register Range | Description | Data Type | Range | Units |
|----------------|-------------|-----------|-------|-------|
| 100-149 | DS18B20 Points 0-49 | INT16 | -400 to 2000 | 0.1°C |
| 150-159 | PT1000 Points 50-59 | INT16 | -400 to 2000 | 0.1°C |
| 160-199 | Reserved | - | - | - |

#### Minimum Temperature (200-299)
| Register Range | Description | Data Type | Range | Units |
|----------------|-------------|-----------|-------|-------|
| 200-249 | DS18B20 Points 0-49 | INT16 | -400 to 2000 | 0.1°C |
| 250-259 | PT1000 Points 50-59 | INT16 | -400 to 2000 | 0.1°C |
| 260-299 | Reserved | - | - | - |

#### Maximum Temperature (300-399)
| Register Range | Description | Data Type | Range | Units |
|----------------|-------------|-----------|-------|-------|
| 300-349 | DS18B20 Points 0-49 | INT16 | -400 to 2000 | 0.1°C |
| 350-359 | PT1000 Points 50-59 | INT16 | -400 to 2000 | 0.1°C |
| 360-399 | Reserved | - | - | - |

### Alarm Status (Registers 400-499) - Read Only

| Register Range | Description | Data Type | Bitmap Definition |
|----------------|-------------|-----------|-------------------|
| 400-449 | DS18B20 Alarm Status | UINT16 | See alarm bits below |
| 450-459 | PT1000 Alarm Status | UINT16 | See alarm bits below |
| 460-499 | Reserved | - | - |

#### Alarm Status Bits
- Bit 0: Low Temperature Alarm Active
- Bit 1: High Temperature Alarm Active
- Bit 2: Low Temperature Alarm Acknowledged
- Bit 3: High Temperature Alarm Acknowledged
- Bit 4: Sensor Error
- Bit 5: Sensor Disconnected
- Bit 6-7: Alarm Priority (0=Low, 1=Medium, 2=High, 3=Critical)
- Bit 8-15: Reserved

### Error Status (Registers 500-599) - Read Only

| Register Range | Description | Data Type | Bitmap Definition |
|----------------|-------------|-----------|-------------------|
| 500-549 | DS18B20 Error Status | UINT16 | See error bits below |
| 550-559 | PT1000 Error Status | UINT16 | See error bits below |
| 560-599 | Reserved | - | - |

#### Error Status Bits
- Bit 0: Communication Error
- Bit 1: Out of Range
- Bit 2: Sensor Disconnected
- Bit 3: CRC Error
- Bit 4: Configuration Error
- Bit 5-15: Reserved

### Alarm Thresholds (Registers 600-799) - Read/Write

#### Low Temperature Thresholds (600-699)
| Register Range | Description | Data Type | Range | Units |
|----------------|-------------|-----------|-------|-------|
| 600-649 | DS18B20 Low Thresholds | INT16 | -400 to 2000 | 0.1°C |
| 650-659 | PT1000 Low Thresholds | INT16 | -400 to 2000 | 0.1°C |
| 660-699 | Reserved | - | - | - |

#### High Temperature Thresholds (700-799)
| Register Range | Description | Data Type | Range | Units |
|----------------|-------------|-----------|-------|-------|
| 700-749 | DS18B20 High Thresholds | INT16 | -400 to 2000 | 0.1°C |
| 750-759 | PT1000 High Thresholds | INT16 | -400 to 2000 | 0.1°C |
| 760-799 | Reserved | - | - | - |

### Alarm Configuration (Registers 800-859) - Read/Write

| Register Range | Description | Data Type | Bit Definition |
|----------------|-------------|-----------|----------------|
| 800-849 | DS18B20 Alarm Config | UINT8 | See config bits |
| 850-859 | PT1000 Alarm Config | UINT8 | See config bits |

#### Alarm Configuration Bits
- Bits 0-2: Low Temperature Priority (0-4, 4=Disabled)
- Bits 3-5: High Temperature Priority (0-4, 4=Disabled)
- Bits 6-7: Sensor Error Priority (0-3)

Priority Values:
- 0: Low
- 1: Medium
- 2: High
- 3: Critical
- 4: Disabled (for temperature alarms only)

### Relay Control (Registers 860-869) - Read/Write

| Register | Description | Values | Notes |
|----------|-------------|--------|-------|
| 860 | Relay 1 (Siren) Control | 0=Auto, 1=Force Off, 2=Force On | Auto follows alarm logic |
| 861 | Relay 2 (Beacon) Control | 0=Auto, 1=Force Off, 2=Force On | Auto follows alarm logic |
| 862 | Relay 3 (Spare) Control | 0=Auto, 1=Force Off, 2=Force On | Auto follows alarm logic |
| 863 | Relay 1 Current State | 0=Off, 1=On | Read only |
| 864 | Relay 2 Current State | 0=Off, 1=On | Read only |
| 865 | Relay 3 Current State | 0=Off, 1=On | Read only |
| 866-869 | Reserved | - | - |

### Hysteresis Configuration (Registers 870-889) - Read/Write

| Register Range | Description | Data Type | Range | Units |
|----------------|-------------|-----------|-------|-------|
| 870-879 | Temperature Hysteresis | UINT16 | 0-100 | 0.1°C |
| 880-889 | Reserved | - | - | - |

### System Commands (Registers 890-899) - Write Only

| Register | Command | Value | Description |
|----------|---------|-------|-------------|
| 899 | Execute Command | 0x0001 | Apply alarm configuration |
| | | 0x0002 | Reset all min/max values |
| | | 0x0003 | Acknowledge all alarms |
| | | 0x0004 | System reboot |
| | | 0x0005 | Save configuration |
| | | 0x0006 | Restore defaults |
| | | 0x0007 | Clear alarm history |
| | | 0x0008 | Force sensor discovery |

### Point Names (Registers 900-959) - Read Only

Each measurement point name uses 10 registers (20 characters):
- Registers 900-909: Point 0 name (DS18B20)
- Registers 910-919: Point 1 name (DS18B20)
- ...continues for first 6 points

Format: 2 ASCII characters per register, high byte first

### Extended Configuration (Registers 960-999) - Read/Write

| Register | Description | Data Type | Range | Units |
|----------|-------------|-----------|-------|-------|
| 960 | Acknowledged Delay Critical | UINT16 | 0-3600 | Seconds |
| 961 | Acknowledged Delay High | UINT16 | 0-3600 | Seconds |
| 962 | Acknowledged Delay Medium | UINT16 | 0-3600 | Seconds |
| 963 | Acknowledged Delay Low | UINT16 | 0-3600 | Seconds |
| 964 | Display Sleep Timeout | UINT16 | 0-3600 | Seconds (0=never) |
| 965 | Alarm Display Cycle Time | UINT16 | 1-60 | Seconds |
| 966 | Beacon Blink On Time | UINT16 | 1-60 | Seconds |
| 967 | Beacon Blink Off Time | UINT16 | 1-300 | Seconds |
| 968-999 | Reserved | - | - | - |

## Usage Examples

### Reading Current Temperature
To read temperature from Point 5 (DS18B20):
```
Request:  01 03 00 69 00 01 [CRC]
Response: 01 03 02 00 EB [CRC]
Result: 235 = 23.5°C
```

### Setting High Temperature Threshold
To set high threshold for Point 0 to 30.0°C:
```
Request:  01 06 02 BC 01 2C [CRC]
Response: 01 06 02 BC 01 2C [CRC]
Result: Threshold set to 300 = 30.0°C
```

### Configuring Alarm Priorities
To set Point 0 with High=Critical, Low=Medium, Error=High:
```
Value = (High << 3) | Low = (3 << 3) | 1 = 0x19
Request:  01 06 03 20 00 19 [CRC]
```

### Applying Configuration
After changing alarm configuration, trigger application:
```
Request:  01 06 03 83 00 01 [CRC]
Response: 01 06 03 83 00 01 [CRC]
```

### Reading Multiple Registers
To read all current temperatures for DS18B20 points 0-9:
```
Request:  01 03 00 64 00 0A [CRC]
Response: 01 03 14 00 E1 00 E7 00 EA 00 E5 00 E8 00 E6 00 E9 00 EC 00 E4 00 E3 [CRC]
```

## Error Responses

| Exception Code | Description | Possible Cause |
|----------------|-------------|----------------|
| 01 | Illegal Function | Unsupported function code |
| 02 | Illegal Data Address | Register address out of range |
| 03 | Illegal Data Value | Value outside allowed range |
| 04 | Device Failure | Internal error |

## Best Practices

1. **Configuration Changes**
   - Always read current configuration before modifying
   - Apply changes using command register 899
   - Verify changes by reading back

2. **Alarm Management**
   - Check alarm status before acknowledging
   - Use bulk acknowledge only when necessary
   - Monitor relay states after changes

3. **Performance**
   - Read multiple registers in one request when possible
   - Limit polling frequency to 1-5 seconds
   - Use exception responses to detect issues

4. **Error Handling**
   - Implement timeout handling (recommended 1 second)
   - Retry failed requests up to 3 times
   - Log all communication errors

## Integration Example

```python
import minimalmodbus

# Configure instrument
instrument = minimalmodbus.Instrument('/dev/ttyUSB0', 1)
instrument.serial.baudrate = 9600
instrument.serial.timeout = 1.0

# Read current temperature from point 0
temp_raw = instrument.read_register(100, 0, 3, True)
temperature = temp_raw / 10.0
print(f"Temperature: {temperature}°C")

# Set high alarm threshold to 35°C
instrument.write_register(700, 350, 0, 6, True)

# Configure alarm priority (High=Critical)
instrument.write_register(800, 0x18, 0, 6, False)

# Apply configuration
instrument.write_register(899, 1, 0, 6, False)
```

## Change Log

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2024-01-01 | Initial release |
| 2.0 | 2024-12-30 | Added alarm configuration, relay control, extended status |

-------- [ Separator ] ------

File Name: docs/ONBOARDING_RESULTS.md
Size: 9.14 KB
Code:
# Onboarding Results - Temperature Controller Project

## MCP Tools Available
- **Desktop Commander (MCP_DOCKER)**: Full access to file operations, process management, GitHub integration
- **N8N MCP**: Node automation tools available 
- **IDE integration**: Code diagnostics and execution available
- **Other MCP servers**: No additional resources found

## Project Structure Analysis

### Hardware Platform
- **ESP32-WROVER-KIT** based industrial temperature monitoring system
- **Framework**: Arduino with PlatformIO build system
- **Target Environment**: Industrial applications with multiple sensor support

### Key Hardware Components
- **OneWire sensors**: 4 buses (pins 4, 5, 18, 19) for DS18B20 temperature sensors
- **PT1000/PT100 RTD sensors**: 4 SPI CS pins (32, 33, 26, 27) via MAX31865 modules
- **RS485 Modbus RTU**: Communication interface (pins 22, 23)
- **I2C interface**: OLED display and PCF8575 expander (pins 21, 25)
- **SD Card**: Data logging (CS pin 0)
- **Single button interface**: For user interaction
- **Relay outputs**: 2 relays + spare for alarm indication
- **LED indicators**: Multi-color status indication

### Library Dependencies (from platformio.ini)
- **Adafruit MAX31865**: PT1000/PT100 sensor interface
- **ESPAsyncWebServer**: Web interface framework
- **ArduinoJson**: JSON data handling
- **DallasTemperature/OneWire**: DS18B20 sensor support
- **eModbus**: Modbus RTU communication
- **ConfigAssist**: Configuration management with web portal
- **PCF8575**: I/O expander for indicator interface
- **U8g2**: OLED display library
- **CSV-Parser**: Configuration file handling
- **RTClib/NTPClient**: Time management

## Code Architecture Analysis

### Core Classes and Responsibilities

#### 1. TemperatureController (Main Controller)
- **Primary coordinator** for the entire system
- Manages 50 DS18B20 measurement points + 10 PT1000 points
- Handles sensor discovery, binding, and measurement updates
- **Alarm management**: Creates, processes, and manages alarm lifecycle
- **Register map integration**: Updates Modbus registers with current data
- **JSON API**: Provides system status, sensor data, and alarm information

#### 2. Sensor Classes
- **Sensor base class**: Abstract interface for temperature sensors
- **Physical device abstraction**: ROM numbers, chip selects, communication details
- **Separate from measurement points**: Sensors are devices, points are logical locations

#### 3. MeasurementPoint Class
- **Logical measurement locations**: Represents places/equipment being monitored
- **Sensor binding**: Links physical sensors to logical points
- **Threshold management**: Stores alarm thresholds and configuration
- **Data aggregation**: Min/max values, current readings, alarm states

#### 4. Alarm System
- **AlarmType**: HIGH_TEMP, LOW_TEMP, SENSOR_ERROR, SENSOR_DISCONNECTED
- **AlarmPriority**: CRITICAL, HIGH, MEDIUM, LOW, DISABLED
- **AlarmStage**: NEW, ACTIVE, ACKNOWLEDGED, CLEARED, RESOLVED
- **Priority-based notification**: Different LED/relay behaviors per priority
- **Acknowledgment system**: Button press handling with re-activation delays

#### 5. IndicatorInterface
- **PCF8575 I/O expander integration**: Controls LEDs and relays
- **OLED display management**: Shows status, alarms, system information
- **Button handling**: Single button for navigation and acknowledgment
- **Display modes**: Normal operation, alarm display, system status

#### 6. Configuration Management
- **ConfigAssist integration**: Web-based configuration portal
- **CSV file handling**: Sensor binding and alarm configuration
- **Modbus configuration**: RTU settings, device parameters
- **Persistent storage**: YAML configuration with LittleFS

#### 7. Logging System
- **Daily file rotation**: Separate files for temperatures, alarms, events
- **Directory structure**: /data, /alarms, /events
- **CSV format**: Temperature logs for charting and analysis
- **Event aggregation**: System status and configuration changes

#### 8. Modbus RTU Server
- **Register map**: 800+ registers for data and configuration
- **Real-time data**: Temperature readings, alarm status, system info
- **Configuration interface**: Threshold and alarm priority settings
- **Safety mechanisms**: Explicit trigger registers for configuration changes

#### 9. Web Interface
- **Multi-page application**: Dashboard, alarms, configuration, logs
- **Real-time updates**: Auto-refresh with current data
- **Configuration tools**: Sensor binding, alarm setup, system settings
- **File download**: Log file access and system backup

### User Interaction Patterns

#### Physical Interface (Single Button)
- **Short press**: Acknowledge alarms, navigate menus, wake display
- **Long press**: Enter/exit system status mode
- **Display wake**: Button press or new alarm events

#### Web Interface
- **Dashboard**: Overview of all measurement points with status
- **Alarm management**: Configuration and active alarm viewing
- **Sensor binding**: Dropdown-based point assignment
- **System configuration**: Network, time, Modbus settings

#### Modbus RTU Interface
- **Industrial integration**: SCADA/PLC connectivity
- **Read operations**: Temperature data, alarm status, system info
- **Write operations**: Threshold configuration, relay control
- **Safety features**: Explicit configuration triggers

## Key Findings and Requirements

### Main Requirements Analysis
Based on `docs/main_requirements.md` and `docs/DEVELOPMENT_BRIEF.md`:

1. **Hysteresis implementation needed**: Prevent alarm oscillation
2. **Consistent display/LED logic**: Current implementation has issues
3. **Enhanced alarm configuration**: Single comprehensive interface
4. **Modbus safety**: Explicit triggers for configuration changes
5. **Sensor vs. Point separation**: Clear distinction in user interface
6. **Button handling**: Single button for all interactions
7. **Circular scrolling**: Improve text display behavior
8. **Relay control**: Modbus-accessible relay management
9. **Temperature trends**: Modal-based charts from log data
10. **Russian translation**: Complete UI localization

### Technical Constraints
- **Hardware compatibility**: Pin definitions cannot change
- **Library preservation**: Keep proven implementations (PCF8575, ConfigAssist)
- **Logging system**: Current structure works well, minimal changes needed
- **Class architecture**: Maintain separation of concerns

### System Status
- **Development stage**: Feature-complete but requires refinement
- **Known issues**: Indicator interface logic, alarm display inconsistency
- **Missing features**: Hysteresis, enhanced web UI, trend charts
- **Documentation**: Needs comprehensive Modbus register documentation

## Next Steps Recommendation

The system has a solid foundation with good OOP design and separation of concerns. The main development focus should be on:

1. **Alarm system refinement**: Hysteresis and improved display logic
2. **Web interface enhancement**: Modern UI with trend charts
3. **Configuration safety**: Modbus trigger mechanisms
4. **Documentation**: Complete register map and usage examples
5. **User experience**: Consistent display behavior and navigation

The codebase shows good industrial practices with proper error handling, logging, and communication interfaces. The modular design will support the required enhancements effectively.

## Updated Assessment (Current Onboarding)

### MCP Tools Status
✅ **All MCP Tools Working**: Desktop Commander, N8N MCP, IDE integration, and Context7 are fully operational and ready for development.

### Current Project State Analysis

The project has comprehensive documentation and a well-structured codebase. Key observations:

#### Code Architecture Review
- **Solid OOP Foundation**: Clear separation between Sensor (physical devices) and MeasurementPoint (logical locations) classes
- **Comprehensive Alarm System**: AlarmType, AlarmPriority, AlarmStage enums with full lifecycle management
- **Proven Libraries**: PCF8575, U8g2, ConfigAssist, DallasTemperature, and Adafruit MAX31865 are properly integrated
- **Modular Design**: TemperatureController acts as coordinator, IndicatorInterface handles display/LEDs, RegisterMap manages Modbus

#### Known Issues from Requirements Analysis
1. **Hysteresis Missing**: Critical for alarm stability - needs implementation
2. **Indicator Logic Inconsistent**: Display and LED behaviors need standardization  
3. **Alarm Configuration UX**: Current modal approach needs improvement
4. **Modbus Safety**: Explicit triggers needed for configuration writes
5. **Button Handling**: Single button needs refined logic for navigation
6. **Display Scrolling**: Circular scrolling behavior needs implementation

#### Development Priorities
Based on `main_requirements.md` and `DEVELOPMENT_BRIEF.md`:
1. Implement hysteresis in alarm threshold checking
2. Fix indicator interface consistency issues
3. Enhance alarm configuration web interface
4. Add Modbus relay control capabilities
5. Improve OLED display scrolling behavior
6. Create comprehensive Modbus register documentation

#### Ready for Planning Stage
The onboarding is complete. The codebase is well-understood, documentation is comprehensive, and all development tools are operational. Ready to proceed to the Planning stage to create a detailed implementation plan addressing the identified requirements.
-------- [ Separator ] ------

File Name: docs/PLANNING_RESULTS.md
Size: 34.75 KB
Code:
# Temperature Controller Development Planning Results

## Overview

This document provides a comprehensive step-by-step implementation plan for enhancing the Temperature Controller system based on requirements analysis from `main_requirements.md` and `DEVELOPMENT_BRIEF.md`.

## Priority Matrix

### Critical Issues (Must Fix)
1. **Hysteresis Implementation** - Critical for alarm stability
2. **Indicator Interface Logic** - Display/LED inconsistencies causing user confusion
3. **Alarm Configuration UX** - Current modal approach needs complete redesign

### High Priority Features  
4. **Modbus Safety Mechanisms** - Explicit triggers for configuration writes
5. **Single Button Navigation** - Improve user interaction consistency
6. **Circular Display Scrolling** - Better text display behavior

### Medium Priority Enhancements
7. **Temperature Trend Charts** - Modal-based charts with log data
8. **Relay Modbus Control** - RTU-accessible relay management
9. **Russian Translation** - Complete UI localization

## Detailed Implementation Plan

### Phase 1: Core Alarm System Fixes (Priority: Critical)

#### Step 1.1: Implement Hysteresis in Alarm Class
**Target File**: `include/Alarm.h`, `src/Alarm.cpp`

**Implementation Details**:
```cpp
// In Alarm class, add hysteresis support
private:
    int16_t _hysteresis;  // Already exists
    
// Modify _checkCondition() method
bool Alarm::_checkCondition() {
    if (!_source) return false;
    
    float currentTemp = _source->getCurrentTemperature();
    float threshold = (_type == AlarmType::HIGH_TEMPERATURE) ? 
        _source->getHighThreshold() : _source->getLowThreshold();
    
    bool conditionMet = false;
    
    if (_type == AlarmType::HIGH_TEMPERATURE) {
        if (_stage == AlarmStage::NEW || _stage == AlarmStage::CLEARED) {
            conditionMet = (currentTemp > threshold + _hysteresis);
        } else if (_stage == AlarmStage::ACTIVE || _stage == AlarmStage::ACKNOWLEDGED) {
            conditionMet = (currentTemp > threshold);
        }
    } else if (_type == AlarmType::LOW_TEMPERATURE) {
        if (_stage == AlarmStage::NEW || _stage == AlarmStage::CLEARED) {
            conditionMet = (currentTemp < threshold - _hysteresis);
        } else if (_stage == AlarmStage::ACTIVE || _stage == AlarmStage::ACKNOWLEDGED) {
            conditionMet = (currentTemp < threshold);
        }
    }
    
    return conditionMet;
}
```

**Testing**:
- Unit test with temperature values around thresholds
- Verify alarm doesn't oscillate with ±1°C temperature variations
- Test with different hysteresis values (1°C, 2°C, 5°C)

**Debug Output**:
```cpp
Serial.printf("HYSTERESIS: Point %d, Temp: %.1f, Threshold: %.1f, Hysteresis: %d, Condition: %s\n",
    _source->getAddress(), currentTemp, threshold, _hysteresis, conditionMet ? "MET" : "NOT_MET");
```

#### Step 1.2: Fix Indicator Interface Logic  
**Target File**: `src/IndicatorInterface.cpp`

**Issues to Fix**:
1. Inconsistent LED blinking patterns
2. Display state management problems  
3. Button handling reliability

**Implementation**:
```cpp
// Add state machine for display management
enum class DisplayState {
    NORMAL,           // Normal operation display
    ALARM_ACTIVE,     // Showing active alarms
    ALARM_ACK,        // Showing acknowledged alarms  
    SYSTEM_STATUS,    // System status mode (long press)
    OK_DISPLAY        // Showing OK after acknowledgment
};

// In IndicatorInterface class
private:
    DisplayState _currentDisplayState;
    unsigned long _displayStateTime;
    
// Centralized LED control method
void IndicatorInterface::updateLEDStates(AlarmPriority highestPriority, bool hasAcknowledged) {
    // Clear all LEDs first
    writePort("RED_LED", false);
    writePort("YELLOW_LED", false);
    writePort("BLUE_LED", false);
    
    switch(highestPriority) {
        case AlarmPriority::PRIORITY_CRITICAL:
            writePort("RED_LED", true);
            writePort("YELLOW_LED", true);
            break;
        case AlarmPriority::PRIORITY_HIGH:
            writePort("RED_LED", !hasAcknowledged);
            writePort("YELLOW_LED", true);
            break;
        case AlarmPriority::PRIORITY_MEDIUM:
            if (!hasAcknowledged) {
                startBlinking("YELLOW_LED", 2000, 30000);
            } else {
                stopBlinking("YELLOW_LED");
                writePort("YELLOW_LED", false);
            }
            break;
        case AlarmPriority::PRIORITY_LOW:
            // No LED indication for low priority
            break;
    }
}
```

**Testing**:
- Test all priority levels with different alarm states
- Verify LED states match requirements table
- Test button press handling reliability

#### Step 1.3: Redesign Alarm Configuration Web Interface
**Target File**: `data/alarms.html`

**Current Problem**: Modal-based approach shows one alarm at a time
**Solution**: Single comprehensive table showing all points

**Implementation**:
```html
<!-- Replace modal with comprehensive table -->
<div class="alarm-config-container">
    <table class="alarm-table">
        <thead>
            <tr>
                <th>Point</th>
                <th>Name</th>
                <th>Current Temp</th>
                <th>Low Threshold</th>
                <th>Low Priority</th>
                <th>High Threshold</th>
                <th>High Priority</th>
                <th>Error Priority</th>
                <th>Hysteresis</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody id="alarmConfigTable">
            <!-- Dynamic rows populated by JavaScript -->
        </tbody>
    </table>
    <button id="applyAllChanges" class="btn-primary">Apply All Changes</button>
</div>
```

**JavaScript Implementation**:
```javascript
function loadAlarmConfiguration() {
    fetch('/api/alarm-config')
        .then(response => response.json())
        .then(data => {
            const tbody = document.getElementById('alarmConfigTable');
            tbody.innerHTML = '';
            
            data.points.forEach(point => {
                const row = createAlarmConfigRow(point);
                tbody.appendChild(row);
            });
        });
}

function createAlarmConfigRow(point) {
    const row = document.createElement('tr');
    row.innerHTML = `
        <td>${point.address}</td>
        <td><input type="text" value="${point.name}" data-field="name" data-point="${point.address}"></td>
        <td class="temp-display">${point.currentTemp}°C</td>
        <td><input type="number" value="${point.lowThreshold}" data-field="lowThreshold" data-point="${point.address}"></td>
        <td>
            <select data-field="lowPriority" data-point="${point.address}">
                <option value="0">Disabled</option>
                <option value="1">Low</option>
                <option value="2">Medium</option>
                <option value="3">High</option>
                <option value="4">Critical</option>
            </select>
        </td>
        <!-- Similar structure for other fields -->
    `;
    return row;
}
```

**API Endpoint Extensions Required**:
```cpp
// New/Modified API endpoints needed in main.cpp or separate API handler

// 1. Enhanced alarm configuration endpoint
server.on("/api/alarm-config", HTTP_GET, [](AsyncWebServerRequest *request) {
    // Return comprehensive alarm config for all points
    JsonDocument doc;
    JsonArray points = doc["points"].to<JsonArray>();
    
    for (int i = 0; i < 60; i++) {
        JsonObject point = points.add<JsonObject>();
        MeasurementPoint* mp = tempController.getMeasurementPoint(i);
        if (mp) {
            point["address"] = i;
            point["name"] = mp->getName();
            point["currentTemp"] = mp->getCurrentTemperature();
            point["lowThreshold"] = mp->getLowThreshold();
            point["highThreshold"] = mp->getHighThreshold();
            point["lowPriority"] = mp->getLowAlarmPriority();
            point["highPriority"] = mp->getHighAlarmPriority();
            point["errorPriority"] = mp->getErrorAlarmPriority();
            point["hysteresis"] = mp->getHysteresis();
            point["sensorBound"] = mp->getBoundSensor() != nullptr;
        }
    }
    
    String response;
    serializeJson(doc, response);
    request->send(200, "application/json", response);
});

// 2. Bulk alarm configuration update endpoint
server.on("/api/alarm-config", HTTP_POST, [](AsyncWebServerRequest *request) {}, 
    NULL, [](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) {
    // Parse JSON body with all configuration changes
    JsonDocument doc;
    deserializeJson(doc, (char*)data);
    
    JsonArray changes = doc["changes"];
    for (JsonObject change : changes) {
        uint8_t pointAddress = change["address"];
        MeasurementPoint* mp = tempController.getMeasurementPoint(pointAddress);
        if (mp) {
            if (change.containsKey("name")) mp->setName(change["name"]);
            if (change.containsKey("lowThreshold")) mp->setLowThreshold(change["lowThreshold"]);
            if (change.containsKey("highThreshold")) mp->setHighThreshold(change["highThreshold"]);
            if (change.containsKey("lowPriority")) mp->setLowAlarmPriority(change["lowPriority"]);
            if (change.containsKey("highPriority")) mp->setHighAlarmPriority(change["highPriority"]);
            if (change.containsKey("errorPriority")) mp->setErrorAlarmPriority(change["errorPriority"]);
            if (change.containsKey("hysteresis")) mp->setHysteresis(change["hysteresis"]);
        }
    }
    
    // Save configuration and update register map
    tempController.saveConfiguration();
    tempController.applyConfigToRegisterMap();
    
    request->send(200, "application/json", "{\"status\":\"success\"}");
});

// 3. Temperature trend data endpoint
server.on("/api/trend-data/{pointAddress}", HTTP_GET, [](AsyncWebServerRequest *request) {
    String pointAddressStr = request->pathArg(0);
    uint8_t pointAddress = pointAddressStr.toInt();
    
    // Read last 24 hours from log file
    JsonDocument doc;
    JsonArray timestamps = doc["timestamps"].to<JsonArray>();
    JsonArray temperatures = doc["temperatures"].to<JsonArray>();
    JsonArray alarmEvents = doc["alarmEvents"].to<JsonArray>();
    JsonArray highThresholds = doc["highThresholds"].to<JsonArray>();
    JsonArray lowThresholds = doc["lowThresholds"].to<JsonArray>();
    
    // Read from temperature log file (last 288 entries = 24 hours at 5-min intervals)
    File logFile = LittleFS.open("/data/temperatures.csv", "r");
    if (logFile) {
        // Parse CSV and extract data for specific point
        // Implementation details in Step 3.1
    }
    
    String response;
    serializeJson(doc, response);
    request->send(200, "application/json", response);
});

// 4. Enhanced sensor binding endpoint with dropdown data
server.on("/api/sensor-binding-options", HTTP_GET, [](AsyncWebServerRequest *request) {
    JsonDocument doc;
    
    // Available sensors
    JsonArray sensors = doc["sensors"].to<JsonArray>();
    for (int i = 0; i < tempController.getSensorCount(); i++) {
        Sensor* sensor = tempController.getSensorByIndex(i);
        if (sensor) {
            JsonObject sensorObj = sensors.add<JsonObject>();
            sensorObj["rom"] = sensor->getRomString();
            sensorObj["type"] = sensor->getType();
            sensorObj["bus"] = tempController.getSensorBus(sensor);
            sensorObj["bound"] = sensor->getBoundPointAddress() != 255;
        }
    }
    
    // Available measurement points with names
    JsonArray points = doc["points"].to<JsonArray>();
    for (int i = 0; i < 60; i++) {
        MeasurementPoint* mp = tempController.getMeasurementPoint(i);
        if (mp) {
            JsonObject pointObj = points.add<JsonObject>();
            pointObj["address"] = i;
            pointObj["name"] = mp->getName();
            pointObj["type"] = i < 50 ? "DS18B20" : "PT1000";
            pointObj["hasSensor"] = mp->getBoundSensor() != nullptr;
        }
    }
    
    String response;
    serializeJson(doc, response);
    request->send(200, "application/json", response);
});

// 5. Relay control endpoint
server.on("/api/relay-control", HTTP_POST, [](AsyncWebServerRequest *request) {}, 
    NULL, [](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) {
    JsonDocument doc;
    deserializeJson(doc, (char*)data);
    
    uint8_t relayNumber = doc["relay"];
    bool state = doc["state"];
    
    if (relayNumber >= 1 && relayNumber <= 3) {
        String relayPort = "RELAY" + String(relayNumber);
        indicator.writePort(relayPort, state);
        
        // Update register map for Modbus access
        tempController.getRegisterMap().setRelayState(relayNumber, state);
        
        LoggerManager::getInstance().logEvent("Manual relay control: Relay" + String(relayNumber) + " = " + (state ? "ON" : "OFF"));
    }
    
    request->send(200, "application/json", "{\"status\":\"success\"}");
});

// 6. Enhanced system status endpoint
server.on("/api/system-status", HTTP_GET, [](AsyncWebServerRequest *request) {
    JsonDocument doc;
    
    // Existing system info
    doc["deviceId"] = tempController.getDeviceId();
    doc["firmwareVersion"] = tempController.getFirmwareVersion();
    doc["activeDS18B20"] = tempController.getDS18B20Count();
    doc["activePT1000"] = tempController.getPT1000Count();
    
    // Enhanced alarm statistics
    doc["totalAlarms"] = tempController.getAlarmCount(AlarmStage::ACTIVE);
    doc["criticalAlarms"] = tempController.getAlarmCount(AlarmPriority::PRIORITY_CRITICAL, AlarmStage::ACTIVE);
    doc["highAlarms"] = tempController.getAlarmCount(AlarmPriority::PRIORITY_HIGH, AlarmStage::ACTIVE);
    doc["mediumAlarms"] = tempController.getAlarmCount(AlarmPriority::PRIORITY_MEDIUM, AlarmStage::ACTIVE);
    doc["lowAlarms"] = tempController.getAlarmCount(AlarmPriority::PRIORITY_LOW, AlarmStage::ACTIVE);
    doc["acknowledgedAlarms"] = tempController.getAlarmCount(AlarmStage::ACKNOWLEDGED);
    
    // Unbound sensor count
    int unboundSensors = 0;
    for (int i = 0; i < tempController.getSensorCount(); i++) {
        Sensor* sensor = tempController.getSensorByIndex(i);
        if (sensor && sensor->getBoundPointAddress() == 255) {
            unboundSensors++;
        }
    }
    doc["unboundSensors"] = unboundSensors;
    
    // Relay states
    JsonObject relays = doc["relays"].to<JsonObject>();
    relays["relay1"] = indicator.readPort("RELAY1");
    relays["relay2"] = indicator.readPort("RELAY2"); 
    relays["relay3"] = indicator.readPort("RELAY3");
    
    String response;
    serializeJson(doc, response);
    request->send(200, "application/json", response);
});

// 7. Language preference endpoint
server.on("/api/language", HTTP_GET, [](AsyncWebServerRequest *request) {
    // Read saved language preference from configuration
    String language = configManager.getLanguage(); // Default: "en"
    request->send(200, "application/json", "{\"language\":\"" + language + "\"}");
});

server.on("/api/language", HTTP_POST, [](AsyncWebServerRequest *request) {}, 
    NULL, [](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) {
    JsonDocument doc;
    deserializeJson(doc, (char*)data);
    
    String language = doc["language"];
    if (language == "en" || language == "ru") {
        configManager.setLanguage(language);
        configManager.saveConfiguration();
        request->send(200, "application/json", "{\"status\":\"success\"}");
    } else {
        request->send(400, "application/json", "{\"error\":\"Invalid language\"}");
    }
});
```

**Required Model Extensions**:
```cpp
// Extensions needed in MeasurementPoint class
class MeasurementPoint {
public:
    // Add these methods if not present
    void setLowAlarmPriority(AlarmPriority priority);
    void setHighAlarmPriority(AlarmPriority priority);
    void setErrorAlarmPriority(AlarmPriority priority);
    AlarmPriority getLowAlarmPriority() const;
    AlarmPriority getHighAlarmPriority() const;
    AlarmPriority getErrorAlarmPriority() const;
    
    void setHysteresis(int16_t hysteresis);
    int16_t getHysteresis() const;
    
    uint8_t getBoundPointAddress() const; // For sensors
};

// Extensions needed in Sensor class
class Sensor {
public:
    uint8_t getBoundPointAddress() const; // Returns 255 if unbound
    String getType() const; // "DS18B20" or "PT1000"
};
```

**Testing**:
- Load configuration for all 60 measurement points
- Test dropdown functionality for priority selection
- Verify changes are applied correctly via API
- Test input validation (threshold ranges, hysteresis values)
- Test trend data API with real log files
- Verify sensor binding dropdown population
- Test relay control API integration

### Phase 2: Modbus Safety and Button Enhancement (Priority: High)

#### Step 2.1: Implement Modbus Configuration Safety
**Target File**: `src/TempModbusServer.cpp`, `include/RegisterMap.h`

**Requirements**: 
- Configuration changes only apply when trigger register is written
- Prevent accidental configuration from startup values

**Implementation**:
```cpp
// Add trigger registers to RegisterMap
class RegisterMap {
private:
    static const uint16_t ALARM_CONFIG_TRIGGER = 899;
    static const uint16_t RELAY_CONFIG_TRIGGER = 999;
    bool _alarmConfigPending = false;
    bool _relayConfigPending = false;
    
public:
    bool isAlarmConfigTriggered() {
        return _alarmConfigPending;
    }
    
    void setAlarmConfigTrigger() {
        _alarmConfigPending = true;
    }
    
    void clearAlarmConfigTrigger() {
        _alarmConfigPending = false;
    }
};

// In TempModbusServer handling
void TempModbusServer::handleWriteRegister(uint16_t address, uint16_t value) {
    if (address == RegisterMap::ALARM_CONFIG_TRIGGER && value == 0xA5A5) {
        // Apply pending alarm configuration
        _controller->applyAlarmConfigFromRegisterMap();
        _registerMap->clearAlarmConfigTrigger();
        LoggerManager::getInstance().logEvent("Modbus alarm config applied");
    }
    // Handle other registers...
}
```

**Testing**:
- Write alarm configuration to registers 800-898
- Verify changes don't apply until trigger register is written
- Test with invalid trigger values (should be ignored)
- Test configuration rollback if trigger not sent

#### Step 2.2: Enhance Single Button Navigation
**Target File**: `src/IndicatorInterface.cpp`

**Requirements**:
- Short press: Acknowledge alarms, navigate pages
- Long press: Enter/exit system status mode
- Improve debouncing and state management

**Implementation**:
```cpp
// Button state machine
enum class ButtonState {
    IDLE,
    PRESSED,
    SHORT_PRESS_DETECTED,
    LONG_PRESS_DETECTED
};

class ButtonHandler {
private:
    ButtonState _state = ButtonState::IDLE;
    unsigned long _pressStartTime = 0;
    unsigned long _lastPressTime = 0;
    const unsigned long LONG_PRESS_THRESHOLD = 2000;  // 2 seconds
    const unsigned long DEBOUNCE_DELAY = 50;          // 50ms
    
public:
    void update(bool buttonPressed) {
        unsigned long currentTime = millis();
        
        switch(_state) {
            case ButtonState::IDLE:
                if (buttonPressed && (currentTime - _lastPressTime > DEBOUNCE_DELAY)) {
                    _state = ButtonState::PRESSED;
                    _pressStartTime = currentTime;
                }
                break;
                
            case ButtonState::PRESSED:
                if (!buttonPressed) {
                    unsigned long pressDuration = currentTime - _pressStartTime;
                    if (pressDuration < LONG_PRESS_THRESHOLD) {
                        _state = ButtonState::SHORT_PRESS_DETECTED;
                    }
                    _lastPressTime = currentTime;
                } else if (currentTime - _pressStartTime >= LONG_PRESS_THRESHOLD) {
                    _state = ButtonState::LONG_PRESS_DETECTED;
                }
                break;
        }
    }
    
    bool isShortPressDetected() {
        if (_state == ButtonState::SHORT_PRESS_DETECTED) {
            _state = ButtonState::IDLE;
            return true;
        }
        return false;
    }
    
    bool isLongPressDetected() {
        if (_state == ButtonState::LONG_PRESS_DETECTED) {
            _state = ButtonState::IDLE;
            return true;
        }
        return false;
    }
};
```

**Testing**:
- Test short press detection (< 2 seconds)
- Test long press detection (≥ 2 seconds)
- Verify debouncing works with rapid button presses
- Test navigation through different display modes

#### Step 2.3: Implement Circular Display Scrolling
**Target File**: `src/IndicatorInterface.cpp`

**Current Problem**: Text jumps back to beginning instead of circular scrolling
**Solution**: Implement circular scrolling with spacing

**Implementation**:
```cpp
void IndicatorInterface::_handleScrolling() {
    unsigned long currentTime = millis();
    
    if (currentTime - _lastScrollTime < _scrollDelay) {
        return;
    }
    
    for (int i = 0; i < _textBufferSize; i++) {
        String& line = _textBuffer[i];
        if (line.length() > _maxCharsPerLine) {
            // Calculate total scroll length (text + spacing)
            int totalLength = line.length() + 3; // 3 spaces after text
            
            // Increment scroll offset
            _scrollOffset[i] = (_scrollOffset[i] + 1) % totalLength;
            
            // If we've scrolled past the text, show spaces
            if (_scrollOffset[i] >= line.length()) {
                _scrollOffset[i] = (_scrollOffset[i] + 1) % totalLength;
            }
        }
    }
    
    _lastScrollTime = currentTime;
}

void IndicatorInterface::_drawTextLine(int lineIndex, int yPos) {
    if (lineIndex >= _textBufferSize) return;
    
    String& line = _textBuffer[lineIndex];
    
    if (line.length() <= _maxCharsPerLine) {
        // No scrolling needed
        u8g2.drawStr(0, yPos, line.c_str());
    } else {
        // Create scrolled string with circular behavior
        String displayText = "";
        int offset = _scrollOffset[lineIndex];
        
        for (int i = 0; i < _maxCharsPerLine; i++) {
            int charIndex = (offset + i) % (line.length() + 3);
            if (charIndex < line.length()) {
                displayText += line[charIndex];
            } else {
                displayText += " "; // Spacing between end and start
            }
        }
        
        u8g2.drawStr(0, yPos, displayText.c_str());
    }
}
```

**Testing**:
- Test with strings longer than 21 characters
- Verify circular scrolling behavior (text flows smoothly)
- Test with multiple lines scrolling simultaneously
- Verify performance with 5 lines of long text

### Phase 3: Feature Enhancements (Priority: Medium)

#### Step 3.1: Implement Temperature Trend Charts
**Target File**: `data/dashboard.html`

**Requirements**:
- Modal-based charts using Chart.js
- Data from log files
- Alarm event markers with tooltips

**Implementation**:
```html
<!-- Add modal to dashboard.html -->
<div id="trendModal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <h2 id="trendTitle">Temperature Trend</h2>
        <canvas id="trendChart" width="800" height="400"></canvas>
    </div>
</div>
```

```javascript
function showTrendChart(pointAddress) {
    fetch(`/api/trend-data/${pointAddress}`)
        .then(response => response.json())
        .then(data => {
            const ctx = document.getElementById('trendChart').getContext('2d');
            
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.timestamps,
                    datasets: [{
                        label: 'Temperature',
                        data: data.temperatures,
                        borderColor: '#2196F3',
                        backgroundColor: 'rgba(33, 150, 243, 0.1)',
                        tension: 0.1
                    }, {
                        label: 'High Threshold',
                        data: data.highThresholds,
                        borderColor: '#F44336',
                        borderDash: [5, 5],
                        pointRadius: 0
                    }, {
                        label: 'Low Threshold', 
                        data: data.lowThresholds,
                        borderColor: '#FF9800',
                        borderDash: [5, 5],
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        tooltip: {
                            filter: function(tooltipItem) {
                                // Show alarm events in tooltips
                                return data.alarmEvents[tooltipItem.dataIndex];
                            },
                            callbacks: {
                                afterBody: function(context) {
                                    const index = context[0].dataIndex;
                                    const alarmEvent = data.alarmEvents[index];
                                    if (alarmEvent) {
                                        return `Alarm: ${alarmEvent.type} (${alarmEvent.priority})`;
                                    }
                                    return '';
                                }
                            }
                        }
                    }
                }
            });
            
            document.getElementById('trendModal').style.display = 'block';
        });
}
```

**Testing**:
- Test chart loading with real log data
- Verify alarm markers appear correctly
- Test modal open/close functionality
- Performance test with 24 hours of data (1440 points)

#### Step 3.2: Add Relay Modbus Control
**Target File**: `src/TempModbusServer.cpp`, `include/RegisterMap.h`

**Implementation**:
```cpp
// Add relay control registers
class RegisterMap {
public:
    static const uint16_t RELAY1_CONTROL = 950;
    static const uint16_t RELAY2_CONTROL = 951;
    static const uint16_t RELAY3_CONTROL = 952;
    static const uint16_t RELAY_TRIGGER = 999;
    
    void setRelayState(uint8_t relayNumber, bool state) {
        // Implementation to control relays via IndicatorInterface
    }
};
```

**Testing**:
- Test individual relay control via Modbus
- Verify relay states are read back correctly
- Test safety trigger mechanism
- Test interaction with alarm-driven relay control

#### Step 3.3: Russian Translation
**Target Files**: All HTML files in `data/` directory

**Implementation**:
```javascript
// Add to each HTML file
const translations = {
    en: {
        "dashboard": "Dashboard",
        "temperature": "Temperature", 
        "alarms": "Alarms",
        "points": "Points",
        "system": "System",
        "current": "Current",
        "minimum": "Minimum",
        "maximum": "Maximum",
        "threshold": "Threshold",
        "priority": "Priority",
        "hysteresis": "Hysteresis"
    },
    ru: {
        "dashboard": "Панель управления",
        "temperature": "Температура",
        "alarms": "Аварии", 
        "points": "Точки",
        "system": "Система",
        "current": "Текущая",
        "minimum": "Минимум",
        "maximum": "Максимум", 
        "threshold": "Порог",
        "priority": "Приоритет",
        "hysteresis": "Гистерезис"
    }
};

function setLanguage(lang) {
    document.querySelectorAll('[data-translate]').forEach(element => {
        const key = element.getAttribute('data-translate');
        if (translations[lang] && translations[lang][key]) {
            element.textContent = translations[lang][key];
        }
    });
    localStorage.setItem('language', lang);
}
```

**Testing**:
- Test language switching on all pages
- Verify all UI elements are translated
- Test language persistence across page reloads

## Unit Testing Strategy

### Test Categories

#### 1. Alarm System Tests
```cpp
// Test hysteresis behavior
void test_alarm_hysteresis() {
    Alarm alarm(AlarmType::HIGH_TEMPERATURE, &mockPoint, AlarmPriority::PRIORITY_HIGH);
    alarm.setHysteresis(20); // 2.0°C
    
    // Test threshold = 50°C, hysteresis = 2°C
    mockPoint.setCurrentTemperature(51.5); // Below trigger (50 + 2)
    assert(!alarm.updateCondition()); // Should not trigger
    
    mockPoint.setCurrentTemperature(52.5); // Above trigger (50 + 2)  
    assert(alarm.updateCondition()); // Should trigger
    
    mockPoint.setCurrentTemperature(50.5); // Above threshold but below hysteresis
    assert(alarm.isActive()); // Should remain active
    
    mockPoint.setCurrentTemperature(49.5); // Below threshold
    assert(!alarm.isActive()); // Should clear
}
```

#### 2. Button Handling Tests
```cpp
void test_button_short_press() {
    ButtonHandler handler;
    
    // Simulate button press for 100ms
    handler.update(true);
    delay(100);
    handler.update(false);
    
    assert(handler.isShortPressDetected());
    assert(!handler.isLongPressDetected());
}

void test_button_long_press() {
    ButtonHandler handler;
    
    // Simulate button press for 2.5 seconds
    handler.update(true);
    delay(2500);
    handler.update(false);
    
    assert(handler.isLongPressDetected());
    assert(!handler.isShortPressDetected());
}
```

#### 3. Display Scrolling Tests
```cpp
void test_circular_scrolling() {
    IndicatorInterface indicator(Wire, 0x20, -1);
    
    indicator.pushLine("This is a very long text that exceeds display width");
    
    // Test multiple scroll iterations
    for (int i = 0; i < 50; i++) {
        indicator.updateOLED();
        delay(200);
        // Verify scroll offset wraps around correctly
    }
}
```

### Debug Output Strategy

#### 1. Alarm Debug Messages
```cpp
#define ALARM_DEBUG 1

#if ALARM_DEBUG
#define ALARM_LOG(fmt, ...) Serial.printf("[ALARM] " fmt "\n", ##__VA_ARGS__)
#else
#define ALARM_LOG(fmt, ...)
#endif

// Usage in alarm code:
ALARM_LOG("Point %d: Temp=%.1f, Threshold=%.1f, Hysteresis=%d, State=%s", 
    pointAddress, temperature, threshold, hysteresis, stateString);
```

#### 2. Button Debug Messages
```cpp
#define BUTTON_DEBUG 1

#if BUTTON_DEBUG  
#define BUTTON_LOG(fmt, ...) Serial.printf("[BUTTON] " fmt "\n", ##__VA_ARGS__)
#else
#define BUTTON_LOG(fmt, ...)
#endif

// Usage:
BUTTON_LOG("Press detected: duration=%dms, type=%s", duration, pressType);
```

#### 3. Display Debug Messages
```cpp
#define DISPLAY_DEBUG 1

#if DISPLAY_DEBUG
#define DISPLAY_LOG(fmt, ...) Serial.printf("[DISPLAY] " fmt "\n", ##__VA_ARGS__)
#else  
#define DISPLAY_LOG(fmt, ...)
#endif

// Usage:
DISPLAY_LOG("Scroll: line=%d, offset=%d, text='%s'", lineIndex, offset, displayText.c_str());
```

## Risk Assessment and Dependencies

### High Risk Items

#### 1. **Memory Constraints**
- **Risk**: Chart.js and trend data may exceed ESP32 memory limits
- **Mitigation**: Implement data pagination, limit chart data points to 288 (5-minute intervals for 24 hours)
- **Fallback**: Simple text-based trend display if Chart.js fails

#### 2. **Performance Impact**
- **Risk**: Circular scrolling may impact display refresh rate
- **Mitigation**: Optimize scroll calculations, limit text processing per frame
- **Testing**: Monitor performance with 5 long lines scrolling simultaneously

#### 3. **ConfigAssist Integration**
- **Risk**: Changes to alarm configuration interface may break ConfigAssist file handling
- **Mitigation**: Preserve existing CSV structure, add new fields as optional columns
- **Testing**: Verify configuration persistence and loading after changes

### Medium Risk Items

#### 4. **Modbus Timing**
- **Risk**: Explicit trigger mechanism may cause timing issues with SCADA systems  
- **Mitigation**: Implement timeout for trigger register (auto-apply after 30 seconds)
- **Documentation**: Clear Modbus integration guide with timing requirements

#### 5. **Russian Font Support**
- **Risk**: U8g2 library may not support Cyrillic characters
- **Mitigation**: Use Unicode font or English fallback for OLED display
- **Alternative**: Implement custom character mapping for essential Russian text

### Dependencies

#### External Libraries
- **Chart.js**: For trend charts (web interface)
- **U8g2**: Display library (no changes needed)
- **PCF8575**: I/O expander (preserve existing logic)
- **ConfigAssist**: Configuration management (minimal changes)

#### Hardware Dependencies
- **Pin definitions**: Must remain unchanged (hardware constraint)
- **I2C addresses**: PCF8575 (0x20), OLED (auto-detect)
- **Button debouncing**: Physical button characteristics may require timing adjustments

## Implementation Timeline

### Week 1: Core Alarm System
- Day 1-2: Implement hysteresis in Alarm class
- Day 3-4: Fix indicator interface logic and LED control  
- Day 5-6: Redesign alarm configuration web interface (HTML/CSS/JS)
- Day 7: Implement API endpoints for alarm configuration

### Week 2: Safety and Navigation  
- Day 1-2: Implement Modbus configuration safety
- Day 3-4: Enhance button handling with state machine
- Day 5-6: Implement circular display scrolling
- Day 7: Implement sensor binding API endpoints with dropdown support

### Week 3: Feature Enhancements
- Day 1-2: Implement temperature trend charts (HTML/JS + Chart.js)
- Day 3: Implement trend data API endpoint
- Day 4: Add relay Modbus control + API endpoints
- Day 5: Implement system status API enhancements
- Day 6-7: Russian translation and language API

### Week 4: Testing and Documentation
- Day 1-3: Comprehensive testing of all features
- Day 4-5: Performance optimization and bug fixes  
- Day 6-7: Update documentation and user manual

## Success Criteria

### Functional Requirements
✅ **Hysteresis prevents alarm oscillation** (±1°C temperature variations)
✅ **LED indicators match specification table** for all priority levels  
✅ **Single alarm configuration page** shows all points simultaneously
✅ **Modbus configuration requires explicit trigger** to prevent accidental changes
✅ **Button navigation works reliably** with proper debouncing
✅ **Display scrolling is circular** with smooth text flow

### Performance Requirements  
✅ **Display refresh rate ≥ 10 FPS** with scrolling text
✅ **Button response time < 100ms** for acknowledgment
✅ **Web interface loads < 3 seconds** on local network
✅ **Trend charts render < 5 seconds** with 24 hours of data
✅ **API response time < 500ms** for configuration endpoints
✅ **Bulk configuration update < 2 seconds** for all 60 points

### Quality Requirements
✅ **Zero regression** in existing functionality  
✅ **Configuration persistence** survives power cycles
✅ **Memory usage < 80%** of available ESP32 memory
✅ **All user-facing text** available in English and Russian

---

## Next Steps

After planning approval:
1. Create `claude-branch` from current branch if it doesn't exist
2. Begin Phase 1 implementation starting with hysteresis
3. Implement comprehensive testing after each major component
4. Build and test incrementally to catch issues early
5. Document changes in commit messages and update relevant documentation files

**Ready for implementation phase upon approval.**
-------- [ Separator ] ------

File Name: docs/TECHNICAL_DOCUMENTATION.md
Size: 16.69 KB
Code:
# Temperature Controller Technical Documentation

## Table of Contents
1. [System Architecture](#system-architecture)
2. [Class Reference](#class-reference)
3. [API Reference](#api-reference)
4. [Configuration Files](#configuration-files)
5. [Communication Protocols](#communication-protocols)
6. [Hardware Interfaces](#hardware-interfaces)
7. [Build and Deployment](#build-and-deployment)

## System Architecture

### Overview
The Temperature Controller system follows a modular architecture with clear separation of concerns:

```
┌─────────────────────────────────────────────────────────────┐
│                        Web Interface                         │
│                    (HTML/CSS/JavaScript)                     │
└─────────────────────┬───────────────────────────────────────┘
                      │ HTTP/WebSocket
┌─────────────────────┴───────────────────────────────────────┐
│                      ConfigManager                           │
│              (Web Server + Configuration)                    │
└─────────────────────┬───────────────────────────────────────┘
                      │
┌─────────────────────┴───────────────────────────────────────┐
│                  TemperatureController                       │
│            (Core Business Logic + Orchestration)             │
└──┬──────────┬──────────┬──────────┬──────────┬─────────────┘
   │          │          │          │          │
┌──┴───┐  ┌──┴───┐  ┌──┴───┐  ┌──┴───┐  ┌───┴──────┐
│Sensor│  │Point │  │Alarm │  │RegMap│  │Indicator │
└──────┘  └──────┘  └──────┘  └──────┘  └──────────┘
```

### Core Components

#### 1. TemperatureController
Central orchestrator managing all system operations:
- Sensor discovery and management
- Measurement point handling
- Alarm processing
- Register map updates
- Hardware interface coordination

#### 2. MeasurementPoint
Represents a logical measurement location:
- Holds current, min, max temperature values
- Manages alarm thresholds
- Links to physical sensors
- Maintains error states

#### 3. Sensor
Abstracts physical temperature sensors:
- DS18B20 digital sensors
- PT1000/PT100 RTD sensors
- Handles communication protocols
- Error detection and recovery

#### 4. Alarm System
Multi-level alarm management:
- Priority-based processing
- State machine implementation
- Hysteresis support
- Acknowledged delay handling

#### 5. RegisterMap
Modbus register abstraction:
- Maps internal data to Modbus registers
- Handles read/write operations
- Data type conversions
- Access control

#### 6. IndicatorInterface
Hardware UI management:
- OLED display control
- LED management
- Button input handling
- PCF8575 I/O expander interface

## Class Reference

### TemperatureController

```cpp
class TemperatureController {
public:
    // Constructor
    TemperatureController(uint8_t oneWirePins[4], uint8_t csPins[4], 
                         IndicatorInterface& indicator);
    
    // Initialization
    bool begin();
    
    // Main update loop
    void update();
    
    // Sensor management
    bool addSensor(Sensor* sensor);
    bool removeSensorByRom(const String& romString);
    Sensor* findSensorByRom(const String& romString);
    bool discoverDS18B20Sensors();
    bool discoverPTSensors();
    
    // Point management
    MeasurementPoint* getMeasurementPoint(uint8_t address);
    bool bindSensorToPoint(const String& romString, uint8_t pointAddress);
    bool unbindSensorFromPoint(uint8_t pointAddress);
    
    // Alarm management
    void updateAlarms();
    std::vector<Alarm*> getActiveAlarms() const;
    void acknowledgeHighestPriorityAlarm();
    void acknowledgeAllAlarms();
    
    // Configuration
    void setDeviceId(uint16_t id);
    void setMeasurementPeriod(uint16_t seconds);
    void setAcknowledgedDelay(AlarmPriority priority, unsigned long delay);
    
    // Data access
    String getSensorsJson();
    String getPointsJson();
    String getAlarmsJson();
    RegisterMap& getRegisterMap();
};
```

### MeasurementPoint

```cpp
class MeasurementPoint {
public:
    // Constructor
    MeasurementPoint(uint8_t address);
    
    // Temperature management
    void updateTemperature(int16_t temp);
    int16_t getCurrentTemp() const;
    int16_t getMinTemp() const;
    int16_t getMaxTemp() const;
    void resetMinMax();
    
    // Threshold management
    void setLowThreshold(int16_t threshold);
    void setHighThreshold(int16_t threshold);
    int16_t getLowThreshold() const;
    int16_t getHighThreshold() const;
    
    // Sensor binding
    void bindSensor(Sensor* sensor);
    void unbindSensor();
    Sensor* getBoundSensor() const;
    bool hasSensor() const;
    
    // Status
    uint8_t getAddress() const;
    String getName() const;
    void setName(const String& name);
    uint16_t getAlarmStatus() const;
    uint16_t getErrorStatus() const;
};
```

### Sensor

```cpp
class Sensor {
public:
    // Sensor types
    enum class SensorType {
        DS18B20,
        PT1000,
        PT100,
        UNKNOWN
    };
    
    // Constructor
    Sensor(SensorType type, const String& id);
    
    // Temperature reading
    virtual bool readTemperature(int16_t& temperature) = 0;
    
    // Identification
    String getId() const;
    SensorType getType() const;
    String getTypeString() const;
    
    // Status
    bool isConnected() const;
    uint32_t getErrorCount() const;
    unsigned long getLastReadTime() const;
};
```

### Alarm

```cpp
class Alarm {
public:
    // Constructor
    Alarm(AlarmType type, MeasurementPoint* source, 
          AlarmPriority priority = AlarmPriority::PRIORITY_MEDIUM);
    
    // State management
    void acknowledge();
    void clear();
    void resolve();
    void reactivate();
    
    // Properties
    AlarmType getType() const;
    AlarmStage getStage() const;
    AlarmPriority getPriority() const;
    MeasurementPoint* getSource() const;
    
    // Timing
    unsigned long getTimestamp() const;
    unsigned long getAcknowledgedTime() const;
    bool isAcknowledgedDelayElapsed() const;
    
    // Display
    String getDisplayText() const;
    String getStatusText() const;
    
    // Configuration
    void setHysteresis(int16_t hysteresis);
    void setAcknowledgedDelay(unsigned long delay);
};
```

## API Reference

### RESTful API Endpoints

#### System Status
```
GET /api/status
Response: {
    "deviceId": 1000,
    "firmware": "2.0",
    "uptime": 12345,
    "time": "2024-12-30T14:23:45",
    "network": {
        "wifi": true,
        "ip": "192.168.1.100",
        "rssi": -45
    }
}
```

#### Points Management
```
GET /api/points
Response: [{
    "address": 0,
    "name": "Room A",
    "temperature": 23.5,
    "min": 20.1,
    "max": 25.3,
    "sensor": "28:AA:BB:CC:DD:EE:FF:00",
    "status": "normal"
}]

PUT /api/points/{address}
Body: {
    "name": "New Name",
    "lowThreshold": -10.0,
    "highThreshold": 30.0
}

POST /api/points/{address}/bind
Body: {
    "sensorId": "28:AA:BB:CC:DD:EE:FF:00"
}
```

#### Sensors Management
```
GET /api/sensors
Response: [{
    "id": "28:AA:BB:CC:DD:EE:FF:00",
    "type": "DS18B20",
    "temperature": 23.5,
    "bound": true,
    "pointAddress": 0,
    "errors": 0
}]

POST /api/sensors/discover
Response: {
    "discovered": 5,
    "sensors": [...]
}
```

#### Alarms Management
```
GET /api/alarms
Response: [{
    "id": "alarm_0_high",
    "type": "HIGH_TEMPERATURE",
    "point": 0,
    "priority": "CRITICAL",
    "stage": "ACTIVE",
    "timestamp": "2024-12-30T14:23:45",
    "value": 45.2,
    "threshold": 40.0
}]

POST /api/alarms/acknowledge
Body: {
    "alarmId": "alarm_0_high"
}

GET /api/alarms/config
Response: [{
    "point": 0,
    "lowPriority": "MEDIUM",
    "highPriority": "HIGH",
    "errorPriority": "CRITICAL",
    "hysteresis": 2.0
}]

PUT /api/alarms/config
Body: [{
    "point": 0,
    "lowPriority": "HIGH",
    "highPriority": "CRITICAL",
    "hysteresis": 3.0
}]
```

#### Logs Access
```
GET /api/logs/temperature?date=2024-12-30
Response: CSV data

GET /api/logs/events?date=2024-12-30&category=ALARM
Response: [{
    "timestamp": "2024-12-30T14:23:45",
    "category": "ALARM",
    "message": "High temperature alarm on Point 5"
}]

GET /api/logs/list
Response: [{
    "type": "temperature",
    "date": "2024-12-30",
    "size": 102400,
    "url": "/api/logs/download/temperature_2024-12-30.csv"
}]
```

### WebSocket API

#### Connection
```javascript
const ws = new WebSocket('ws://device-ip/ws');

ws.onopen = () => {
    // Subscribe to updates
    ws.send(JSON.stringify({
        action: 'subscribe',
        topics: ['alarms', 'temperatures']
    }));
};
```

#### Real-time Updates
```javascript
// Temperature update
{
    "type": "temperature",
    "data": {
        "point": 0,
        "value": 23.5,
        "timestamp": "2024-12-30T14:23:45"
    }
}

// Alarm notification
{
    "type": "alarm",
    "data": {
        "id": "alarm_0_high",
        "action": "triggered",
        "details": {...}
    }
}
```

## Configuration Files

### Main Configuration (`/config.yaml`)
```yaml
Wifi settings:
  - st_ssid:
      label: WiFi SSID
      default: ''
  - st_pass:
      label: WiFi Password
      default: ''
      
Device settings:
  - device_id:
      label: Device ID
      type: number
      min: 1
      max: 9999
      default: 1000
  - measurement_period:
      label: Measurement Period (seconds)
      type: number
      min: 1
      max: 3600
      default: 10
      
Modbus settings:
  - modbus_enabled:
      label: Enable Modbus RTU
      checked: true
  - modbus_address:
      label: Modbus Device Address
      type: number
      min: 1
      max: 247
      default: 1
```

### Sensor Configuration (`/sensors.csv`)
```csv
rom,type,point,name
28:AA:BB:CC:DD:EE:FF:00,DS18B20,0,Room A
28:11:22:33:44:55:66:77,DS18B20,1,Room B
PT:1,PT1000,50,Boiler Input
```

### Alarm Configuration (`/alarms.csv`)
```csv
point,low_threshold,low_priority,high_threshold,high_priority,error_priority,hysteresis
0,-10.0,MEDIUM,30.0,HIGH,CRITICAL,2.0
1,-5.0,LOW,35.0,MEDIUM,HIGH,1.5
```

## Communication Protocols

### OneWire Protocol (DS18B20)
- Bus speed: Standard (15.4 kbps)
- Power: Parasitic or external (3.3V)
- Pull-up resistor: 4.7kΩ
- Maximum devices per bus: 15 (recommended)
- Maximum cable length: 100m

### SPI Protocol (PT1000)
- Clock speed: 1 MHz
- Mode: 3 (CPOL=1, CPHA=1)
- Chip select: Active low
- Data format: MSB first
- MAX31865 configuration: 3-wire or 4-wire RTD

### Modbus RTU Protocol
- Physical layer: RS-485
- Baud rates: 4800, 9600, 19200, 38400, 57600, 115200
- Data format: 8 data bits, no parity, 1 stop bit
- Maximum nodes: 32 (without repeater)
- Maximum cable length: 1200m

### I2C Protocol
- Speed: 100 kHz (standard mode)
- Addresses used:
  - 0x20: PCF8575 I/O expander
  - 0x3C: OLED display
  - 0x68: RTC (if present)

## Hardware Interfaces

### Pin Assignments (ESP32-WROVER)

#### OneWire Buses
```
BUS1_PIN: GPIO 4
BUS2_PIN: GPIO 5
BUS3_PIN: GPIO 18
BUS4_PIN: GPIO 19
```

#### SPI Interface
```
SCK_PIN:  GPIO 14
MISO_PIN: GPIO 12
MOSI_PIN: GPIO 13
CS1_PIN:  GPIO 32
CS2_PIN:  GPIO 33
CS3_PIN:  GPIO 26
CS4_PIN:  GPIO 27
CS5_PIN:  GPIO 0 (SD Card)
```

#### RS-485 Interface
```
RX_PIN: GPIO 22
TX_PIN: GPIO 23
DE_PIN: Not used (auto-direction)
```

#### I2C Interface
```
SDA_PIN: GPIO 21
SCL_PIN: GPIO 25
PCF_INT: GPIO 34
```

### PCF8575 I/O Mapping

| Port | Function | Direction | Active |
|------|----------|-----------|--------|
| P0 | Button Input | Input | Low |
| P1 | Relay 1 (Siren) | Output | High |
| P2 | Relay 2 (Beacon) | Output | High |
| P3 | Relay 3 (Spare) | Output | High |
| P4 | LED Red | Output | Low |
| P5 | LED Yellow | Output | Low |
| P6 | LED Blue | Output | Low |
| P7 | LED Green | Output | Low |
| P8-P15 | Reserved | - | - |

## Build and Deployment

### Development Environment
- PlatformIO Core 6.1.0+
- ESP-IDF 4.4+
- Arduino framework for ESP32

### Dependencies
```ini
lib_deps = 
    adafruit/Adafruit MAX31865 library
    Wire
    WiFi
    OneWire
    ESPAsyncWebServer
    AsyncTCP
    ArduinoJson
    DallasTemperature
    eModbus
    ConfigAssist
    PCF8575
    U8g2
    CSV-Parser-for-Arduino
    RTClib
    NTPClient
```

### Build Configuration
```ini
[env:esp-wrover-kit]
platform = espressif32
board = esp-wrover-kit
framework = arduino
monitor_speed = 115200
build_flags = 
    -DBOARD_HAS_PSRAM
    -mfix-esp32-psram-cache-issue
    -DCA_USE_LITTLEFS
    -DLOGGER_LOG_LEVEL=3
board_build.partitions = huge_app.csv
board_build.filesystem = littlefs
```

### Partition Table
```
# Name,   Type, SubType, Offset,  Size
nvs,      data, nvs,     0x9000,  0x5000
otadata,  data, ota,     0xe000,  0x2000
app0,     app,  ota_0,   0x10000, 0x300000
app1,     app,  ota_1,   0x310000,0x300000
littlefs, data, littlefs,0x610000,0x1F0000
```

### Build Commands
```bash
# Clean build
pio run --target clean

# Build firmware
pio run

# Upload firmware
pio run --target upload

# Upload filesystem
pio run --target uploadfs

# Monitor serial output
pio device monitor

# Full deployment
pio run --target upload && pio run --target uploadfs
```

### OTA Update Process
1. Build firmware: `pio run`
2. Access web interface: `http://device-ip/update`
3. Select firmware.bin from `.pio/build/esp-wrover-kit/`
4. Click Upload and wait for completion
5. Device will reboot automatically

### Debugging

#### Serial Debug Levels
```cpp
#define LOGGER_LOG_LEVEL_NONE 0
#define LOGGER_LOG_LEVEL_ERROR 1
#define LOGGER_LOG_LEVEL_WARN 2
#define LOGGER_LOG_LEVEL_INFO 3
#define LOGGER_LOG_LEVEL_DEBUG 4
#define LOGGER_LOG_LEVEL_VERBOSE 5
```

#### Common Debug Commands
```cpp
// In setup()
Serial.setDebugOutput(true);
esp_log_level_set("*", ESP_LOG_VERBOSE);

// Memory debugging
Serial.printf("Free heap: %d\n", ESP.getFreeHeap());
Serial.printf("Free PSRAM: %d\n", ESP.getFreePsram());

// Task debugging
Serial.printf("Task watermark: %d\n", uxTaskGetStackHighWaterMark(NULL));
```

### Performance Optimization

#### Memory Management
- Use PSRAM for large buffers
- Minimize String usage in loops
- Prefer stack allocation over heap
- Use F() macro for constant strings

#### Task Priorities
```cpp
#define SENSOR_TASK_PRIORITY 5
#define ALARM_TASK_PRIORITY 4
#define WEB_TASK_PRIORITY 3
#define MODBUS_TASK_PRIORITY 3
#define LOG_TASK_PRIORITY 2
```

#### Timing Constraints
- Sensor reading: 750ms max (DS18B20)
- Web response: 500ms target
- Modbus response: 100ms max
- Display update: 100ms (10 FPS)

## Error Handling

### Error Codes

| Code | Category | Description |
|------|----------|-------------|
| 1xx | Sensor | Sensor-related errors |
| 2xx | Network | Network and communication errors |
| 3xx | Storage | SD card and filesystem errors |
| 4xx | Config | Configuration errors |
| 5xx | System | System and hardware errors |

### Recovery Strategies

#### Sensor Errors
1. Retry reading 3 times with 100ms delay
2. Mark sensor as disconnected after 3 failures
3. Disable temperature alarms for affected point
4. Log error with timestamp and sensor ID

#### Network Errors
1. Attempt reconnection every 30 seconds
2. Fall back to AP mode after 5 failures
3. Continue normal operation without network
4. Buffer logs locally until connection restored

#### Storage Errors
1. Retry write operation once
2. Skip logging if SD card fails
3. Use circular buffer in RAM (last 100 entries)
4. Alert user via LED and display

## Testing

### Unit Tests
Located in `/test` directory:
- test_alarm_logic.cpp
- test_sensor_reading.cpp
- test_modbus_registers.cpp
- test_web_api.cpp

### Integration Tests
- Full system startup sequence
- Sensor discovery and binding
- Alarm trigger and acknowledge cycle
- Modbus master simulation
- Web interface automation

### Performance Tests
- Maximum sensor count stress test
- Concurrent web requests handling
- Modbus polling rate limits
- Memory leak detection
- Long-term stability (72 hours)

### Hardware-in-the-Loop Tests
- Temperature chamber cycling
- Power cycling resilience
- EMI/RFI susceptibility
- Cable length limits
- Relay lifecycle testing

---
*Version: 2.0*  
*Last Updated: December 2024*

-------- [ Separator ] ------

File Name: docs/USER_MANUAL_RU.md
Size: 19.74 KB
Code:
# Руководство пользователя системы контроля температуры

## Содержание
1. [Введение](#введение)
2. [Технические характеристики](#технические-характеристики)
3. [Установка и подключение](#установка-и-подключение)
4. [Первоначальная настройка](#первоначальная-настройка)
5. [Веб-интерфейс](#веб-интерфейс)
6. [Настройка сигнализации](#настройка-сигнализации)
7. [Работа с Modbus RTU](#работа-с-modbus-rtu)
8. [Индикация и управление](#индикация-и-управление)
9. [Обслуживание](#обслуживание)
10. [Устранение неисправностей](#устранение-неисправностей)

## Введение

Система контроля температуры предназначена для непрерывного мониторинга температуры в промышленных условиях. Устройство поддерживает до 60 точек измерения с различными типами датчиков и обеспечивает гибкую настройку аварийной сигнализации.

### Основные возможности
- Поддержка до 50 датчиков DS18B20 и 10 датчиков PT1000/PT100
- Веб-интерфейс для настройки и мониторинга
- Интерфейс Modbus RTU для интеграции в промышленные системы
- Гибкая настройка аварийной сигнализации с 4 уровнями приоритета
- OLED дисплей и светодиодная индикация
- Журналирование данных на SD карту
- Релейные выходы для подключения внешней сигнализации

## Технические характеристики

### Общие параметры
- Питание: 12-24В постоянного тока
- Потребление: не более 5 Вт
- Рабочая температура: -20°C до +70°C
- Степень защиты: IP20
- Габариты: 160×90×58 мм

### Измерительные каналы
- DS18B20: 50 каналов (адреса 0-49)
- PT1000/PT100: 10 каналов (адреса 50-59)
- Диапазон измерения: -40°C до +200°C
- Точность: ±0.5°C (DS18B20), ±0.3°C (PT1000)
- Разрешение: 0.1°C

### Интерфейсы
- Ethernet: 10/100 Мбит/с
- WiFi: 802.11 b/g/n
- RS-485: Modbus RTU (до 115200 бод)
- USB: для обновления прошивки

### Выходы
- Реле 1: Сирена (250В AC, 5А)
- Реле 2: Световой маяк (250В AC, 5А)
- Реле 3: Резерв (250В AC, 5А)

## Установка и подключение

### Подключение питания
1. Подключите источник питания 12-24В к клеммам PWR+ и PWR-
2. Соблюдайте полярность!
3. Рекомендуется использовать источник питания с запасом 20%

### Подключение датчиков DS18B20
1. Подключите датчики к шинам 1-4 (клеммы BUS1-BUS4)
2. Каждая шина поддерживает до 15 датчиков
3. Используйте кабель с витой парой для длинных линий
4. Максимальная длина линии: 100 метров

**Схема подключения DS18B20:**
```
BUS+ ----+---- Красный (VDD)
         |
         R 4.7кОм
         |
DATA ----+---- Желтый (DATA)
         
GND ----------- Черный (GND)
```

### Подключение датчиков PT1000
1. Подключите датчики к разъемам PT1-PT4
2. Используйте 3-проводную или 4-проводную схему
3. Для точных измерений используйте 4-проводную схему

**3-проводная схема:**
```
PT+ ---- Красный
PT- ---- Белый 1
PT- ---- Белый 2
```

### Подключение RS-485
```
A+ ---- Клемма A (зеленый)
B- ---- Клемма B (желтый)
GND --- Клемма GND (черный)
```

### Подключение реле
```
Реле 1 (Сирена):
COM --- Общий контакт
NO ---- Нормально открытый
NC ---- Нормально закрытый

Реле 2 (Маяк):
COM --- Общий контакт  
NO ---- Нормально открытый
NC ---- Нормально закрытый
```

## Первоначальная настройка

### Шаг 1: Включение устройства
1. Подайте питание на устройство
2. Дождитесь загрузки (около 30 секунд)
3. На дисплее появится сообщение о готовности

### Шаг 2: Подключение к сети
#### Вариант А: Ethernet
1. Подключите кабель Ethernet
2. Устройство автоматически получит IP-адрес по DHCP
3. IP-адрес отобразится на дисплее

#### Вариант Б: WiFi
1. При первом включении устройство создаст точку доступа
2. Имя сети: TempController-XXXX
3. Пароль: 12345678
4. Подключитесь к этой сети с компьютера или смартфона
5. Откройте браузер и перейдите по адресу 192.168.4.1
6. Введите параметры вашей WiFi сети

### Шаг 3: Доступ к веб-интерфейсу
1. Откройте веб-браузер
2. Введите IP-адрес устройства
3. Логин: admin
4. Пароль: admin (измените при первом входе!)

## Веб-интерфейс

### Главная страница (Панель управления)
Отображает текущее состояние всех точек измерения:
- Номер точки
- Название точки
- Текущая температура
- Минимальная/максимальная температура
- Статус (Норма/Тревога/Ошибка)

**Цветовая индикация:**
- Зеленый: нормальное состояние
- Желтый: предупреждение
- Красный: тревога
- Серый: датчик не подключен

### Страница "Точки измерения"
Позволяет:
- Назначить имена точкам измерения
- Привязать датчики к точкам
- Просмотреть информацию о датчиках

**Процедура привязки датчика:**
1. Нажмите кнопку "Привязать" напротив нужной точки
2. В выпадающем списке выберите доступный датчик
3. Введите название точки (до 20 символов)
4. Нажмите "Сохранить"

### Страница "Настройка тревог"
Таблица настройки параметров сигнализации:

| Параметр | Описание | Диапазон |
|----------|----------|----------|
| Нижний порог | Температура для тревоги "Низкая температура" | -40...+200°C |
| Верхний порог | Температура для тревоги "Высокая температура" | -40...+200°C |
| Гистерезис | Зона нечувствительности | 0...10°C |
| Приоритет | Уровень важности тревоги | Низкий/Средний/Высокий/Критический |

**Уровни приоритета:**
- **Критический**: Сирена + маяк постоянно
- **Высокий**: Маяк постоянно
- **Средний**: Маяк мигает (2с вкл / 30с выкл)
- **Низкий**: Только индикация на дисплее

### Страница "Активные тревоги"
Отображает список текущих тревог:
- Время возникновения
- Точка измерения
- Тип тревоги
- Текущее значение
- Приоритет
- Статус (Активна/Подтверждена)

**Подтверждение тревог:**
1. Нажмите кнопку "Подтвердить" напротив тревоги
2. Или используйте кнопку на корпусе устройства
3. После подтверждения сирена отключится

## Настройка сигнализации

### Принцип работы
1. При выходе температуры за установленные пределы создается тревога
2. Тревога активирует световую и звуковую сигнализацию согласно приоритету
3. Оператор подтверждает тревогу нажатием кнопки
4. После подтверждения звуковая сигнализация отключается
5. При возврате температуры в норму тревога автоматически сбрасывается

### Гистерезис
Предотвращает частые срабатывания при колебаниях температуры:
```
Верхний порог: 30°C
Гистерезис: 2°C

Тревога включается при: T > 30°C
Тревога выключается при: T < 28°C
```

### Задержка повторной активации
После подтверждения тревога может быть повторно активирована через заданное время:
- Критический приоритет: 5 минут
- Высокий приоритет: 15 минут  
- Средний приоритет: 30 минут
- Низкий приоритет: 60 минут

## Работа с Modbus RTU

### Параметры подключения
- Скорость: 9600 бод (настраивается)
- Биты данных: 8
- Четность: Нет
- Стоповые биты: 1
- Адрес устройства: 1 (настраивается)

### Основные регистры

| Регистр | Описание | Тип |
|---------|----------|-----|
| 0 | ID устройства | R |
| 100-159 | Текущие температуры | R |
| 600-659 | Нижние пороги | R/W |
| 700-759 | Верхние пороги | R/W |
| 800-859 | Конфигурация тревог | R/W |
| 899 | Команды | W |

### Пример чтения температуры (Python)
```python
import minimalmodbus

# Настройка соединения
device = minimalmodbus.Instrument('/dev/ttyUSB0', 1)
device.serial.baudrate = 9600

# Чтение температуры точки 0
temp_raw = device.read_register(100, 0, 3, signed=True)
temperature = temp_raw / 10.0
print(f"Температура: {temperature}°C")
```

### Применение настроек
После изменения конфигурации через Modbus необходимо записать команду применения:
```python
# Запись команды применения конфигурации
device.write_register(899, 1)
```

## Индикация и управление

### OLED дисплей
#### Режимы отображения:
1. **Нормальный режим**: Циклическое отображение точек с датчиками
2. **Режим тревоги**: Отображение активных тревог
3. **Системный режим**: Информация о системе

#### Управление дисплеем:
- Дисплей автоматически выключается через 60 секунд
- Для включения нажмите кнопку
- Прокрутка длинных названий автоматическая

### Светодиодная индикация

| LED | Цвет | Значение |
|-----|------|----------|
| 1 | Красный | Критическая тревога |
| 2 | Желтый | Высокий приоритет |
| 3 | Синий | Средний приоритет |
| 4 | Зеленый | Система в норме |

### Кнопка управления
- **Короткое нажатие (<1с)**:
  - Подтверждение тревоги
  - Переключение экранов
  - Пробуждение дисплея
  
- **Длинное нажатие (>3с)**:
  - Вход/выход из системного режима

### Системный режим
Для просмотра системной информации:
1. Удерживайте кнопку 3 секунды
2. Короткими нажатиями переключайте экраны:
   - IP-адрес и состояние сети
   - Количество настроенных точек
   - Статистика тревог
   - Состояние Modbus
3. Для выхода снова удерживайте кнопку 3 секунды

## Обслуживание

### Регулярное обслуживание
#### Ежемесячно:
1. Проверьте журналы на наличие ошибок
2. Очистите вентиляционные отверстия
3. Проверьте надежность соединений

#### Ежеквартально:
1. Загрузите и архивируйте журналы
2. Проверьте калибровку датчиков
3. Протестируйте работу сигнализации

#### Ежегодно:
1. Замените батарею часов реального времени
2. Проверьте состояние реле
3. Обновите прошивку при наличии новой версии

### Резервное копирование
1. Перейдите в раздел "Система" → "Резервное копирование"
2. Нажмите "Создать резервную копию"
3. Сохраните файл конфигурации на компьютер
4. Рекомендуется делать резервные копии после каждого изменения настроек

### Обновление прошивки
1. Загрузите файл прошивки с сайта производителя
2. Перейдите в раздел "Система" → "Обновление"
3. Выберите файл прошивки
4. Нажмите "Обновить"
5. НЕ ОТКЛЮЧАЙТЕ питание во время обновления!

### Сброс к заводским настройкам
1. Перейдите в "Система" → "Сброс настроек"
2. Введите код подтверждения: 1234
3. Нажмите "Сбросить"
4. Устройство перезагрузится с заводскими настройками

## Устранение неисправностей

### Устройство не включается
1. Проверьте напряжение питания (12-24В)
2. Проверьте полярность подключения
3. Проверьте предохранитель

### Нет связи по сети
1. Проверьте сетевой кабель
2. Проверьте настройки IP-адреса
3. Попробуйте перезагрузить устройство
4. Проверьте настройки файрвола

### Датчик не определяется
1. Проверьте правильность подключения
2. Проверьте сопротивление подтягивающего резистора (4.7кОм)
3. Попробуйте подключить датчик к другой шине
4. Проверьте длину кабеля (не более 100м)

### Неправильные показания температуры
1. Проверьте тип датчика в настройках
2. Для PT1000 проверьте схему подключения
3. Проверьте наличие помех на линии
4. Выполните калибровку датчика

### Тревога не срабатывает
1. Проверьте настройки порогов
2. Убедитесь, что приоритет не "Отключен"
3. Проверьте привязку датчика к точке
4. Проверьте работу реле тестовой командой

### Частые ложные срабатывания
1. Увеличьте значение гистерезиса
2. Проверьте стабильность показаний датчика
3. Увеличьте время усреднения
4. Проверьте экранирование кабелей

### Ошибка связи Modbus
1. Проверьте параметры связи (скорость, адрес)
2. Проверьте подключение A+ и B-
3. Проверьте терминальные резисторы (120 Ом)
4. Используйте экранированный кабель

## Коды ошибок

| Код | Описание | Решение |
|-----|----------|---------|
| E01 | Ошибка датчика | Проверьте подключение |
| E02 | Ошибка SD карты | Проверьте карту памяти |
| E03 | Ошибка сети | Проверьте настройки сети |
| E04 | Ошибка конфигурации | Сбросьте настройки |
| E05 | Перегрев устройства | Улучшите вентиляцию |

## Техническая поддержка

При обращении в службу поддержки подготовьте:
- Серийный номер устройства
- Версию прошивки
- Описание проблемы
- Журналы событий
- Схему подключения

**Контакты:**
- Email: support@tempcontroller.ru
- Телефон: 8-800-XXX-XX-XX
- Сайт: www.tempcontroller.ru

## Гарантийные обязательства

Гарантийный срок: 24 месяца с даты продажи

Гарантия не распространяется на:
- Механические повреждения
- Повреждения от неправильного подключения
- Повреждения от перенапряжения
- Модификации устройства

Для гарантийного обслуживания сохраняйте:
- Гарантийный талон
- Чек о покупке
- Заводскую упаковку

## Приложения

### А. Схема подключения
[Здесь должна быть принципиальная схема подключения всех компонентов]

### Б. Размеры корпуса
[Здесь должен быть чертеж с размерами]

### В. Спецификация клеммников
[Здесь должна быть таблица с описанием всех клемм]

### Г. Список совместимых датчиков
- DS18B20 (любой производитель)
- PT1000 (класс A или B)
- PT100 (класс A или B)

---
*Версия документа: 2.0*  
*Дата: Декабрь 2024*

-------- [ Separator ] ------

File Name: docs/WEB_INTERFACE_SPEC.md
Size: 16.47 KB
Code:
# Web Interface Design Specification

## Overview
The web interface should provide a modern, responsive, and intuitive control panel for the Temperature Controller system. All interfaces must support both English and Russian languages.

## Design Principles
- **Consistency**: Unified look and feel across all pages
- **Responsiveness**: Works on desktop, tablet, and mobile
- **Performance**: Fast loading, minimal resource usage
- **Accessibility**: WCAG 2.1 AA compliant
- **Modern**: Clean, professional appearance

## Visual Design

### Color Palette
```css
:root {
  /* Primary Colors */
  --primary: #2196F3;        /* Blue - Main brand color */
  --primary-dark: #1976D2;   /* Darker blue for hover */
  --primary-light: #BBDEFB;  /* Light blue for backgrounds */
  
  /* Status Colors */
  --success: #4CAF50;        /* Green - Normal state */
  --warning: #FF9800;        /* Orange - Warning state */
  --danger: #F44336;         /* Red - Alarm/Error state */
  --info: #00BCD4;          /* Cyan - Information */
  
  /* Neutral Colors */
  --text-primary: #212121;   /* Main text */
  --text-secondary: #757575; /* Secondary text */
  --border: #E0E0E0;        /* Borders */
  --background: #FAFAFA;     /* Page background */
  --surface: #FFFFFF;        /* Card/Panel background */
  
  /* Dark Mode */
  --dark-background: #121212;
  --dark-surface: #1E1E1E;
  --dark-text: #FFFFFF;
}
```

### Typography
```css
/* Headings */
h1 { font-size: 2.5rem; font-weight: 300; }
h2 { font-size: 2rem; font-weight: 400; }
h3 { font-size: 1.5rem; font-weight: 400; }

/* Body */
body { 
  font-family: 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;
  font-size: 16px;
  line-height: 1.5;
}

/* Monospace for values */
.value { font-family: 'Roboto Mono', monospace; }
```

## Page Structure

### Common Header
```html
<header class="main-header">
  <div class="logo">
    <img src="/logo.svg" alt="Temperature Controller">
    <span class="system-name">Temperature Controller</span>
  </div>
  
  <nav class="main-nav">
    <a href="/" class="nav-link active">Dashboard</a>
    <div class="nav-dropdown">
      <a href="#" class="nav-link">Alarms <i class="fa fa-chevron-down"></i></a>
      <div class="dropdown-content">
        <a href="/alarms">Active Alarms</a>
        <a href="/alarm-config">Configuration</a>
        <a href="/alarm-history">History</a>
      </div>
    </div>
    <a href="/points" class="nav-link">Points</a>
    <div class="nav-dropdown">
      <a href="#" class="nav-link">System <i class="fa fa-chevron-down"></i></a>
      <div class="dropdown-content">
        <a href="/settings">General Settings</a>
        <a href="/network">Network</a>
        <a href="/time">Time Settings</a>
        <a href="/modbus">Modbus</a>
      </div>
    </div>
    <a href="/logs" class="nav-link">Logs</a>
  </nav>
  
  <div class="header-actions">
    <div class="language-toggle">
      <button class="lang-btn active" data-lang="en">EN</button>
      <button class="lang-btn" data-lang="ru">RU</button>
    </div>
    <div class="connection-status">
      <i class="fa fa-wifi"></i>
      <span class="status-text">Connected</span>
    </div>
  </div>
</header>
```

### Common Footer
```html
<footer class="main-footer">
  <div class="footer-info">
    <span>Device ID: <span class="device-id">1000</span></span>
    <span>Firmware: <span class="firmware-version">2.0</span></span>
    <span>Uptime: <span class="uptime">5d 14h 23m</span></span>
  </div>
  <div class="footer-actions">
    <button class="btn-icon" title="Download Logs">
      <i class="fa fa-download"></i>
    </button>
    <button class="btn-icon" title="System Info">
      <i class="fa fa-info-circle"></i>
    </button>
  </div>
</footer>
```

## Page Specifications

### 1. Dashboard Page (`/`)

#### Layout
```
+----------------------------------+
| Active Alarms Summary (if any)   |
+----------------------------------+
| Measurement Points Table         |
| Point | Name | Temp | Status |▼  |
|-------|------|------|---------|  |
| 01    | Room | 23.5 | Normal  |  |
| 02    | Hall | 24.1 | Normal  |  |
+----------------------------------+
| System Status Cards              |
| [Sensors] [Alarms] [Network]     |
+----------------------------------+
```

#### Features
- Auto-refresh every 5 seconds
- Click on temperature to show trend modal
- Color-coded rows based on status
- Sortable columns
- Search/filter functionality

#### Temperature Trend Modal
```javascript
// Modal structure
<div class="modal" id="trendModal">
  <div class="modal-content">
    <div class="modal-header">
      <h3>Temperature Trend - <span class="point-name"></span></h3>
      <button class="close-btn">&times;</button>
    </div>
    <div class="modal-body">
      <canvas id="trendChart"></canvas>
      <div class="chart-controls">
        <select class="time-range">
          <option value="1h">Last Hour</option>
          <option value="6h">Last 6 Hours</option>
          <option value="24h" selected>Last 24 Hours</option>
          <option value="7d">Last 7 Days</option>
        </select>
      </div>
    </div>
  </div>
</div>
```

### 2. Alarm Configuration Page (`/alarm-config`)

#### Layout
```
+----------------------------------+
| Alarm Configuration              |
+----------------------------------+
| Global Settings                  |
| [Hysteresis: 2.0°C] [Save]       |
+----------------------------------+
| Point Configuration Table        |
| Point | Name | Low Th | Low Pri | High Th | High Pri | Error Pri |
|-------|------|--------|---------|---------|----------|-----------|
| 01    | Room | -10.0  | Medium  | 30.0    | High     | Critical  |
+----------------------------------+
| Relay Behavior Settings          |
| Priority | Active | Acknowledged |
|----------|--------|--------------|
| Critical | S+B ON | Beacon ON    |
+----------------------------------+
```

#### Features
- Inline editing with validation
- Bulk operations (set all to priority)
- Import/Export CSV
- Real-time validation
- Undo/Redo capability

### 3. Active Alarms Page (`/alarms`)

#### Layout
```
+----------------------------------+
| Active Alarms (12)               |
+----------------------------------+
| Filter: [All Priorities] [All Types] [Search...]
+----------------------------------+
| Time | Point | Type | Value | Priority | Status | Actions |
|------|-------|------|-------|---------|--------|---------|
| 14:23| Pt 05 | High | 45.2°C| Critical| Active | [Ack]   |
+----------------------------------+
| Acknowledged Alarms (3)          |
+----------------------------------+
```

#### Features
- Real-time updates via WebSocket
- Bulk acknowledge
- Export to CSV
- Sound notification for new alarms
- Desktop notifications (optional)

### 4. Points Configuration Page (`/points`)

#### Layout
```
+----------------------------------+
| Measurement Points Configuration |
+----------------------------------+
| Point | Name | Sensor | Type | Actions |
|-------|------|--------|------|---------|
| 01    | Room | 28:AA..| DS18 | [Edit]  |
| 02    | Hall | <none> | -    | [Bind]  |
+----------------------------------+
| Available Sensors                |
+----------------------------------+
| ROM/Bus | Type | Temp | Actions |
|---------|------|------|---------|
| 28:FF...| DS18 | 23.1 | [Bind]  |
+----------------------------------+
```

#### Sensor Binding Modal
```html
<div class="modal" id="bindingModal">
  <h3>Bind Sensor to Point</h3>
  <form>
    <div class="form-group">
      <label>Select Point:</label>
      <select class="point-select">
        <option value="">-- Select Point --</option>
        <optgroup label="DS18B20 Points (0-49)">
          <option value="0">Point 00: Room A</option>
          <option value="1">Point 01: Room B</option>
        </optgroup>
        <optgroup label="PT1000 Points (50-59)">
          <option value="50">Point 50: Boiler</option>
        </optgroup>
      </select>
    </div>
    <div class="form-group">
      <label>Point Name:</label>
      <input type="text" class="point-name" maxlength="20">
    </div>
    <div class="form-actions">
      <button type="submit" class="btn-primary">Bind</button>
      <button type="button" class="btn-secondary">Cancel</button>
    </div>
  </form>
</div>
```

### 5. System Settings Pages

#### General Settings (`/settings`)
```
Device Settings:
- Device ID: [____] 
- Measurement Period: [__] seconds
- Display Timeout: [__] seconds

Alarm Settings:
- Critical Delay: [___] seconds
- High Delay: [___] seconds
- Medium Delay: [___] seconds
- Low Delay: [___] seconds

Relay Settings:
- Beacon On Time: [__] seconds
- Beacon Off Time: [__] seconds
```

#### Network Settings (`/network`)
```
WiFi Configuration:
- SSID: [____________]
- Password: [________]
- Hostname: [________]

Current Status:
- IP Address: 192.168.1.100
- MAC: AA:BB:CC:DD:EE:FF
- Signal: -45 dBm
```

#### Time Settings (`/time`)
```
Time Configuration:
- Current Time: 2024-12-30 14:23:45
- Timezone: [UTC+3:00 Moscow]
- NTP Server: [pool.ntp.org]
- [Sync Now]

RTC Status: Valid
Last Sync: 2024-12-30 12:00:00
```

### 6. Log Pages

#### Event Logs (`/logs`)
```
+----------------------------------+
| Event Logs                       |
+----------------------------------+
| Date Range: [Today] [Filter]     |
+----------------------------------+
| Time | Category | Message        |
|------|----------|----------------|
| 14:23| ALARM    | High temp Pt05 |
| 14:20| SYSTEM   | Config updated |
+----------------------------------+
```

## JavaScript Architecture

### API Service
```javascript
class APIService {
  constructor(baseURL = '/api') {
    this.baseURL = baseURL;
  }
  
  async getPoints() {
    return this.fetch('/points');
  }
  
  async updatePoint(id, data) {
    return this.fetch(`/points/${id}`, {
      method: 'PUT',
      body: JSON.stringify(data)
    });
  }
  
  async getAlarms() {
    return this.fetch('/alarms');
  }
  
  // ... other methods
  
  async fetch(endpoint, options = {}) {
    const response = await fetch(this.baseURL + endpoint, {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      },
      ...options
    });
    
    if (!response.ok) {
      throw new Error(`API Error: ${response.statusText}`);
    }
    
    return response.json();
  }
}
```

### Internationalization
```javascript
class I18n {
  constructor() {
    this.currentLang = localStorage.getItem('language') || 'en';
    this.translations = {};
  }
  
  async load(lang) {
    const response = await fetch(`/i18n/${lang}.json`);
    this.translations[lang] = await response.json();
    this.currentLang = lang;
    this.updateUI();
  }
  
  t(key) {
    const keys = key.split('.');
    let value = this.translations[this.currentLang];
    
    for (const k of keys) {
      value = value?.[k];
    }
    
    return value || key;
  }
  
  updateUI() {
    document.querySelectorAll('[data-i18n]').forEach(element => {
      const key = element.getAttribute('data-i18n');
      element.textContent = this.t(key);
    });
  }
}
```

## Translation Files

### English (`/i18n/en.json`)
```json
{
  "common": {
    "save": "Save",
    "cancel": "Cancel",
    "edit": "Edit",
    "delete": "Delete",
    "confirm": "Confirm",
    "search": "Search",
    "filter": "Filter"
  },
  "dashboard": {
    "title": "Dashboard",
    "temperature": "Temperature",
    "status": "Status",
    "normal": "Normal",
    "alarm": "Alarm",
    "error": "Error"
  },
  "alarms": {
    "title": "Alarms",
    "active": "Active Alarms",
    "acknowledged": "Acknowledged",
    "priority": {
      "critical": "Critical",
      "high": "High",
      "medium": "Medium",
      "low": "Low"
    },
    "type": {
      "high_temp": "High Temperature",
      "low_temp": "Low Temperature",
      "sensor_error": "Sensor Error"
    }
  }
}
```

### Russian (`/i18n/ru.json`)
```json
{
  "common": {
    "save": "Сохранить",
    "cancel": "Отмена",
    "edit": "Редактировать",
    "delete": "Удалить",
    "confirm": "Подтвердить",
    "search": "Поиск",
    "filter": "Фильтр"
  },
  "dashboard": {
    "title": "Панель управления",
    "temperature": "Температура",
    "status": "Статус",
    "normal": "Норма",
    "alarm": "Тревога",
    "error": "Ошибка"
  },
  "alarms": {
    "title": "Тревоги",
    "active": "Активные тревоги",
    "acknowledged": "Подтвержденные",
    "priority": {
      "critical": "Критический",
      "high": "Высокий",
      "medium": "Средний",
      "low": "Низкий"
    },
    "type": {
      "high_temp": "Высокая температура",
      "low_temp": "Низкая температура",
      "sensor_error": "Ошибка датчика"
    }
  }
}
```

## Responsive Design

### Breakpoints
```css
/* Mobile First Approach */
/* Base styles for mobile */

/* Tablet */
@media (min-width: 768px) {
  .container { max-width: 750px; }
}

/* Desktop */
@media (min-width: 1024px) {
  .container { max-width: 960px; }
}

/* Large Desktop */
@media (min-width: 1280px) {
  .container { max-width: 1140px; }
}
```

### Mobile Navigation
```css
/* Hamburger menu for mobile */
@media (max-width: 767px) {
  .main-nav {
    position: fixed;
    top: 60px;
    left: -100%;
    width: 80%;
    height: calc(100vh - 60px);
    background: var(--surface);
    transition: left 0.3s;
  }
  
  .main-nav.active {
    left: 0;
  }
}
```

## Performance Optimization

### 1. Resource Loading
```html
<!-- Preload critical resources -->
<link rel="preload" href="/css/main.css" as="style">
<link rel="preload" href="/fonts/roboto-v20-latin-regular.woff2" as="font" crossorigin>

<!-- Lazy load non-critical CSS -->
<link rel="preload" href="/css/charts.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
```

### 2. JavaScript Optimization
```javascript
// Use dynamic imports for large libraries
async function showChart() {
  const { Chart } = await import('./chart.min.js');
  // Use Chart
}

// Debounce search input
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}
```

### 3. API Optimization
- Use pagination for large datasets
- Implement caching with ETags
- Compress responses with gzip
- Use WebSocket for real-time updates

## Security Considerations

### 1. Authentication
```javascript
// Basic auth header
const auth = btoa(`${username}:${password}`);
fetch('/api/points', {
  headers: {
    'Authorization': `Basic ${auth}`
  }
});
```

### 2. CSRF Protection
```html
<meta name="csrf-token" content="{{ csrf_token }}">
```

### 3. Input Validation
```javascript
// Client-side validation
function validateTemperature(value) {
  const temp = parseFloat(value);
  return !isNaN(temp) && temp >= -40 && temp <= 200;
}

// Sanitize user input
function sanitizeInput(input) {
  const div = document.createElement('div');
  div.textContent = input;
  return div.innerHTML;
}
```

## Accessibility

### 1. ARIA Labels
```html
<button aria-label="Acknowledge alarm" class="btn-ack">
  <i class="fa fa-check" aria-hidden="true"></i>
</button>
```

### 2. Keyboard Navigation
```javascript
// Trap focus in modal
function trapFocus(element) {
  const focusableElements = element.querySelectorAll(
    'a[href], button, textarea, input[type="text"], input[type="radio"], input[type="checkbox"], select'
  );
  const firstFocusable = focusableElements[0];
  const lastFocusable = focusableElements[focusableElements.length - 1];
  
  element.addEventListener('keydown', function(e) {
    if (e.key === 'Tab') {
      if (e.shiftKey) { // Shift + Tab
        if (document.activeElement === firstFocusable) {
          lastFocusable.focus();
          e.preventDefault();
        }
      } else { // Tab
        if (document.activeElement === lastFocusable) {
          firstFocusable.focus();
          e.preventDefault();
        }
      }
    }
  });
}
```

### 3. Screen Reader Support
```html
<!-- Live regions for dynamic content -->
<div role="status" aria-live="polite" aria-atomic="true">
  <span class="sr-only">Temperature updated: 23.5°C</span>
</div>
```

## Testing Requirements

### 1. Browser Support
- Chrome 90+
- Firefox 88+
- Safari 14+
- Edge 90+
- Mobile Safari (iOS 14+)
- Chrome Mobile (Android 8+)

### 2. Performance Targets
- First Contentful Paint: < 1.5s
- Time to Interactive: < 3.5s
- Lighthouse Score: > 90

### 3. Accessibility Testing
- WAVE tool: 0 errors
- axe DevTools: 0 violations
- Keyboard navigation: Full support
- Screen reader: Tested with NVDA/JAWS

-------- [ Separator ] ------

File Name: docs/fix_alarm_config.md
Size: 1.99 KB
Code:
# Alarm configuration fixing
## Overview
- Each measurement point mast have 3 Alarms from the very startup - high/low temperature, sensor error.
- We turn alarm on and off by `_enable` flag.
- We store alarms in the point `/points2.ini` - including priorities for each type, hysteresis, enable flag
- The temperature controller have ALL the alarms, both enabled and disabled, in `_configuredAlarms` property from the startup.
- We manage all the alarms from the `alarm-config.html` web page.

## allarm-config.html web page
### Table content changes
- Should have `enable` checkboxes - to toggle `_enable` property of alarms of all the types for each measurement point.
- Should allow to edit **Measurement Point name**

## ConfigManager class
- Saves and loads the points config via `/api/alarm-config`
- Loads the alarm config during the startup to temperature controller class

# Plan
## Key changes
- structure of the `/points2.ini` file and related methods to save and load configuration in the ConfigManager class
- `alarm-config.html` - add **checkboxes** and **enable to edit Measurement point name**. 
- **TemperatureController** should keep all the alarms from the very beginning.
- **CSVConfigManager** CSV structure should contain enable fields (checkboxes) for the alarms as well as priorities.
- We should have **only 3 alarm types** -  HIGH_TEMPERATURE, LOW_TEMPERATURE, SENSOR_ERROR,

## Onboarding stage
- **DO NOT** CODE on this stage.
- **DO NOT** follow any other plans you find in the project. We need to implement only this features.
- inspect the code. **THINK HARD** about the alarm logic, class structure. 
- compare the current state of the code and logic with the desired state.
- ASK QUESTIONS
- **THINK HARD** upon the implementation plan.

## Implementation stage
- implement the changes from the plan.
- try to compile the code
- if there are any errors - fix the code. Iterate through the code while it got compiled without any errors.

## Summary
- provide me with the summary of the implemented changes




-------- [ Separator ] ------

File Name: docs/main_requirements.md
Size: 3.75 KB
Code:
In addition
- I also need to have **hysteresis implementation in place**
Alarm state transitions works well, so do not change it just extend.
- The **config assist library uses its own config files handler**. Study the code for the implementation
- **Alarm and thresholds configuring via the Modbus RTU should be triggered explicitly** as the master could write zero or undefined values from the startup if not configured properly
- **Alarm configuration page should contain also threshold configuration**, point name configuration etc. It could be done in a dedicated modal, but i do not like the way the alarm configuration modal works now. it should show all the alarms, thresholds and other configurable field at once. 
- **Sensor binding mechanics should remain the same as in the old code** with point address check for different types of sensors. But instead of just inputing a point number there should be a dropdown with point names and autocomplete if it’s possible on esp32.
- I do not like how indication with OLED and LEDs works now. It’s inconsistent and not clear for the user. **Indicator interface logic does not work properly** as well check it carefully. different dislpay and LED blinkings work bad.
- **relay outputs should be able to be controlled via ModbusRTU**.
- **Use the original PCF8575 logic as it’s proven**. Do not change it much, just extend
- When a list of alarms shows the LED indicators should duplicate alarm priority from the screen
- I need a separate document for modbus implementation - register map table, examples, usage patterns etc.
- **For the temperature trend charts use modals to show trends** and **use log file to populate the trend**. It could be called from the dashboard page by clicking on some trend icon in a table row. Place the markers with time stamp and alarm type in a tooltip for alarms rising events on the charts to give the user the most important information
- **The device has only one button, no any additional phisical input controls**. We can use just it.
- **use short button presses to any type of acknowledgement** (alarms, during the startup). **Use long press to enter and exit system status mode**, use short presses for moving thru the pages
- **log system works pretty well at the moment**, just one consideration - too many records in the event log. e.g. creating 20 alarms should be wrapped in one message - 20 alarms created.
- **When on display we work only with mesurement points**. If we have any sensors without any point bound to it, we just show it in the system status page like Unbound sensors 5 pcs. The user works with the measurement points, not with sensors. Sensors are just devices with ROM numbers and we do not show them to the end user. We show the point with bound working (with no errors) sensor with a number and the name
- **Do not mess sensors and measurement points** - those are separate classes and separate abstractions - sensor abstracts the measuring device, Measurement point abstracts a place or a piece of equipment which temperature is measured by the sensor.
- When we have a list of unacknowledged alarms the first is the higher priority alarm and we do not cycle trough the list, we a re waiting while the user press the button. We acknowledge the alarms by short press as mentioned already.
- **Current representation of the alarm on OLED is ok**. We should show the point name, current temp, alarm type, alarm status and other alarm and point related information. **Add timestamp to this screen**
- **Change the way how scrolling on display works**. It should go round - show the beginning of the string after some spaces after the end of the screen but not jump back and place the beginning to the first character 

Provide me with a table for the notification system based on alarm priority and alarm state



-------- [ Separator ] ------

File Name: download_fs.py
Size: 10.69 KB
Code:
# Written by Maximilian Gerhardt <maximilian.gerhardt@rub.de>
# 29th December 2020
# and Christian Baars, Johann Obermeier
# 2023 / 2024
# License: Apache
# Expanded from functionality provided by PlatformIO's espressif32 and espressif8266 platforms, credited below.
# This script provides functions to download the filesystem (LittleFS) from a running ESP32 / ESP8266
# over the serial bootloader using esptool.py, and mklittlefs for extracting.
# run by either using the VSCode task "Custom" -> "Download Filesystem"
# or by doing 'pio run -t downloadfs' (with optional '-e <environment>') from the commandline.
# output will be saved, by default, in the "unpacked_fs" of the project.
# this folder can be changed by writing 'custom_unpack_dir = some_other_dir' in the corresponding platformio.ini
# environment.
import re
import sys
from os.path import isfile, join
from enum import Enum
import os
import subprocess
import shutil

Import("env")
platform = env.PioPlatform()
board = env.BoardConfig()
mcu = board.get("build.mcu", "esp32")


class FSType(Enum):
    LITTLEFS="littlefs"
    FATFS="fatfs"

class FSInfo:
    def __init__(self, fs_type, start, length, page_size, block_size):
        self.fs_type = fs_type
        self.start = start
        self.length = length
        self.page_size = page_size
        self.block_size = block_size
    def __repr__(self):
        return f"FS type {self.fs_type} Start {hex(self.start)} Len {self.length} Page size {self.page_size} Block size {self.block_size}"
    # extract command supposed to be implemented by subclasses
    def get_extract_cmd(self, input_file, output_dir):
        raise NotImplementedError()

class FS_Info(FSInfo):
    def __init__(self, start, length, page_size, block_size):
        self.tool = env["MKFSTOOL"]
        self.tool = join(platform.get_package_dir("tool-mklittlefs"), self.tool)
        super().__init__(FSType.LITTLEFS, start, length, page_size, block_size)
    def __repr__(self):
        return f"{self.fs_type} Start {hex(self.start)} Len {hex(self.length)} Page size {hex(self.page_size)} Block size {hex(self.block_size)}"
    def get_extract_cmd(self, input_file, output_dir):
        return f'"{self.tool}" -b {self.block_size} -s {self.length} -p {self.page_size} --unpack "{output_dir}" "{input_file}"'

# SPIFFS helpers copied from ESP32, https://github.com/platformio/platform-espressif32/blob/develop/builder/main.py
# Copyright 2014-present PlatformIO <contact@platformio.org>
# Licensed under the Apache License, Version 2.0 (the "License");

def _parse_size(value):
    if isinstance(value, int):
        return value
    elif value.isdigit():
        return int(value)
    elif value.startswith("0x"):
        return int(value, 16)
    elif value[-1].upper() in ("K", "M"):
        base = 1024 if value[-1].upper() == "K" else 1024 * 1024
        return int(value[:-1]) * base
    return value

## FS helpers for ESP8266
# copied from https://github.com/platformio/platform-espressif8266/blob/develop/builder/main.py
# Copyright 2014-present PlatformIO <contact@platformio.org>
# Licensed under the Apache License, Version 2.0 (the "License");

def _parse_ld_sizes(ldscript_path):
    assert ldscript_path
    result = {}
    # get flash size from LD script path
    match = re.search(r"\.flash\.(\d+[mk]).*\.ld", ldscript_path)
    if match:
        result['flash_size'] = _parse_size(match.group(1))

    appsize_re = re.compile(
        r"irom0_0_seg\s*:.+len\s*=\s*(0x[\da-f]+)", flags=re.I)
    filesystem_re = re.compile(
        r"PROVIDE\s*\(\s*_%s_(\w+)\s*=\s*(0x[\da-f]+)\s*\)" % "FS"
        if "arduino" in env.subst("$PIOFRAMEWORK")
        else "SPIFFS",
        flags=re.I,
    )
    with open(ldscript_path) as fp:
        for line in fp.readlines():
            line = line.strip()
            if not line or line.startswith("/*"):
                continue
            match = appsize_re.search(line)
            if match:
                result['app_size'] = _parse_size(match.group(1))
                continue
            match = filesystem_re.search(line)
            if match:
                result['fs_%s' % match.group(1)] = _parse_size(
                    match.group(2))
    return result

def esp8266_fetch_fs_size(env):
    ldsizes = _parse_ld_sizes(env.GetActualLDScript())
    for key in ldsizes:
        if key.startswith("fs_"):
            env[key.upper()] = ldsizes[key]

    assert all([
        k in env
        for k in ["FS_START", "FS_END", "FS_PAGE", "FS_BLOCK"]
    ])

    # esptool flash starts from 0
    for k in ("FS_START", "FS_END"):
        _value = 0
        if env[k] < 0x40300000:
            _value = env[k] & 0xFFFFF
        elif env[k] < 0x411FB000:
            _value = env[k] & 0xFFFFFF
            _value -= 0x200000  # correction
        else:
            _value = env[k] & 0xFFFFFF
            _value += 0xE00000  # correction

        env[k] = _value

## Script interface functions
def parse_partition_table(content):
    entries = [e for e in content.split(b'\xaaP') if len(e) > 0]
    #print("Partition data:")
    for entry in entries:
        type = entry[1]
        if type in [0x82,0x83]: # SPIFFS or LITTLEFS
            offset = int.from_bytes(entry[2:5], byteorder='little', signed=False)
            size = int.from_bytes(entry[6:9], byteorder='little', signed=False)
            #print("type:",hex(type))
            #print("address:",hex(offset))
            #print("size:",hex(size))
            env["FS_START"] = offset
            env["FS_SIZE"] = size
            env["FS_PAGE"] = int("0x100", 16)
            env["FS_BLOCK"] = int("0x1000", 16)

def get_partition_table():
    esptoolpy = join(platform.get_package_dir("tool-esptoolpy") or "", "esptool.py")
    upload_port = join(env.get("UPLOAD_PORT", "none"))
    download_speed = join(str(board.get("download.speed", "115200")))
    if "none" in upload_port:
        env.AutodetectUploadPort()
        upload_port = join(env.get("UPLOAD_PORT", "none"))
    fs_file = join(env["PROJECT_DIR"], "partition_table_from_flash.bin")
    esptoolpy_flags = [
            "--chip", mcu,
            "--port", upload_port,
            "--baud",  download_speed,
            "--before", "default_reset",
            "--after", "hard_reset",
            "read_flash",
            "0x8000",
            "0x1000",
            fs_file
    ]
    esptoolpy_cmd = [env["PYTHONEXE"], esptoolpy] + esptoolpy_flags
    try:
        returncode = subprocess.call(esptoolpy_cmd, shell=False)
    except subprocess.CalledProcessError as exc:
        print("Downloading failed with " + str(exc))
    with open(fs_file, mode="rb") as file:
        content = file.read()
        parse_partition_table(content)

def get_fs_type_start_and_length():
    platform = env["PIOPLATFORM"]
    if platform == "espressif32":
        print(f"Retrieving filesystem info for {mcu}.")
        get_partition_table()
        return FS_Info(env["FS_START"], env["FS_SIZE"], env["FS_PAGE"], env["FS_BLOCK"])
    elif platform == "espressif8266":
        print("Retrieving filesystem info for ESP8266.")
        filesystem = board.get("build.filesystem", "littlefs")
        if filesystem not in ("littlefs"):
            print("Unrecognized board_build.filesystem option '" + str(filesystem) + "'.")
            env.Exit(1)
        # fetching sizes is the same for all filesystems
        esp8266_fetch_fs_size(env)
        #print("FS_START: " + hex(env["FS_START"]))
        #print("FS_SIZE: " + hex(env["FS_END"] - env["FS_START"]))
        #print("FS_PAGE: " + hex(env["FS_PAGE"]))
        #print("FS_BLOCK: " + hex(env["FS_BLOCK"]))
        if filesystem == "littlefs":
            print("Recognized LittleFS filesystem.")
            return FS_Info(env["FS_START"], env["FS_END"] - env["FS_START"], env["FS_PAGE"], env["FS_BLOCK"])
        else:
            print("Unrecongized configuration.")
    pass

def download_fs(fs_info: FSInfo):
    print(fs_info)
    esptoolpy = join(platform.get_package_dir("tool-esptoolpy") or "", "esptool.py")
    upload_port = join(env.get("UPLOAD_PORT", "none"))
    download_speed = join(str(board.get("download.speed", "115200")))
    if "none" in upload_port:
        env.AutodetectUploadPort()
        upload_port = join(env.get("UPLOAD_PORT", "none"))
    fs_file = join(env.subst("$BUILD_DIR"), f"downloaded_fs_{hex(fs_info.start)}_{hex(fs_info.length)}.bin")
    esptoolpy_flags = [
            "--chip", mcu,
            "--port", upload_port,
            "--baud",  download_speed,
            "--before", "default_reset",
            "--after", "hard_reset",
            "read_flash",
            hex(fs_info.start),
            hex(fs_info.length),
            fs_file
    ]
    esptoolpy_cmd = [env["PYTHONEXE"], esptoolpy] + esptoolpy_flags
    print("Download filesystem image")
    try:
        returncode = subprocess.call(esptoolpy_cmd, shell=False)
        return (True, fs_file)
    except subprocess.CalledProcessError as exc:
        print("Downloading failed with " + str(exc))
        return (False, "")

def unpack_fs(fs_info: FSInfo, downloaded_file: str):
    # by writing custom_unpack_dir = some_dir in the platformio.ini, one can
    # control the unpack directory
    unpack_dir = env.GetProjectOption("custom_unpack_dir", "unpacked_fs")
    if not os.path.exists(downloaded_file):
        print(f"ERROR: {downloaded_file} with filesystem not found, maybe download failed due to download_speed setting being too high.")
        assert(0)
    try:
        if os.path.exists(unpack_dir):
            shutil.rmtree(unpack_dir)
    except Exception as exc:
        print("Exception while attempting to remove the folder '" + str(unpack_dir) + "': " + str(exc))
    if not os.path.exists(unpack_dir):
        os.makedirs(unpack_dir)

    cmd = fs_info.get_extract_cmd(downloaded_file, unpack_dir)
    print("Unpack files from filesystem image")
    try:
        returncode = subprocess.call(cmd, shell=True)
        return (True, unpack_dir)
    except subprocess.CalledProcessError as exc:
        print("Unpacking filesystem failed with " + str(exc))
        return (False, "")

def display_fs(extracted_dir):
    # extract command already nicely lists all extracted files.
    # no need to display that ourselves. just display a summary
    file_count = sum([len(files) for r, d, files in os.walk(extracted_dir)])
    print("Extracted " + str(file_count) + " file(s) from filesystem.")

def command_download_fs(*args, **kwargs):
    info = get_fs_type_start_and_length()
    download_ok, downloaded_file = download_fs(info)
    unpack_ok, unpacked_dir = unpack_fs(info, downloaded_file)
    if unpack_ok is True:
        display_fs(unpacked_dir)


env.AddCustomTarget(
    name="downloadfs",
    dependencies=None,
    actions=[
        command_download_fs
    ],
    title="Download Filesystem",
    description="Downloads and displays files stored in the target ESP32/ESP8266"
)

-------- [ Separator ] ------

File Name: include/Alarm.h
Size: 4.31 KB
Code:
#pragma once

#include <Arduino.h>
#include <vector>
#include "MeasurementPoint.h"
#include "LoggerManager.h"

// Forward declaration
class MeasurementPoint;

enum class AlarmType {
    HIGH_TEMPERATURE,    // This should be OK since it's not just "HIGH"
    LOW_TEMPERATURE,     // This should be OK since it's not just "LOW"
    SENSOR_ERROR,
    SENSOR_DISCONNECTED
};


enum class AlarmStage {
    NEW,                    // Just triggered
    CLEARED,                // Condition cleared but still in delay
    RESOLVED,                // Fully resolved
    ACKNOWLEDGED,           // Operator acknowledged
    ACTIVE                 // Confirmed and active


};

enum class AlarmPriority {
    PRIORITY_LOW,
    PRIORITY_MEDIUM,
    PRIORITY_HIGH,
    PRIORITY_CRITICAL
};


class Alarm {
public:
    // Constructor
    Alarm(AlarmType type, MeasurementPoint* source, AlarmPriority priority = AlarmPriority::PRIORITY_MEDIUM);
    
    // Destructor
    ~Alarm();
    
    // Getters
    AlarmType getType() const { return _type; }
    AlarmStage getStage() const { return _stage; }
    AlarmPriority getPriority() const { return _priority; }
    MeasurementPoint* getSource() const { return _source; }
    unsigned long getTimestamp() const { return _timestamp; }
    unsigned long getAcknowledgedTime() const { return _acknowledgedTime; }
    unsigned long getClearedTime() const { return _clearedTime; }
    String getMessage() const { return _message; }
    bool isActive() const { return _stage == AlarmStage::ACTIVE || _stage == AlarmStage::ACKNOWLEDGED; }
    bool isAcknowledged() const { return _stage == AlarmStage::ACKNOWLEDGED || _stage == AlarmStage::CLEARED; }
    bool isResolved() const { return _stage == AlarmStage::RESOLVED; }
    
    // State management
    void acknowledge();
    void clear();
    void resolve();
    void reactivate();
    
    // Update alarm condition
    bool updateCondition();
    
    // Display methods
    String getDisplayText() const;
    String getStatusText() const;
    
    // Alarm behavior configuration
    void setDelayTime(unsigned long delayMs) { _delayTime = delayMs; }
    unsigned long getDelayTime() const { return _delayTime; }
    
    // Check if delay has elapsed
    bool isDelayElapsed() const;
    
    // Comparison operators for sorting
    bool operator<(const Alarm& other) const;
    bool operator==(const Alarm& other) const;

    String getTypeString() const;
    String getStageString() const;

    // Configuration support
    String getConfigKey() const;
    void setConfigKey(const String& key);
    bool isEnabled() const { return _enabled; }
    void setEnabled(bool enabled);
    uint8_t getPointAddress() const { return _source ? _source->getAddress() : 255; }

    void setPriority(AlarmPriority priority);
    void setStage(AlarmStage stage);
    
    void setHysteresis(int16_t hysteresis);
    int16_t getHysteresis() const { return _hysteresis; }

    void setAcknowledgedDelay(unsigned long delay);
    unsigned long getAcknowledgedDelay() const;
    bool isAcknowledgedDelayElapsed() const;
    unsigned long getAcknowledgedTimeLeft() const;


    

private:
    AlarmType _type;
    AlarmStage _stage;
    AlarmPriority _priority;
    MeasurementPoint* _source;
    
    // Timestamps
    unsigned long _timestamp;        // When alarm was created
    unsigned long _acknowledgedTime; // When alarm was acknowledged
    unsigned long _clearedTime;      // When condition cleared

    int16_t _hysteresis;  // Configurable hysteresis value
    
    // Configuration
    unsigned long _delayTime;        // Delay before auto-resolve
    
    // Display message
    String _message;
    
    // Internal methods
    void _updateMessage();
    bool _checkCondition();

    String _getPriorityString() const;

    String _configKey;  // Format: "alarm_<point>_<type>"
    bool _enabled;      // Whether this alarm is active in configuration
    unsigned long _acknowledgedDelay; 
    String _getPriorityString(AlarmPriority priority) const;
};

// Alarm comparison function for sorting by priority and timestamp
struct AlarmComparator {
    bool operator()(const Alarm* a, const Alarm* b) const {
        if (a->getPriority() != b->getPriority()) {
            return static_cast<int>(a->getPriority()) > static_cast<int>(b->getPriority());
        }
        return a->getTimestamp() < b->getTimestamp();
    }
};

-------- [ Separator ] ------

File Name: include/CSVConfigManager.h
Size: 1.60 KB
Code:
#pragma once

#include <Arduino.h>
#include <CSV_Parser.h>
#include "TemperatureController.h"

class CSVConfigManager {
public:
    CSVConfigManager(TemperatureController& controller);
    
    // CSV export/import for combined points and alarms
    String exportPointsWithAlarmsToCSV();
    bool importPointsWithAlarmsFromCSV(const String& csvData);
    
    // Individual exports (if needed)
    String exportSensorsToCSV();
    bool importSensorsFromCSV(const String& csvData);
    
    // File operations
    bool saveCSVToFile(const String& filename, const String& csvData);
    String loadCSVFromFile(const String& filename);
    
    // Validation
    bool validatePointsCSV(const String& csvData);
    String getLastError() const { return _lastError; }

private:
    TemperatureController& _controller;
    String _lastError;
    
    // Helper methods
    String _escapeCSVField(const String& field);
    String _unescapeCSVField(const String& field);
    bool _parseAlarmFromCSV(int pointAddress, const String& alarmType, 
                           const String& priority, const String& enabled, 
                           const String& hysteresis);
    
    // Additional helper methods needed
    String _getAlarmTypeString(AlarmType type);
    AlarmType _parseAlarmType(const String& typeStr);
    String _getPriorityString(AlarmPriority priority);
    AlarmPriority _parsePriority(const String& priorityStr);
    void _exportPointToCSV(String& csv, MeasurementPoint* point, const String& pointType);
    bool _parseCSVLine(const String& line);
    String _getAlarmPriorityForPoint(int pointAddress, AlarmType alarmType);
};

-------- [ Separator ] ------

File Name: include/ConfigManager.h
Size: 4.10 KB
Code:
#ifndef CONFIG_MANAGER_H
#define CONFIG_MANAGER_H

#include <Arduino.h>
#include <ConfigAssist.h>
#include <ConfigAssistHelper.h>
#include <WebServer.h>
#include <LittleFS.h>
#include "TemperatureController.h"
#include "CSVConfigManager.h"
#include "SettingsCSVManager.h"
#include "LoggerManager.h" 

// YAML configuration definition
extern const char* VARIABLES_DEF_YAML;

class ConfigManager {
private:
    SettingsCSVManager settingsCSVManager;
    CSVConfigManager csvManager;
    ConfigAssist conf;
    ConfigAssistHelper* confHelper;
    TemperatureController& controller;
    WebServer* server;
    bool portalActive;
    
    // Callback function for ConfigAssist
    static void onConfigChanged(String key);
    
    // Pointer to instance for callback functions
    static ConfigManager* instance;
    void _applySettingsWithoutRestart();

    void basicAPI();
    void sensorAPI();
    void csvImportExportAPI();
    void pointsAPI();
    void alarmsAPI();
    void logsAPI();
    void downloadAPI();

    
    // Save sensor configuration to file
    //void saveSensorConfig();
    
    // Load sensor configuration from file
    //void loadSensorConfig();

public:
    ConfigManager(TemperatureController& tempController);
    ~ConfigManager();
    
    // Initialize configuration
    bool begin();
    
    // Update configuration (call in loop)
    void update();
    
    // Connect to WiFi
    bool connectWiFi(int timeoutMs = 15000);
    
    // Add sensor to configuration
    // bool addSensorToConfig(SensorType type, uint8_t address, const String& name, 
    //                       const uint8_t* romAddress = nullptr);
    
    // Remove sensor from configuration
    //bool removeSensorFromConfig(uint8_t address);
    
    // Update sensor in configuration
    // bool updateSensorInConfig(uint8_t address, const String& name, 
    //                          int16_t lowAlarm, int16_t highAlarm);
    
    // Get web server instance
    WebServer* getWebServer() { return server; }
    
    // Check if portal is active
    bool isPortalActive() { return portalActive; }
    
    // Get configuration values
    String getWifiSSID() { return conf("st_ssid"); }
    String getWifiPassword() { return conf("st_pass"); }
    String getHostname() { return conf("host_name"); }
    uint16_t getDeviceId() { return conf("device_id").toInt(); }
    uint16_t getMeasurementPeriod() { return conf("measurement_period").toInt(); }
    bool isModbusEnabled() { return conf("modbus_enabled").toInt() == 1; }
    uint8_t getModbusAddress() { return conf("modbus_address").toInt(); }
    uint32_t getModbusBaudRate() { return conf("modbus_baud_rate").toInt(); }
    uint8_t getRxPin() { return conf("rs485_rx_pin").toInt(); }
    uint8_t getTxPin() { return conf("rs485_tx_pin").toInt(); }
    //uint8_t getDePin() { return conf("rs485_de_pin").toInt(); }
    //uint8_t getOneWirePin() { return conf("onewire_pin").toInt(); }
    bool getAutoDiscover() { return conf("auto_discover").toInt() == 1; }
    
    // Reset min/max values
    void resetMinMaxValues();
    //void updateSensorInConfig(Sensor* sensor);
    // Remove:
// void saveSensorConfig();
// void loadSensorConfig();
// bool addSensorToConfig(...);
// bool removeSensorFromConfig(...);
// bool updateSensorInConfig(...);
// void updateSensorInConfig(Sensor* sensor);

    // Add:
    void savePointsConfig();
    void loadPointsConfig();
    bool updatePointInConfig(uint8_t address, const String& name, int16_t lowAlarm, int16_t highAlarm,
                            const String& ds18b20RomString = "", int pt1000ChipSelect = -1);
    
    void saveAlarmsConfig();
    void loadAlarmsConfig();

    CSVConfigManager& getCSVManager() { return csvManager; }

    uint16_t getAcknowledgedDelayCritical() { return conf("ack_delay_critical").toInt(); }
    uint16_t getAcknowledgedDelayHigh() { return conf("ack_delay_high").toInt(); }
    uint16_t getAcknowledgedDelayMedium() { return conf("ack_delay_medium").toInt(); }
    uint16_t getAcknowledgedDelayLow() { return conf("ack_delay_low").toInt(); }
    };

// Initialize static member
//ConfigManager* ConfigManager::instance = nullptr;

#endif // CONFIG_MANAGER_H

-------- [ Separator ] ------

File Name: include/IndicatorInterface.h
Size: 5.91 KB
Code:
#ifndef INDICATOR_INTERFACE_H
#define INDICATOR_INTERFACE_H

#include <Arduino.h>
#include <Wire.h>
#include <map>
#include <string>
#include "PCF8575.h"
#include <U8g2lib.h>
#include <vector>
#include "LoggerManager.h"

class IndicatorInterface {
public:
    struct BlinkingPort {
        std::string portName;
        unsigned long onTime;
        unsigned long offTime;
        unsigned long lastToggleTime;
        bool currentState;
        bool isActive;
    };
    // Constructor
    IndicatorInterface(TwoWire& i2cBus, uint8_t pcf_i2cAddress, int intPin = -1);
    
    // Destructor
    ~IndicatorInterface();
    
    // Initialization
    bool begin();
    void update();
    
    // Configuration setters
    void setDirection(uint16_t directionMask);          // 0 = input, 1 = output
    void setMode(uint16_t modeMask);                    // 0 = normal, 1 = inverted
    void setPortNames(const std::map<std::string, uint8_t>& portNames);
    void setPortName(const std::string& name, uint8_t portNumber);
    
    // Port control methods
    bool writePort(const std::string& portName, bool state);
    bool writePort(uint8_t portNumber, bool state);
    void writePorts(uint16_t portMask);                 // Write only to outputs
    void setAllOutputs(bool state);
    void setAllOutputsHigh();
    void setAllOutputsLow();
    
    void setPortInverted(const std::string& portName, bool inverted);
    void setPortInverted(uint8_t portNumber, bool inverted);

    
    // Port reading methods
    uint16_t getCurrentState();
    bool readPort(const std::string& portName);
    bool readPort(uint8_t portNumber);
    
    // Utility methods
    bool isOutput(uint8_t portNumber);
    bool isInput(uint8_t portNumber);
    bool isInverted(uint8_t portNumber);
    uint8_t getPortNumber(const std::string& portName);
    std::string getPortName(uint8_t portNumber);
    
    // Interrupt handling
    void handleInterrupt();
    void setInterruptCallback(void (*callback)(uint16_t currentState, uint16_t changedPins));
    
    // Debug methods
    void printPortStates();
    void printConfiguration();

    // OLED control methods
    void setOledSleepDelay(long sleepDelay);        // -1 = never sleep
    void setOledMode(int lines);                    // 1-5 lines
    void printText(String buffer[], int bufferSize);
    void setOLEDblink(int timeOn, int timeOff, bool blinkOn = true);
    void setOLEDOff();
    void setOLEDOn();
    void updateOLED();                              // Call this in loop for scrolling/blinking

    // Add these to the public section:
    void pushLine(String newLine);                      // Push new line, shift others down
    void displayOK();                                   // Display huge "OK"
    void displayCross();                                // Display huge cross in circle
    void blinkOK(int blinkDelay);                       // Blink between OK and previous text
    void blinkCross(int blinkDelay);                    // Blink between cross and previous text
    void stopBlinking();                                // Stop any blinking and restore text

    void startBlinking(const std::string& portName, unsigned long onTime, unsigned long offTime);
    void stopBlinking(const std::string& portName);
    void updateBlinking();
    bool isBlinking(const std::string& portName);


private:



    std::vector<BlinkingPort> _blinkingPorts;

    // Hardware configuration
    TwoWire* _i2cBus;
    uint8_t _pcf_i2cAddress;
    uint8_t oled_i2cAddress;
    int _intPin;
    PCF8575 _pcf8575;
    
    // Port configuration
    uint16_t _directionMask;    // 0 = input, 1 = output
    uint16_t _modeMask;         // 0 = normal, 1 = inverted
    std::map<std::string, uint8_t> _portNames;
    std::map<uint8_t, std::string> _portNumbers;
    
    // State tracking
    uint16_t _currentState;
    uint16_t _lastState;
    unsigned long _lastReadTime;
    unsigned long _pollInterval;
    
    // Interrupt handling
    volatile bool _interruptFlag;
    bool _useInterrupts;
    void (*_interruptCallback)(uint16_t currentState, uint16_t changedPins);
    
    // Internal methods
    void _updateState();
    void _clearInterrupt();
    uint16_t _readPCF();
    void _writePCF(uint16_t state);
    bool _applyModeLogic(uint8_t portNumber, bool state);
    bool _reverseModeLogic(uint8_t portNumber, bool state);
    void _configureInterruptPin();
    
    // Static interrupt handler
    static IndicatorInterface* _instance;
    static void IRAM_ATTR _staticInterruptHandler();
    static U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2;

    // OLED configuration
    long _oledSleepDelay;
    int _oledLines;
    String _textBuffer[5];                          // Max 5 lines
    int _textBufferSize;
    bool _oledOn;
    bool _oledBlink;
    int _blinkTimeOn;
    int _blinkTimeOff;
    unsigned long _lastBlinkTime;
    bool _blinkState;
    unsigned long _lastActivityTime;
    bool _oledSleeping;
    
    // Scrolling variables
    int _scrollOffset[5];                           // Scroll offset for each line
    unsigned long _lastScrollTime;
    int _scrollDelay;
    int _charWidth;
    int _lineHeight;
    int _maxCharsPerLine;
    
    // Internal OLED methods
    void _initOLED();
    void _updateOLEDDisplay();
    void _handleOLEDSleep();
    void _handleOLEDBlink();
    void _handleScrolling();
    void _drawTextLine(int lineIndex, int yPos);
    void _calculateDisplayParams();
    void _wakeOLED();
    //void _fixSH1106Offset();
    // Add these to the private section:
    String _savedTextBuffer[5];                         // Backup of text before OK/Cross
    int _savedTextBufferSize;
    int _savedOledLines;
    bool _isBlinkingOK;
    bool _isBlinkingCross;
    int _blinkDelayTime;
    unsigned long _lastBlinkToggle;
    bool _blinkShowSpecial;                             // true = show OK/Cross, false = show text

    // Internal methods
    void _saveCurrentText();
    void _restoreCurrentText();
    void _handleSpecialBlink();

};

#endif

-------- [ Separator ] ------

File Name: include/LoggerManager.h
Size: 9.46 KB
Code:
#ifndef LOGGERMANAGER_H
#define LOGGERMANAGER_H

#include <Arduino.h>
#include "FS.h"
#include "SD.h"
//#include "TemperatureController.h"
#include "TimeManager.h"
#include <vector>
#include "LoggerManager.h"

// Add forward declaration instead
class TemperatureController;  // Forward declaration
class MeasurementPoint;

class LoggerManager {
private:
    static LoggerManager* _instance;
    TemperatureController* _controller;
    TimeManager* _timeManager;
    fs::FS* _fs;
    
    unsigned long _logFrequency;     // Logging frequency in milliseconds
    unsigned long _lastLogTime;     // Last time data was logged
    String _currentLogFile;         // Current log file name
    bool _headerWritten;            // Flag to track if header is written
    
    // Configuration
    bool _enabled;
    String _logDirectory;
    bool _dailyFiles;               // Create new file each day
    String _lastLogDate;            // Track date for daily file creation
    
    // Private methods
    String _generateLogFileName();
    String _generateCSVHeader();
    bool _writeHeader();
    bool _writeDataRow();
    String _escapeCSVField(const String& field);
    bool _ensureDirectoryExists();
    String _getCurrentDateString();
    String _getCurrentTimeString();
    

    bool _recoverFromExistingFiles();
    String _findLatestFileForDate(const String& dateStr);
    int _extractSequenceNumber(const String& filename);
    String _readHeaderFromFile(const String& filename);
    std::vector<String> _getFilesForDate(const String& dateStr);
    int _findHighestSequenceForDate(const String& dateStr);

    // Header change detection
    String _lastGeneratedHeader;
    bool _headerChanged;
    int _fileSequenceNumber;
    
    // New private methods
    bool _hasHeaderChanged();
    String _generateLogFileNameWithSequence();
    void _incrementSequenceNumber();

    // Event logging
    bool _eventLoggingEnabled;
    String _eventLogDirectory;
    String _currentEventLogFile;
    String _lastEventLogDate;
    
    // Event logging methods
    String _generateEventLogFileName();
    bool _writeEventHeader();
    bool _writeEventRow(const String& timestamp, const String& source, 
                       const String& description, const String& priority);
    bool _ensureEventLogExists();

    // Alarm state logging
    bool _alarmStateLoggingEnabled;
    String _alarmStateLogDirectory;
    String _currentAlarmStateLogFile;
    String _lastAlarmStateLogDate;
    
    // Alarm state logging methods
    String _generateAlarmStateLogFileName();
    bool _writeAlarmStateHeader();
    bool _ensureAlarmStateLogExists();
    bool _writeAlarmStateRow(const String& timestamp, int pointNumber, const String& pointName,
        const String& alarmType, const String& alarmPriority,
        const String& previousState, const String& newState,
        int16_t currentTemp, int16_t threshold);

    
    bool _isSDCardAvailable();

    
public:
    LoggerManager(TemperatureController& controller, TimeManager& timeManager, fs::FS& filesystem);
    ~LoggerManager();

    static LoggerManager* getInstance() { return _instance; }
    
    // Add these static convenience methods
    static bool info(const String& source, const String& description) {
        return _instance ? _instance->logInfo(source, description) : false;
    }
    
    static bool warning(const String& source, const String& description) {
        return _instance ? _instance->logWarning(source, description) : false;
    }
    
    static bool error(const String& source, const String& description) {
        return _instance ? _instance->logError(source, description) : false;
    }
    
    static bool critical(const String& source, const String& description) {
        return _instance ? _instance->logCritical(source, description) : false;
    }
    
    // Initialization
    bool init(); 
    bool begin();
    
    // Configuration methods
    void setLogFrequency(unsigned long frequencyMs);
    unsigned long getLogFrequency() const;
    void setEnabled(bool enabled);
    bool isEnabled() const;
    void setDailyFiles(bool enabled);
    bool isDailyFiles() const;
    void setLogDirectory(const String& directory);
    static String getLogDirectory();
    
    // Logging methods
    void update();                  // Call this in main loop
    bool logDataNow();             // Force immediate logging
    bool createNewLogFile();       // Create new log file
    
    // File management
    String getCurrentLogFile() const;
    bool closeCurrentFile();
    static std::vector<String> getLogFiles();
    bool deleteLogFile(const String& filename);
    
    // Statistics
    unsigned long getLastLogTime() const;
    size_t getLogFileSize() const;
    
    // Error handling
    String getLastError() const;

    void forceNewFile();
    int getCurrentSequenceNumber() const;
    void resetSequenceNumber();

        // Event logging configuration
        void setEventLoggingEnabled(bool enabled);
        bool isEventLoggingEnabled() const;
        void setEventLogDirectory(const String& directory);
        String getEventLogDirectory() const;
        
        // Event logging methods
        bool logEvent(const String& source, const String& description, const String& priority = "INFO");
        bool logInfo(const String& source, const String& description);
        bool logWarning(const String& source, const String& description);
        bool logError(const String& source, const String& description);
        bool logCritical(const String& source, const String& description);
        
        // Event log management
        String getCurrentEventLogFile() const;
        std::vector<String> getEventLogFiles();
        bool deleteEventLogFile(const String& filename);


    // Alarm state logging configuration
    void setAlarmStateLoggingEnabled(bool enabled);
    bool isAlarmStateLoggingEnabled() const;
    void setAlarmStateLogDirectory(const String& directory);
    String getAlarmStateLogDirectory() const;
    
    // Static method for alarm state logging
    static bool logAlarmStateChange(int pointNumber, const String& pointName, 
                                   const String& alarmType, const String& alarmPriority,
                                   const String& previousState, const String& newState,
                                   int16_t currentTemp, int16_t threshold);
    
    // Instance method for alarm state logging
    bool logAlarmState(int pointNumber, const String& pointName, 
                      const String& alarmType, const String& alarmPriority,
                      const String& previousState, const String& newState,
                      int16_t currentTemp, int16_t threshold);
    
    // Alarm state log management
    String getCurrentAlarmStateLogFile() const;
    //static std::vector<String> getAlarmStateLogFiles();
    bool deleteAlarmStateLogFile(const String& filename);

        // Static alarm history retrieval methods
    // static String getAlarmHistoryJson(const String& startDate, const String& endDate);
    // static String getAlarmHistoryCsv(const String& startDate, const String& endDate);
    
    // Event log retrieval methods
    // static String getEventLogsJson(const String& startDate, const String& endDate);
    // static String getEventLogsCsv(const String& startDate, const String& endDate);

    // Static event log retrieval methods
    static String getEventLogsJson(const String& startDate, const String& endDate);
    static String getEventLogsCsv(const String& startDate, const String& endDate);
    static String getEventLogStatsJson(const String& startDate, const String& endDate);
    //static std::vector<String> getEventLogFilesStatic();
    
    // Static alarm history retrieval methods (already existing)
    static String getAlarmHistoryJson(const String& startDate, const String& endDate);
    static String getAlarmHistoryCsv(const String& startDate, const String& endDate);

    // Static methods for file operations
    //static std::vector<String> getLogFiles();
    static std::vector<String> getEventLogFilesStatic();
    static std::vector<String> getAlarmStateLogFiles();
    
    // Static methods for file information
    static bool getFileInfo(const String& filename, const String& type, size_t& fileSize, String& date);
    
    // Static methods for file streaming
    static File openLogFile(const String& filename, const String& type);
    static String getLogDirectoryPath(const String& type);
    
    
private:
    String _lastError;
    // Make helper methods static too
    // static std::vector<String> _getAlarmLogFilesInRange(const String& startDate, const String& endDate);
    // static bool _parseAlarmStateLogEntry(const String& line, DynamicJsonDocument& entry);
    // static String _normalizeDate(const String& dateStr);

    // Helper methods for event logs
    // static std::vector<String> _getEventLogFilesInRange(const String& startDate, const String& endDate);
    // static bool _parseEventLogEntry(const String& line, DynamicJsonDocument& entry);

    // Static helper methods for event logs
    static std::vector<String> _getEventLogFilesInRange(const String& startDate, const String& endDate);
    static bool _parseEventLogEntry(const String& line, DynamicJsonDocument& entry);
    
    // Make existing helper methods static too (if not already)
    static std::vector<String> _getAlarmLogFilesInRange(const String& startDate, const String& endDate);
    static bool _parseAlarmStateLogEntry(const String& line, DynamicJsonDocument& entry);
    static String _normalizeDate(const String& dateStr);
};

#endif // LOGGERMANAGER_H

-------- [ Separator ] ------

File Name: include/MeasurementPoint.h
Size: 1.93 KB
Code:
#ifndef MEASUREMENT_POINT_H
#define MEASUREMENT_POINT_H

#include <Arduino.h>
#include "Sensor.h"
#include "LoggerManager.h"



class MeasurementPoint {
public:
    // Constructor
    MeasurementPoint() : address(0), name(""), currentTemp(0), minTemp(32767), maxTemp(-32768),
    lowAlarmThreshold(-10), highAlarmThreshold(50), alarmStatus(0), errorStatus(0), boundSensor(nullptr) {}
    MeasurementPoint(uint8_t address, const String& name);

    // Destructor
    ~MeasurementPoint();

    // Getters
    uint8_t getAddress() const;
    String getName() const;
    int16_t getCurrentTemp() const;
    int16_t getMinTemp() const;
    int16_t getMaxTemp() const;
    int16_t getLowAlarmThreshold() const;
    int16_t getHighAlarmThreshold() const;
    uint8_t getAlarmStatus() const;
    uint8_t getErrorStatus() const;

    // Setters
    void setName(const String& newName);
    void setLowAlarmThreshold(int16_t threshold);
    void setHighAlarmThreshold(int16_t threshold);

    // Sensor binding (optional)
    void bindSensor(Sensor* sensor);
    void unbindSensor();
    Sensor* getBoundSensor() const;

    // Operations
    void update();              // Should be called to refresh temperature and status
    void resetMinMaxTemp();     // Resets min/max to current
    // void setOneWireBus(uint8_t bus);
    // uint8_t getOneWireBus();

private:
    uint8_t address;
    String name;
    // uint8_t oneWireBus;

    int16_t currentTemp;        // Latest temperature (°C x1)
    int16_t minTemp;            // Minimum recorded temperature
    int16_t maxTemp;            // Maximum recorded temperature
    int16_t lowAlarmThreshold;  // Alarm threshold low
    int16_t highAlarmThreshold; // Alarm threshold high
    uint8_t alarmStatus;        // Alarm status bits
    uint8_t errorStatus;        // Error status bits

    Sensor* boundSensor;        // Pointer to bound sensor, or nullptr

    void updateAlarmStatus();
};


#endif // TEMPERATURE_CONTROLLER_H

-------- [ Separator ] ------

File Name: include/RegisterMap.h
Size: 3.92 KB
Code:
#ifndef REGISTER_MAP_H
#define REGISTER_MAP_H

#include <stdint.h>
#include "MeasurementPoint.h"

class RegisterMap {
private:
    // Device Information Registers (0-99)
    uint16_t deviceId;
    uint16_t firmwareVersion;
    uint16_t numActiveDS18B20;
    uint16_t numActivePT1000;
    uint16_t deviceStatus[7]; // Registers 4-10

    // Temperature Data Registers (100-599)
    int16_t currentTemps[60];    // 100-159
    int16_t minTemps[60];        // 200-259
    int16_t maxTemps[60];        // 300-359
    uint16_t alarmStatus[60];    // 400-459
    uint16_t errorStatus[60];    // 500-559

    // Configuration Registers (600-799)
    int16_t lowAlarmThresholds[60];  // 600-659
    int16_t highAlarmThresholds[60]; // 700-759

    // Helpers
    bool isValidAddress(uint16_t address);
    bool isReadOnlyRegister(uint16_t address);

public:
    RegisterMap();

    // Register read/write
    uint16_t readHoldingRegister(uint16_t address);
    bool writeHoldingRegister(uint16_t address, uint16_t value);

    // Update register map from measurement point data
    void updateFromMeasurementPoint(const MeasurementPoint& point);

    // Apply config (thresholds) to and from measurement points
    void applyConfigToMeasurementPoint(MeasurementPoint& point);
    void applyConfigFromMeasurementPoint(const MeasurementPoint& point);

    // Utility methods for device info
    void incrementActiveDS18B20() { numActiveDS18B20++; }
    void decrementActiveDS18B20() { if (numActiveDS18B20 > 0) numActiveDS18B20--; }
    void incrementActivePT1000() { numActivePT1000++; }
    void decrementActivePT1000() { if (numActivePT1000 > 0) numActivePT1000--; }

    uint16_t getDeviceId() const { return deviceId; }
    uint16_t getFirmwareVersion() const { return firmwareVersion; }
    uint16_t getNumActiveDS18B20() const { return numActiveDS18B20; }
    uint16_t getNumActivePT1000() const { return numActivePT1000; }

    // Register address constants (as in your original code)
    static const uint16_t DEVICE_ID_REG = 0;
    static const uint16_t FIRMWARE_VERSION_REG = 1;
    static const uint16_t NUM_DS18B20_REG = 2;
    static const uint16_t NUM_PT1000_REG = 3;
    static const uint16_t DEVICE_STATUS_START_REG = 4;
    static const uint16_t DEVICE_STATUS_END_REG = 10;
    static const uint16_t CURRENT_TEMP_DS18B20_START_REG = 100;
    static const uint16_t CURRENT_TEMP_DS18B20_END_REG = 149;
    static const uint16_t CURRENT_TEMP_PT1000_START_REG = 150;
    static const uint16_t CURRENT_TEMP_PT1000_END_REG = 159;
    static const uint16_t MIN_TEMP_DS18B20_START_REG = 200;
    static const uint16_t MIN_TEMP_DS18B20_END_REG = 249;
    static const uint16_t MIN_TEMP_PT1000_START_REG = 250;
    static const uint16_t MIN_TEMP_PT1000_END_REG = 259;
    static const uint16_t MAX_TEMP_DS18B20_START_REG = 300;
    static const uint16_t MAX_TEMP_DS18B20_END_REG = 349;
    static const uint16_t MAX_TEMP_PT1000_START_REG = 350;
    static const uint16_t MAX_TEMP_PT1000_END_REG = 359;
    static const uint16_t ALARM_STATUS_DS18B20_START_REG = 400;
    static const uint16_t ALARM_STATUS_DS18B20_END_REG = 449;
    static const uint16_t ALARM_STATUS_PT1000_START_REG = 450;
    static const uint16_t ALARM_STATUS_PT1000_END_REG = 459;
    static const uint16_t ERROR_STATUS_DS18B20_START_REG = 500;
    static const uint16_t ERROR_STATUS_DS18B20_END_REG = 549;
    static const uint16_t ERROR_STATUS_PT1000_START_REG = 550;
    static const uint16_t ERROR_STATUS_PT1000_END_REG = 559;
    static const uint16_t LOW_ALARM_DS18B20_START_REG = 600;
    static const uint16_t LOW_ALARM_DS18B20_END_REG = 649;
    static const uint16_t LOW_ALARM_PT1000_START_REG = 650;
    static const uint16_t LOW_ALARM_PT1000_END_REG = 659;
    static const uint16_t HIGH_ALARM_DS18B20_START_REG = 700;
    static const uint16_t HIGH_ALARM_DS18B20_END_REG = 749;
    static const uint16_t HIGH_ALARM_PT1000_START_REG = 750;
    static const uint16_t HIGH_ALARM_PT1000_END_REG = 759;
};

#endif // REGISTER_MAP_H

-------- [ Separator ] ------

File Name: include/Sensor.h
Size: 2.54 KB
Code:
#ifndef SENSOR_H
#define SENSOR_H

#include <Arduino.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <Adafruit_MAX31865.h>

// Define your sensor types
enum class SensorType {
    DS18B20,
    PT1000
};

// Error and alarm bitmasks
constexpr uint8_t ERROR_COMMUNICATION = 0x01;
constexpr uint8_t ERROR_OUT_OF_RANGE  = 0x02;
constexpr uint8_t ERROR_DISCONNECTED  = 0x04;

constexpr uint8_t ALARM_LOW_TEMP  = 0x01;
constexpr uint8_t ALARM_HIGH_TEMP = 0x02;

class Sensor {
public:
    Sensor(SensorType type, uint8_t address, const String& name);
    ~Sensor();

    // Setup methods for each sensor type
    void setupDS18B20(uint8_t pin, const uint8_t* deviceAddress);
    void setupPT1000(uint8_t csPin, uint8_t maxAddress);

    // Initialize hardware
    bool initialize();

    // Read temperature from the sensor, update internal state
    bool readTemperature();

    // Accessors
    SensorType getType() const;
    uint8_t getAddress() const;
    String getName() const;
    void setName(const String& newName);

    int16_t getCurrentTemp() const;
    int16_t getMinTemp() const;
    int16_t getMaxTemp() const;
    int16_t getLowAlarmThreshold() const;
    int16_t getHighAlarmThreshold() const;
    uint8_t getAlarmStatus() const;
    uint8_t getErrorStatus() const;
    uint8_t getPT1000ChipSelectPin() const;
    

    void setAddress(uint8_t newAddress);
    void setLowAlarmThreshold(int16_t threshold);
    void setHighAlarmThreshold(int16_t threshold);

    // DS18B20 ROM address accessor
    const uint8_t* getDS18B20Address() const;

    // Reset min/max values
    void resetMinMaxTemp();

    // Update alarm status (call after reading temperature or changing thresholds)
    void updateAlarmStatus();
    String getDS18B20RomString() const;        // ROM as hex string
    void getDS18B20RomArray(uint8_t out[8]) const; // ROM as array
    uint8_t getOneWirePin() {return connection.ds18b20.oneWirePin;}

private:
    uint8_t address;
    String name;
    SensorType type;

    int16_t currentTemp;
    int16_t minTemp;
    int16_t maxTemp;
    int16_t lowAlarmThreshold;
    int16_t highAlarmThreshold;
    uint8_t alarmStatus;
    uint8_t errorStatus;

    // Hardware-specific members
    OneWire* oneWire;
    DallasTemperature* dallasTemperature;
    Adafruit_MAX31865* max31865;

    // Connection details
    union {
        struct {
            uint8_t oneWirePin;
            uint8_t oneWireAddress[8];
        } ds18b20;
        struct {
            uint8_t csPin;
            uint8_t maxAddress;
        } pt1000;
    } connection;
};

#endif // SENSOR_H

-------- [ Separator ] ------

File Name: include/SettingsCSVManager.h
Size: 826 B
Code:
#pragma once

#include <Arduino.h>
#include "ConfigAssist.h"

class SettingsCSVManager {
public:
    SettingsCSVManager(ConfigAssist& config);
    
    // CSV export/import for settings
    String exportSettingsToCSV();
    bool importSettingsFromCSV(const String& csvData);
    
    // Validation
    bool validateSettingsCSV(const String& csvData);
    String getLastError() const { return _lastError; }

private:
    ConfigAssist& _config;
    String _lastError;
    
    // Helper methods
    String _escapeCSVField(const String& field);
    String _unescapeCSVField(const String& field);
    bool _parseCSVLine(const String& line);
    
    // Add these helper methods for acknowledged delays
    void _exportAcknowledgedDelays(String& csv);
    bool _importAcknowledgedDelays(const String& key, const String& value);
};

-------- [ Separator ] ------

File Name: include/TempModbusServer.h
Size: 1.01 KB
Code:
#ifndef TEMP_MODBUS_SERVER_H
#define TEMP_MODBUS_SERVER_H

#include <Arduino.h>
#include "ModbusServerRTU.h"
#include "RegisterMap.h"
#include "LoggerManager.h"

class TempModbusServer {
private:
    ModbusServerRTU* mbServer;
    RegisterMap& registerMap;
    uint8_t serverID;
    HardwareSerial& serial;
    int rxPin;
    int txPin;
    int dePin;
    int baudRate;
    
    // Worker functions for different Modbus function codes
    static ModbusMessage readHoldingRegistersWorker(ModbusMessage request);
    static ModbusMessage writeHoldingRegisterWorker(ModbusMessage request);
    static ModbusMessage writeMultipleRegistersWorker(ModbusMessage request);
    
    // Pointer to the RegisterMap instance for static worker functions
    static RegisterMap* registerMapPtr;

public:
    TempModbusServer(RegisterMap& regMap, uint8_t id, HardwareSerial& serialPort, 
                 int rx, int tx, int de, int baud = 9600);
    ~TempModbusServer();
    
    bool begin();
    void stop();
};



#endif // TEMP_MODBUS_SERVER_H

-------- [ Separator ] ------

File Name: include/TemperatureController.h
Size: 7.72 KB
Code:
#pragma once

#include <Arduino.h>
#include <vector>
#include "Sensor.h"
#include "MeasurementPoint.h"
#include "RegisterMap.h"
#include "IndicatorInterface.h"
#include "Alarm.h"
#include <OneWire.h>
#include <DallasTemperature.h>
#include <ArduinoJson.h>
#include <algorithm>

class TemperatureController {
public:
    TemperatureController(uint8_t oneWirePin[4], uint8_t csPin[4], IndicatorInterface& indicator);

    

    ~TemperatureController();
    
    bool begin();
    
    // Measurement point management
    MeasurementPoint* getMeasurementPoint(uint8_t address);
    MeasurementPoint* getDS18B20Point(uint8_t idx);
    MeasurementPoint* getPT1000Point(uint8_t idx);
    
    // Sensor management
    bool addSensor(Sensor* sensor);
    bool removeSensorByRom(const String& romString);
    Sensor* findSensorByRom(const String& romString);
    Sensor* findSensorByChipSelect(uint8_t csPin);
    int getSensorCount() const { return sensors.size(); }
    Sensor* getSensorByIndex(int idx);
    
    // Sensor binding
    bool bindSensorToPointByRom(const String& romString, uint8_t pointAddress);
    bool bindSensorToPointByChipSelect(uint8_t csPin, uint8_t pointAddress);
    bool unbindSensorFromPoint(uint8_t pointAddress);
    Sensor* getBoundSensor(uint8_t pointAddress);
    bool unbindSensorFromPointBySensor(Sensor* sensor);
    
    // Main update and measurement
    void update();
    void readAllPoints();
    void updateRegisterMap();
    void applyConfigFromRegisterMap();
    void applyConfigToRegisterMap();
    
    // Sensor discovery
    bool discoverDS18B20Sensors();
    bool discoverPTSensors();
    
    // JSON output
    String getSensorsJson();
    String getPointsJson();
    String getSystemStatusJson();
    
    // Utility functions
    void resetMinMaxValues();
    RegisterMap& getRegisterMap() { return registerMap; }
    
    // Configuration
    void setDeviceId(uint16_t id);
    uint16_t getDeviceId() const;
    void setFirmwareVersion(uint16_t version);
    uint16_t getFirmwareVersion() const;
    void setMeasurementPeriod(uint16_t seconds);
    uint16_t getMeasurementPeriod() const;
    void setOneWireBusPin(uint8_t pin, size_t idx);
    uint8_t getOneWirePin(size_t bus);
    
    // Statistics
    int getDS18B20Count() const;
    int getPT1000Count() const;
    void updateAllSensors();
    int getSensorBus(Sensor* sensor);
    
    // New Alarm Management
    void updateAlarms();
    String getAlarmsJson();
    void handleAlarmDisplay();
    void handleAlarmOutputs();

    std::vector<Alarm*> getActiveAlarms() const;
    void createAlarm(AlarmType type, MeasurementPoint* source, AlarmPriority priority);
    Alarm* getHighestPriorityAlarm() const;
    void acknowledgeHighestPriorityAlarm();
    void acknowledgeAllAlarms();
    void clearResolvedAlarms();
    void clearConfiguredAlarms();

    // Alarm management (similar to sensor management)
    bool addAlarm(AlarmType type, uint8_t pointAddress, AlarmPriority priority);
    bool removeAlarm(const String& configKey);
    bool updateAlarm(const String& configKey, AlarmPriority priority, bool enabled);
    Alarm* findAlarm(const String& configKey);
    Alarm* getAlarmByIndex(int idx);
    int getAlarmCount() const { return _configuredAlarms.size(); }
    std::vector<Alarm*> getConfiguredAlarms() const { return _configuredAlarms; }

    // JSON output (similar to getSensorsJson, getPointsJson)
    //String getAlarmsJson();

    // Alarm handling scenarios (placeholders)
    void handleCriticalAlarms();
    void handleHighPriorityAlarms();
    void handleMediumPriorityAlarms();
    void handleLowPriorityAlarms();

    bool bindSensorToPointByBusNumber(uint8_t busNumber, uint8_t pointAddress);


    // Setters for acknowledged delays
    void setAcknowledgedDelayCritical(unsigned long delay);
    void setAcknowledgedDelayHigh(unsigned long delay);
    void setAcknowledgedDelayMedium(unsigned long delay);
    void setAcknowledgedDelayLow(unsigned long delay);
    
    // Getters for acknowledged delays
    unsigned long getAcknowledgedDelayCritical() const;
    unsigned long getAcknowledgedDelayHigh() const;
    unsigned long getAcknowledgedDelayMedium() const;
    unsigned long getAcknowledgedDelayLow() const;
    
    // Method to apply delays to existing alarms
    void applyAcknowledgedDelaysToAlarms();

    // int getAlarmCount(AlarmPriority priority) const;
    // int getAlarmCount(AlarmStage stage) const;
    // Add these method declarations to TemperatureController.h
    int getAlarmCount(AlarmPriority priority, const String& comparison = "==") const;
    int getAlarmCount(AlarmStage stage, const String& comparison = "==") const;
    int getAlarmCount(AlarmPriority priority, AlarmStage stage, const String& priorityComparison = "==", const String& stageComparison = "==") const;






private:
    // Hardware components
    IndicatorInterface& indicator;
    OneWire* oneWireBuses[4];
    DallasTemperature* dallasSensors[4];
    
    // Measurement points and sensors
    MeasurementPoint dsPoints[50];
    MeasurementPoint ptPoints[10];
    std::vector<Sensor*> sensors;
    
    // System configuration
    RegisterMap registerMap;
    uint16_t measurementPeriodSeconds;
    uint16_t deviceId;
    uint16_t firmwareVersion;
    unsigned long lastMeasurementTime;
    bool systemInitialized;
    uint8_t oneWireBusPin[4];
    uint8_t chipSelectPin[4];
    
    // Alarm system
    //std::vector<Alarm*> _alarms;
    std::vector<Alarm*> _configuredAlarms; 
    unsigned long _lastAlarmCheck;
    const unsigned long _alarmCheckInterval = 1000; // Check every second
    bool _lastButtonState;
    unsigned long _lastButtonPressTime;
    const unsigned long _buttonDebounceDelay = 200;
    
    // Display management
    Alarm* _currentDisplayedAlarm;
    unsigned long _okDisplayStartTime;
    bool _showingOK;
    
    // Internal methods
    bool isDS18B20Address(uint8_t address) const { return address < 50; }
    bool isPT1000Address(uint8_t address) const { return address >= 50 && address < 60; }
    
    // Alarm helper methods
    void _checkPointForAlarms(MeasurementPoint* point);
    bool _hasAlarmForPoint(MeasurementPoint* point, AlarmType type);
    void _checkButtonPress();
    void _updateNormalDisplay();
    void _showOKAndTurnOffOLED();

    unsigned long _acknowledgedDelayCritical;
    unsigned long _acknowledgedDelayHigh;
    unsigned long _acknowledgedDelayMedium;
    unsigned long _acknowledgedDelayLow;

    bool _relay1State = false;
    bool _relay2State = false;
    bool _redLedState = false;
    bool _yellowLedState = false;
    bool _blueLedState = false;

    bool _comparePriority(AlarmPriority alarmPriority, AlarmPriority targetPriority, const String& comparison) const;
    bool _compareStage(AlarmStage alarmStage, AlarmStage targetStage, const String& comparison) const;

    // Blinking control for low priority alarms
    bool _lowPriorityBlinkState = false;
    unsigned long _lastLowPriorityBlinkTime = 0;
    const unsigned long _blinkOnTime = 2000;   // 2 seconds on
    const unsigned long _blinkOffTime = 30000; // 30 seconds off
    void _handleLowPriorityBlinking();


    // Display management for alarms
    std::vector<Alarm*> _activeAlarmsQueue;
    std::vector<Alarm*> _acknowledgedAlarmsQueue;
    int _currentActiveAlarmIndex;
    int _currentAcknowledgedAlarmIndex;
    unsigned long _lastAlarmDisplayTime;
    unsigned long _acknowledgedAlarmDisplayDelay;
    bool _displayingActiveAlarm;
    
    // Helper methods for alarm display
    void _updateAlarmQueues();
    void _displayNextActiveAlarm();
    void _displayNextAcknowledgedAlarm();
    void _handleAlarmDisplayRotation();

    String _getPriorityString(AlarmPriority priority) const; 


    String _getAlarmTypeString(AlarmType type) const;
    
    //String _getPriorityString(AlarmPriority priority) const;

    
};

-------- [ Separator ] ------

File Name: include/TimeManager.h
Size: 2.88 KB
Code:
#pragma once

#include <Arduino.h>
#include <WiFi.h>
#include <Wire.h>
#include <RTClib.h>
#include <NTPClient.h>
#include <WiFiUdp.h>
#include <ArduinoJson.h>

class TimeManager {
public:
    // Constructor
    TimeManager(int sdaPin = 21, int sclPin = 22);
    
    // Destructor
    ~TimeManager();
    
    // Initialization
    bool begin();
    bool init();
    
    // Time setting methods
    bool setTimeFromNTP(const char* ntpServer = "pool.ntp.org");
    bool setTime(int year, int month, int day, int hour, int minute, int second);
    bool setTime(DateTime dateTime);
    bool setTimeFromUnix(uint32_t unixTime);
    bool setTimeFromCompileTime();
    
    // Time getting methods
    DateTime getCurrentTime();
    String getFormattedTime(const String& format = "YYYY-MM-DD hh:mm:ss");
    String getTimeString();
    String getDateString();
    uint32_t getUnixTime();
    
    // Timezone management
    void setTimezone(int offsetHours, int offsetMinutes = 0);
    void setTimezoneOffset(long offsetSeconds);
    int getTimezoneHours();
    int getTimezoneMinutes();
    long getTimezoneOffset();
    
    // WiFi and NTP configuration
    void setNTPServer(const String& server);
    void setNTPUpdateInterval(unsigned long intervalMs);
    String getNTPServer();
    
    // Update methods (call in loop)
    void update();
    bool syncWithNTP();
    bool isNTPSyncEnabled();
    void enableNTPSync(bool enable);
    
    // Status methods
    bool isRTCConnected();
    bool isTimeSet();
    bool hasLostPower();
    unsigned long getLastNTPSync();
    float getTemperature(); // From DS3231 built-in sensor
    
    // Alarm functionality
    bool setAlarm1(DateTime alarmTime, Ds3231Alarm1Mode mode = DS3231_A1_Hour);
    bool setAlarm2(DateTime alarmTime, Ds3231Alarm2Mode mode = DS3231_A2_Hour);
    bool clearAlarm1();
    bool clearAlarm2();
    bool isAlarm1Triggered();
    bool isAlarm2Triggered();
    
    // Square wave output
    void enableSquareWave(Ds3231SqwPinMode mode = DS3231_SquareWave1Hz);
    void disableSquareWave();
    
    // JSON output for web interface
    String getTimeJSON();
    String getStatusJSON();
    
    // Configuration save/load
    void saveConfig();
    void loadConfig();

private:
    // Hardware
    RTC_DS3231 _rtc;
    WiFiUDP _ntpUDP;
    NTPClient* _timeClient;
    
    // Configuration
    int _sdaPin;
    int _sclPin;
    long _timezoneOffset;  // Offset in seconds
    String _ntpServer;
    unsigned long _ntpUpdateInterval;
    bool _ntpSyncEnabled;
    
    // Status tracking
    bool _rtcConnected;
    bool _timeSet;
    unsigned long _lastNTPSync;
    unsigned long _lastNTPAttempt;
    
    // Internal methods
    void _initializeNTP();
    bool _isWiFiConnected();
    void _updateFromNTP();
    DateTime _applyTimezone(DateTime utcTime);
    DateTime _removeTimezone(DateTime localTime);
    String _formatDateTime(DateTime dt, const String& format);
};

-------- [ Separator ] ------

File Name: platformio.ini
Size: 1.02 KB
Code:
[env:esp-wrover-kit]
platform = espressif32
board = esp-wrover-kit
framework = arduino
monitor_speed = 115200
build_flags = 
    -DBOARD_HAS_PSRAM -mfix-esp32-psram-cache-issue
    -DCA_USE_LITTLEFS       ; Use littlefs remove for spiffs
    -DLOGGER_LOG_LEVEL=3
    -DCA_USE_WIFISCAN=1
    -DCA_USE_TESTWIFI=1
board_build.partitions = huge_app.csv
board_build.filesystem = littlefs
lib_ldf_mode = chain+
lib_deps = 
    adafruit/Adafruit MAX31865 library
    Wire
    WiFi
    OneWire
    https://github.com/me-no-dev/ESPAsyncWebServer.git#master
    me-no-dev/AsyncTCP
    bblanchon/ArduinoJson
    paulstoffregen/OneWire
    milesburton/DallasTemperature
    ModbusClient=https://github.com/eModbus/eModbus.git
    #https://github.com/s00500/ESPUI.git#fix_littlefs_esp32
    # Replace WebConfig with ConfigAssist
    https://github.com/gemi254/ConfigAssist.git
    robtillaart/PCF8575
    olikraus/U8g2
    https://github.com/michalmonday/CSV-Parser-for-Arduino
    adafruit/RTClib
    arduino-libraries/NTPClient

extra_scripts = download_fs.py
-------- [ Separator ] ------

File Name: src/Alarm.cpp
Size: 24.84 KB
Code:
#include "Alarm.h"
#include "LoggerManager.h" 

// Alarm::Alarm(AlarmType type, MeasurementPoint* source, AlarmPriority priority)
//     : _type(type), _stage(AlarmStage::NEW), _priority(priority), _source(source),
//       _timestamp(millis()), _acknowledgedTime(0), _clearedTime(0),
//       _acknowledgedDelay(10 * 60 * 1000), // Default 10 minutes 
//       _delayTime(5 * 60 * 1000), _enabled(true), _hysteresis(1) // Add _hysteresis(1) - 1 degree default
// {
//     if (_source) {
//         _configKey = "alarm_" + String(_source->getAddress()) + "_" + String(static_cast<int>(_type));
//     }

//     _updateMessage();
    
//     Serial.printf("New alarm created: %s for point %d (%s)\n", 
//                   getTypeString().c_str(), 
//                   _source ? _source->getAddress() : -1,
//                   _source ? _source->getName().c_str() : "Unknown");
// }

Alarm::Alarm(AlarmType type, MeasurementPoint* source, AlarmPriority priority)
    : _type(type), _stage(AlarmStage::NEW), _priority(priority), _source(source),
      _timestamp(millis()), _acknowledgedTime(0), _clearedTime(0),
      _acknowledgedDelay(10 * 60 * 1000), _delayTime(5 * 60 * 1000), 
      _enabled(true), _hysteresis(1)
{
    if (_source) {
        _configKey = "alarm_" + String(_source->getAddress()) + "_" + String(static_cast<int>(_type));
    }

    _updateMessage();
    
    // LOG: Alarm creation
    String source_ = "ALARM_" + String(_source ? _source->getAddress() : -1);
    String description = "New alarm created: " + getTypeString() + 
                        " for point " + String(_source ? _source->getAddress() : -1) + 
                        " (" + (_source ? _source->getName() : "Unknown") + ")";
    LoggerManager::info(source_, description);
    
    Serial.printf("New alarm created: %s for point %d (%s)\n", 
                  getTypeString().c_str(), 
                  _source ? _source->getAddress() : -1,
                  _source ? _source->getName().c_str() : "Unknown");
}




// Alarm::~Alarm() {
//     Serial.printf("Alarm destroyed: %s for point %d\n", 
//                   getTypeString().c_str(), 
//                   _source ? _source->getAddress() : -1);
// }

Alarm::~Alarm() {
    // LOG: Alarm destruction
    String source_ = "ALARM_" + String(_source ? _source->getAddress() : -1);
    String description = "Alarm destroyed: " + getTypeString() + 
                        " for point " + String(_source ? _source->getAddress() : -1);
    LoggerManager::info(source_, description);
    
    Serial.printf("Alarm destroyed: %s for point %d\n", 
                  getTypeString().c_str(), 
                  _source ? _source->getAddress() : -1);
}


void Alarm::acknowledge() {
    if (_stage == AlarmStage::NEW || _stage == AlarmStage::ACTIVE) {
        String oldStage = getStageString();
        _stage = AlarmStage::ACKNOWLEDGED;
        _acknowledgedTime = millis();
        _updateMessage();
        
        // LOG: Manual acknowledgment
        String source_ = "ALARM_" + String(_source ? _source->getAddress() : -1);
        String description = "Alarm acknowledged: " + getTypeString() + 
                            " for point " + String(_source ? _source->getAddress() : -1) + 
                            " (" + (_source ? _source->getName() : "Unknown") + ")";
        LoggerManager::info(source_, description);
        
        // LOG: Alarm state change
        if (_source) {
            int16_t currentTemp = _source->getCurrentTemp();
            int16_t threshold = (_type == AlarmType::HIGH_TEMPERATURE) ? 
                               _source->getHighAlarmThreshold() : _source->getLowAlarmThreshold();
            
            LoggerManager::logAlarmStateChange(_source->getAddress(), _source->getName(),
                                             getTypeString(), _getPriorityString(),
                                             oldStage, "ACKNOWLEDGED", currentTemp, threshold);
        }
        
        Serial.printf("Alarm acknowledged: %s for point %d\n", 
                      getTypeString().c_str(), 
                      _source ? _source->getAddress() : -1);
    }
}



void Alarm::clear() {
    if (_stage == AlarmStage::ACTIVE || _stage == AlarmStage::ACKNOWLEDGED) {
        _stage = AlarmStage::CLEARED;
        _clearedTime = millis();
        _updateMessage();
        
        // LOG: Alarm cleared
        String source_ = "ALARM_" + String(_source ? _source->getAddress() : -1);
        String description = "Alarm cleared: " + getTypeString() + 
                            " for point " + String(_source ? _source->getAddress() : -1) + 
                            " (" + (_source ? _source->getName() : "Unknown") + ")";
        LoggerManager::info(source_, description);
        
        Serial.printf("Alarm cleared: %s for point %d\n", 
                      getTypeString().c_str(), 
                      _source ? _source->getAddress() : -1);
    }
}

void Alarm::resolve() {
    _stage = AlarmStage::RESOLVED;
    _updateMessage();
    
    // LOG: Alarm resolved
    String source_ = "ALARM_" + String(_source ? _source->getAddress() : -1);
    String description = "Alarm resolved: " + getTypeString() + 
                        " for point " + String(_source ? _source->getAddress() : -1) + 
                        " (" + (_source ? _source->getName() : "Unknown") + ")";
    LoggerManager::info(source_, description);
    
    Serial.printf("Alarm resolved: %s for point %d\n", 
                  getTypeString().c_str(), 
                  _source ? _source->getAddress() : -1);
}


void Alarm::reactivate() {
    if (_stage == AlarmStage::CLEARED) {
        _stage = _acknowledgedTime > 0 ? AlarmStage::ACKNOWLEDGED : AlarmStage::ACTIVE;
        _clearedTime = 0;
        _updateMessage();
        
        // LOG: Alarm reactivated
        String source_ = "ALARM_" + String(_source ? _source->getAddress() : -1);
        String description = "Alarm reactivated: " + getTypeString() + 
                            " for point " + String(_source ? _source->getAddress() : -1) + 
                            " (" + (_source ? _source->getName() : "Unknown") + ")";
        LoggerManager::warning(source_, description);
        
        Serial.printf("Alarm reactivated: %s for point %d\n", 
                      getTypeString().c_str(), 
                      _source ? _source->getAddress() : -1);
    }
}

bool Alarm::_checkCondition() {
    if (!_source) {
        Serial.println("Alarm: No source point");
        return false;
    }
    
    int16_t currentTemp = _source->getCurrentTemp();
    bool condition = false;
    
    switch (_type) {
        case AlarmType::HIGH_TEMPERATURE:
            {
                int16_t threshold = _source->getHighAlarmThreshold();
                if (_stage == AlarmStage::CLEARED || _stage == AlarmStage::RESOLVED) {
                    // When cleared/resolved, need temperature to drop below (threshold - hysteresis) to stay cleared
                    // Return true if still above (threshold - hysteresis) = condition still exists
                    condition = currentTemp > (threshold - _hysteresis);
                } else {
                    // Normal activation check: activate when >= threshold
                    condition = currentTemp >= threshold;
                }
                Serial.printf("HIGH_TEMP check: Point %d, Temp=%d, Threshold=%d, Hysteresis=%d, Stage=%s, Condition=%s\n",
                             _source->getAddress(), currentTemp, threshold, _hysteresis,
                             getStageString().c_str(), condition ? "TRUE" : "FALSE");
            }
            break;
            
        case AlarmType::LOW_TEMPERATURE:
            {
                int16_t threshold = _source->getLowAlarmThreshold();
                if (_stage == AlarmStage::CLEARED || _stage == AlarmStage::RESOLVED) {
                    // When cleared/resolved, need temperature to rise above (threshold + hysteresis) to stay cleared
                    // Return true if still below (threshold + hysteresis) = condition still exists
                    condition = currentTemp < (threshold + _hysteresis);
                } else {
                    // Normal activation check: activate when <= threshold
                    condition = currentTemp <= threshold;
                }
                Serial.printf("LOW_TEMP check: Point %d, Temp=%d, Threshold=%d, Hysteresis=%d, Stage=%s, Condition=%s\n",
                             _source->getAddress(), currentTemp, threshold, _hysteresis,
                             getStageString().c_str(), condition ? "TRUE" : "FALSE");
            }
            break;
            
        case AlarmType::SENSOR_ERROR:
            condition = _source->getErrorStatus() != 0;
            Serial.printf("SENSOR_ERROR check: Point %d, Error=%d, Condition=%s\n",
                         _source->getAddress(), _source->getErrorStatus(), 
                         condition ? "TRUE" : "FALSE");
            break;
            
        case AlarmType::SENSOR_DISCONNECTED:
            condition = _source->getBoundSensor() == nullptr;
            Serial.printf("DISCONNECTED check: Point %d, Sensor=%p, Condition=%s\n",
                         _source->getAddress(), _source->getBoundSensor(), 
                         condition ? "TRUE" : "FALSE");
            break;
            
        default:
            Serial.println("Unknown alarm type");
            return false;
    }
    
    return condition;
}




// bool Alarm::_checkCondition() {
//     if (!_source) {
//         Serial.println("Alarm: No source point");
//         return false;
//     }
//     const int HYSTERESIS = 2; // 1 degree hysteresis
    
//     bool condition = false;
    
//     switch (_type) {
//         // case AlarmType::HIGH_TEMPERATURE:
//         //     condition = _source->getCurrentTemp() >= _source->getHighAlarmThreshold();
//         //     Serial.printf("HIGH_TEMP check: Point %d, Temp=%d, Threshold=%d, Condition=%s\n",
//         //                  _source->getAddress(), _source->getCurrentTemp(), 
//         //                  _source->getHighAlarmThreshold(), condition ? "TRUE" : "FALSE");
//         //     break;
            
//         // case AlarmType::LOW_TEMPERATURE:
//         //     condition = _source->getCurrentTemp() <= _source->getLowAlarmThreshold();
//         //     Serial.printf("LOW_TEMP check: Point %d, Temp=%d, Threshold=%d, Condition=%s\n",
//         //                  _source->getAddress(), _source->getCurrentTemp(), 
//         //                  _source->getLowAlarmThreshold(), condition ? "TRUE" : "FALSE");
//         //     break;
        

//         case AlarmType::HIGH_TEMPERATURE:
//             if (_stage == AlarmStage::CLEARED) {
//                 // When cleared, need temperature to go below threshold - hysteresis
//                 return _source->getCurrentTemp() >= (_source->getHighAlarmThreshold() - HYSTERESIS);
//             } else {
//                 // Normal check
//                 return _source->getCurrentTemp() >= _source->getHighAlarmThreshold();
//             }
            
//         case AlarmType::LOW_TEMPERATURE:
//             if (_stage == AlarmStage::CLEARED) {
//                 // When cleared, need temperature to go above threshold + hysteresis
//                 return _source->getCurrentTemp() <= (_source->getLowAlarmThreshold() + HYSTERESIS);
//             } else {
//                 // Normal check
//                 return _source->getCurrentTemp() <= _source->getLowAlarmThreshold();
//             }
            
//         case AlarmType::SENSOR_ERROR:
//             condition = _source->getErrorStatus() != 0;
//             Serial.printf("SENSOR_ERROR check: Point %d, Error=%d, Condition=%s\n",
//                          _source->getAddress(), _source->getErrorStatus(), 
//                          condition ? "TRUE" : "FALSE");
//             break;
            
//         case AlarmType::SENSOR_DISCONNECTED:
//             condition = _source->getBoundSensor() == nullptr;
//             Serial.printf("DISCONNECTED check: Point %d, Sensor=%p, Condition=%s\n",
//                          _source->getAddress(), _source->getBoundSensor(), 
//                          condition ? "TRUE" : "FALSE");
//             break;
            
//         default:
//             Serial.println("Unknown alarm type");
//             return false;
//     }
    
//     return condition;
// }



bool Alarm::isDelayElapsed() const {
    if (_stage != AlarmStage::CLEARED || _clearedTime == 0) {
        return false;
    }
    return (millis() - _clearedTime) >= _delayTime;
}

String Alarm::getDisplayText() const {
    if (!_source) return "Unknown Alarm";
    
    String text = String(_source->getAddress()) + "." + _source->getName();
    text += "\n";
    
    switch (_type) {
        case AlarmType::HIGH_TEMPERATURE:
            text += "H: " + String(_source->getCurrentTemp()) + "°C";
            break;
        case AlarmType::LOW_TEMPERATURE:
            text += "L: " + String(_source->getCurrentTemp()) + "°C";
            break;
        case AlarmType::SENSOR_ERROR:
            text += "E: " + String(_source->getErrorStatus());
            break;
        case AlarmType::SENSOR_DISCONNECTED:
            text += "DISCONNECTED";
            break;
    }
    
    if (_stage == AlarmStage::ACKNOWLEDGED) {
        text += " ACK";
    }
    
    return text;
}

String Alarm::getStatusText() const {
    String status = getTypeString() + " - " + getStageString();
    if (_source) {
        status += " (Point " + String(_source->getAddress()) + ")";
    }
    return status;
}

void Alarm::_updateMessage() {
    _message = getDisplayText();
}

String Alarm::getTypeString() const {
    switch (_type) {
        case AlarmType::HIGH_TEMPERATURE: return "HIGH_TEMP";
        case AlarmType::LOW_TEMPERATURE: return "LOW_TEMP";
        case AlarmType::SENSOR_ERROR: return "SENSOR_ERROR";
        case AlarmType::SENSOR_DISCONNECTED: return "DISCONNECTED";
        default: return "UNKNOWN";
    }
}

String Alarm::getStageString() const {
    switch (_stage) {
        case AlarmStage::NEW: return "NEW";
        case AlarmStage::ACTIVE: return "ACTIVE";
        case AlarmStage::ACKNOWLEDGED: return "ACKNOWLEDGED";
        case AlarmStage::CLEARED: return "CLEARED";
        case AlarmStage::RESOLVED: return "RESOLVED";
        default: return "UNKNOWN";
    }
}

String Alarm::_getPriorityString() const {
    switch (_priority) {
        case AlarmPriority::PRIORITY_LOW: return "LOW";
        case AlarmPriority::PRIORITY_MEDIUM: return "MEDIUM";
        case AlarmPriority::PRIORITY_HIGH: return "HIGH";
        case AlarmPriority::PRIORITY_CRITICAL: return "CRITICAL";
        default: return "UNKNOWN";
    }
}

bool Alarm::operator<(const Alarm& other) const {
    // Sort by priority first (higher priority first), then by timestamp (older first)
    if (_priority != other._priority) {
        return static_cast<int>(_priority) > static_cast<int>(other._priority);
    }
    return _timestamp < other._timestamp;
}

bool Alarm::operator==(const Alarm& other) const {
    return _type == other._type && 
           _source == other._source && 
           _timestamp == other._timestamp;
}



String Alarm::getConfigKey() const {
    return _configKey;
}

void Alarm::setConfigKey(const String& key) {
    _configKey = key;
}

void Alarm::setPriority(AlarmPriority priority) {
    if (_priority != priority) {
        AlarmPriority oldPriority = _priority;
        _priority = priority;
        
        // LOG: Priority change
        String source_ = "CONFIG_" + String(_source ? _source->getAddress() : -1);
        String description = "Alarm priority changed from " + _getPriorityString(oldPriority) + 
                            " to " + _getPriorityString(priority) + 
                            " for " + getTypeString() + " alarm";
        LoggerManager::info(source_, description);
    }
}

void Alarm::setHysteresis(int16_t hysteresis) {
    if (_hysteresis != hysteresis) {
        int16_t oldHysteresis = _hysteresis;
        _hysteresis = hysteresis;
        
        // LOG: Hysteresis change
        String source_ = "CONFIG_" + String(_source ? _source->getAddress() : -1);
        String description = "Alarm hysteresis changed from " + String(oldHysteresis) + 
                            " to " + String(hysteresis) + 
                            " for " + getTypeString() + " alarm";
        LoggerManager::info(source_, description);
    }
}

void Alarm::setEnabled(bool enabled) {
    if (_enabled != enabled) {
        _enabled = enabled;
        
        // LOG: Enable/disable change
        String source_ = "CONFIG_" + String(_source ? _source->getAddress() : -1);
        String description = getTypeString() + " alarm " + (enabled ? "enabled" : "disabled");
        LoggerManager::info(source_, description);
    }
}



void Alarm::setStage(AlarmStage stage){
    _stage = stage;
};

// Modify the updateCondition method to handle acknowledged timeout
bool Alarm::updateCondition() {
    if (!_source) {
        Serial.println("Alarm updateCondition: No source");
        return true;
    }
    
    bool conditionExists = _checkCondition();
    AlarmStage oldStage = _stage;
    
    Serial.printf("Alarm update: Point %d, Type=%s, Stage=%s, Condition=%s\n",
                  _source->getAddress(), getTypeString().c_str(), 
                  getStageString().c_str(), conditionExists ? "EXISTS" : "CLEARED");
    
    String source_ = "ALARM_" + String(_source->getAddress());
    String baseDescription = getTypeString() + " alarm for point " + 
                            String(_source->getAddress()) + " (" + _source->getName() + ")";
    
    // Get current temperature and threshold for logging
    int16_t currentTemp = _source->getCurrentTemp();
    int16_t threshold = 0;
    
    switch (_type) {
        case AlarmType::HIGH_TEMPERATURE:
            threshold = _source->getHighAlarmThreshold();
            break;
        case AlarmType::LOW_TEMPERATURE:
            threshold = _source->getLowAlarmThreshold();
            break;
        case AlarmType::SENSOR_ERROR:
        case AlarmType::SENSOR_DISCONNECTED:
            threshold = 0; // Not applicable for these alarm types
            break;
    }
    
    switch (_stage) {
        case AlarmStage::NEW:
            if (conditionExists) {
                _stage = AlarmStage::ACTIVE;
                
                // LOG: NEW -> ACTIVE
                LoggerManager::error(source_, baseDescription + " activated");
                LoggerManager::logAlarmStateChange(_source->getAddress(), _source->getName(),
                                                 getTypeString(), _getPriorityString(),
                                                 "NEW", "ACTIVE", currentTemp, threshold);
                
                Serial.printf("Alarm %s: NEW -> ACTIVE\n", getTypeString().c_str());
            } else {
                resolve();
                
                // LOG: NEW -> RESOLVED
                LoggerManager::info(source_, baseDescription + " resolved before activation");
                LoggerManager::logAlarmStateChange(_source->getAddress(), _source->getName(),
                                                 getTypeString(), _getPriorityString(),
                                                 "NEW", "RESOLVED", currentTemp, threshold);
                
                Serial.printf("Alarm %s: NEW -> RESOLVED (condition cleared)\n", getTypeString().c_str());
            }
            break;
            
        case AlarmStage::ACTIVE:
            if (!conditionExists) {
                clear();
                
                // LOG: ACTIVE -> CLEARED
                LoggerManager::info(source_, baseDescription + " condition cleared");
                LoggerManager::logAlarmStateChange(_source->getAddress(), _source->getName(),
                                                 getTypeString(), _getPriorityString(),
                                                 "ACTIVE", "CLEARED", currentTemp, threshold);
                
                Serial.printf("Alarm %s: ACTIVE -> CLEARED (condition no longer exists)\n", getTypeString().c_str());
            }
            break;
            
        case AlarmStage::ACKNOWLEDGED:
            if (!conditionExists) {
                clear();
                
                // LOG: ACKNOWLEDGED -> CLEARED
                LoggerManager::info(source_, baseDescription + " condition cleared while acknowledged");
                LoggerManager::logAlarmStateChange(_source->getAddress(), _source->getName(),
                                                 getTypeString(), _getPriorityString(),
                                                 "ACKNOWLEDGED", "CLEARED", currentTemp, threshold);
                
                Serial.printf("Alarm %s: ACKNOWLEDGED -> CLEARED (condition no longer exists)\n", getTypeString().c_str());
            } else if (isAcknowledgedDelayElapsed()) {
                _stage = AlarmStage::ACTIVE;
                
                // LOG: ACKNOWLEDGED -> ACTIVE (timeout)
                LoggerManager::warning(source_, baseDescription + " acknowledgment timeout - returned to active");
                LoggerManager::logAlarmStateChange(_source->getAddress(), _source->getName(),
                                                 getTypeString(), _getPriorityString(),
                                                 "ACKNOWLEDGED", "ACTIVE", currentTemp, threshold);
                
                Serial.printf("Alarm %s: ACKNOWLEDGED -> ACTIVE (acknowledged delay elapsed)\n", getTypeString().c_str());
            }
            break;
            
        case AlarmStage::CLEARED:
            if (conditionExists) {
                _stage = AlarmStage::ACTIVE;
                _clearedTime = 0;
                
                // LOG: CLEARED -> ACTIVE (condition returned)
                LoggerManager::warning(source_, baseDescription + " condition returned");
                LoggerManager::logAlarmStateChange(_source->getAddress(), _source->getName(),
                                                 getTypeString(), _getPriorityString(),
                                                 "CLEARED", "ACTIVE", currentTemp, threshold);
                
                Serial.printf("Alarm %s: CLEARED -> ACTIVE (condition returned)\n", getTypeString().c_str());
            } else if (isDelayElapsed()) {
                resolve();
                
                // LOG: CLEARED -> RESOLVED (delay elapsed)
                LoggerManager::info(source_, baseDescription + " auto-resolved after delay");
                LoggerManager::logAlarmStateChange(_source->getAddress(), _source->getName(),
                                                 getTypeString(), _getPriorityString(),
                                                 "CLEARED", "RESOLVED", currentTemp, threshold);
                
                Serial.printf("Alarm %s: CLEARED -> RESOLVED (delay elapsed)\n", getTypeString().c_str());
            }
            break;
        
        case AlarmStage::RESOLVED:
            if (conditionExists) {
                _stage = AlarmStage::ACTIVE;
                _timestamp = millis();
                _acknowledgedTime = 0;
                _clearedTime = 0;
                
                // LOG: RESOLVED -> ACTIVE (condition returned)
                LoggerManager::error(source_, baseDescription + " reoccurred after resolution");
                LoggerManager::logAlarmStateChange(_source->getAddress(), _source->getName(),
                                                 getTypeString(), _getPriorityString(),
                                                 "RESOLVED", "ACTIVE", currentTemp, threshold);
                
                Serial.printf("Alarm %s: RESOLVED -> ACTIVE (condition returned)\n", getTypeString().c_str());
            }
            break;
    }
    
    if (oldStage != _stage) {
        _updateMessage();
    }
    
    return true;
}


// Add these new methods to Alarm.cpp
void Alarm::setAcknowledgedDelay(unsigned long delay) {
    _acknowledgedDelay = delay;
}

unsigned long Alarm::getAcknowledgedDelay() const {
    return _acknowledgedDelay;
}

bool Alarm::isAcknowledgedDelayElapsed() const {
    if (_stage != AlarmStage::ACKNOWLEDGED || _acknowledgedTime == 0) {
        return false;
    }
    return (millis() - _acknowledgedTime) >= _acknowledgedDelay;
}

unsigned long Alarm::getAcknowledgedTimeLeft() const {
    if (_stage != AlarmStage::ACKNOWLEDGED || _acknowledgedTime == 0) {
        return 0; // No time left if not acknowledged
    }
    
    unsigned long elapsed = millis() - _acknowledgedTime;
    if (elapsed >= _acknowledgedDelay) {
        return 0; // Time already elapsed
    }
    
    return _acknowledgedDelay - elapsed; // Time remaining in milliseconds
}


String Alarm::_getPriorityString(AlarmPriority priority) const {
    switch (priority) {
        case AlarmPriority::PRIORITY_LOW: return "LOW";
        case AlarmPriority::PRIORITY_MEDIUM: return "MEDIUM";
        case AlarmPriority::PRIORITY_HIGH: return "HIGH";
        case AlarmPriority::PRIORITY_CRITICAL: return "CRITICAL";
        default: return "UNKNOWN";
    }
}

-------- [ Separator ] ------

File Name: src/CSVConfigManager.cpp
Size: 12.31 KB
Code:
#include "CSVConfigManager.h"
#include <LittleFS.h>

CSVConfigManager::CSVConfigManager(TemperatureController& controller) 
    : _controller(controller), _lastError("") {
}

String CSVConfigManager::exportPointsWithAlarmsToCSV() {
    // Create header with bus number instead of chip select
    String csv = "PointAddress,PointName,PointType,CurrentTemp,MinTemp,MaxTemp,";
    csv += "LowTempThreshold,HighTempThreshold,SensorROM,SensorBusNumber,";
    csv += "HIGH_TEMPERATURE,LOW_TEMPERATURE,SENSOR_ERROR,SENSOR_DISCONNECTED\n";
    
    // Add sample line with point -1 showing all possible priorities
    csv += "-1,SAMPLE_POINT,SAMPLE,0,0,0,0,0,,";
    csv += ",CRITICAL,HIGH,MEDIUM,LOW\n";
    
    // Export DS18B20 points (0-49)
    for (int i = 0; i < 50; i++) {
        MeasurementPoint* point = _controller.getDS18B20Point(i);
        if (point) {
            _exportPointToCSV(csv, point, "DS18B20");
        }
    }
    
    // Export PT1000 points (50-59)
    for (int i = 0; i < 10; i++) {
        MeasurementPoint* point = _controller.getPT1000Point(i);
        if (point) {
            _exportPointToCSV(csv, point, "PT1000");
        }
    }
    
    return csv;
}

void CSVConfigManager::_exportPointToCSV(String& csv, MeasurementPoint* point, const String& pointType) {
    if (!point) return;
    
    // Get bound sensor info
    Sensor* sensor = point->getBoundSensor();
    String romString = "";
    String busNumber = "";
    
    if (sensor) {
        if (sensor->getType() == SensorType::DS18B20) {
            romString = sensor->getDS18B20RomString();
        } else if (sensor->getType() == SensorType::PT1000) {
            busNumber = String(_controller.getSensorBus(sensor)); // Changed from ChipSelectPin to BusNumber
        }
    }
    
    // Build the CSV row
    csv += String(point->getAddress()) + ",";
    csv += _escapeCSVField(point->getName()) + ",";
    csv += pointType + ",";
    csv += String(point->getCurrentTemp()) + ",";
    csv += String(point->getMinTemp()) + ",";
    csv += String(point->getMaxTemp()) + ",";
    csv += String(point->getLowAlarmThreshold()) + ",";
    csv += String(point->getHighAlarmThreshold()) + ",";
    csv += _escapeCSVField(romString) + ",";
    csv += busNumber + ","; // Changed variable name
    
    // Add alarm priorities for each type
    csv += _getAlarmPriorityForPoint(point->getAddress(), AlarmType::HIGH_TEMPERATURE) + ",";
    csv += _getAlarmPriorityForPoint(point->getAddress(), AlarmType::LOW_TEMPERATURE) + ",";
    csv += _getAlarmPriorityForPoint(point->getAddress(), AlarmType::SENSOR_ERROR) + ",";
    csv += _getAlarmPriorityForPoint(point->getAddress(), AlarmType::SENSOR_DISCONNECTED) + "\n";
}


bool CSVConfigManager::importPointsWithAlarmsFromCSV(const String& csvData) {
    if (!validatePointsCSV(csvData)) {
        return false;
    }
    
    int lineStart = 0;
    int lineEnd = csvData.indexOf('\n');
    
    // Skip header line
    if (lineEnd == -1) {
        _lastError = "Invalid CSV format";
        return false;
    }
    lineStart = lineEnd + 1;
    
    // Skip sample line (point -1)
    lineEnd = csvData.indexOf('\n', lineStart);
    if (lineEnd == -1) {
        _lastError = "Missing sample line";
        return false;
    }
    lineStart = lineEnd + 1;
    
    // Clear existing alarms
    _controller.clearConfiguredAlarms();
    
    // Parse each data line
    while (lineStart < csvData.length()) {
        lineEnd = csvData.indexOf('\n', lineStart);
        if (lineEnd == -1) lineEnd = csvData.length();
        
        String line = csvData.substring(lineStart, lineEnd);
        line.trim();
        
        if (line.length() > 0) {
            if (!_parseCSVLine(line)) {
                return false;
            }
        }
        
        lineStart = lineEnd + 1;
    }
    
    return true;
}


bool CSVConfigManager::_parseAlarmFromCSV(int pointAddress, const String& alarmType, 
                                         const String& priority, const String& enabled, 
                                         const String& hysteresis) {
    AlarmType type = _parseAlarmType(alarmType);
    AlarmPriority prio = _parsePriority(priority);
    bool isEnabled = (enabled.equalsIgnoreCase("true"));
    int16_t hyst = hysteresis.toInt();
    
    // Add alarm to controller
    if (_controller.addAlarm(type, pointAddress, prio)) {
        // Find the alarm we just added and configure it
        String configKey = "alarm_" + String(pointAddress) + "_" + String(static_cast<int>(type));
        Alarm* alarm = _controller.findAlarm(configKey);
        if (alarm) {
            alarm->setEnabled(isEnabled);
            alarm->setHysteresis(hyst);
            return true;
        }
    }
    
    return false;
}

String CSVConfigManager::_escapeCSVField(const String& field) {
    if (field.indexOf(',') >= 0 || field.indexOf('"') >= 0 || field.indexOf('\n') >= 0) {
        String escaped = "\"";
        for (int i = 0; i < field.length(); i++) {
            if (field.charAt(i) == '"') {
                escaped += "\"\"";
            } else {
                escaped += field.charAt(i);
            }
        }
        escaped += "\"";
        return escaped;
    }
    return field;
}

String CSVConfigManager::_unescapeCSVField(const String& field) {
    if (field.startsWith("\"") && field.endsWith("\"")) {
        String unescaped = field.substring(1, field.length() - 1);
        unescaped.replace("\"\"", "\"");
        return unescaped;
    }
    return field;
}

String CSVConfigManager::_getAlarmTypeString(AlarmType type) {
    switch (type) {
        case AlarmType::HIGH_TEMPERATURE: return "HIGH_TEMP";
        case AlarmType::LOW_TEMPERATURE: return "LOW_TEMP";
        case AlarmType::SENSOR_ERROR: return "SENSOR_ERROR";
        case AlarmType::SENSOR_DISCONNECTED: return "DISCONNECTED";
        default: return "UNKNOWN";
    }
}

AlarmType CSVConfigManager::_parseAlarmType(const String& typeStr) {
    if (typeStr == "HIGH_TEMP") return AlarmType::HIGH_TEMPERATURE;
    if (typeStr == "LOW_TEMP") return AlarmType::LOW_TEMPERATURE;
    if (typeStr == "SENSOR_ERROR") return AlarmType::SENSOR_ERROR;
    if (typeStr == "DISCONNECTED") return AlarmType::SENSOR_DISCONNECTED;
    return AlarmType::HIGH_TEMPERATURE; // Default
}

String CSVConfigManager::_getPriorityString(AlarmPriority priority) {
    switch (priority) {
        case AlarmPriority::PRIORITY_LOW: return "LOW";
        case AlarmPriority::PRIORITY_MEDIUM: return "MEDIUM";
        case AlarmPriority::PRIORITY_HIGH: return "HIGH";
        case AlarmPriority::PRIORITY_CRITICAL: return "CRITICAL";
        default: return "MEDIUM";
    }
}

AlarmPriority CSVConfigManager::_parsePriority(const String& priorityStr) {
    if (priorityStr == "LOW") return AlarmPriority::PRIORITY_LOW;
    if (priorityStr == "MEDIUM") return AlarmPriority::PRIORITY_MEDIUM;
    if (priorityStr == "HIGH") return AlarmPriority::PRIORITY_HIGH;
    if (priorityStr == "CRITICAL") return AlarmPriority::PRIORITY_CRITICAL;
    return AlarmPriority::PRIORITY_MEDIUM; // Default
}

bool CSVConfigManager::validatePointsCSV(const String& csvData) {
    if (csvData.length() == 0) {
        _lastError = "Empty CSV data";
        return false;
    }
    
    // Check for required headers
    String requiredHeaders[] = {
        "PointAddress", "PointName", "PointType", "CurrentTemp", "MinTemp", "MaxTemp",
        "LowTempThreshold", "HighTempThreshold", "SensorROM", "SensorBusNumber", // Changed header
        "HIGH_TEMPERATURE", "LOW_TEMPERATURE", "SENSOR_ERROR", "SENSOR_DISCONNECTED"
    };
    
    int headerLine = csvData.indexOf('\n');
    if (headerLine == -1) {
        _lastError = "No header line found";
        return false;
    }
    
    String header = csvData.substring(0, headerLine);
    for (const String& reqHeader : requiredHeaders) {
        if (header.indexOf(reqHeader) == -1) {
            _lastError = "Missing required header: " + reqHeader;
            return false;
        }
    }
    
    return true;
}



bool CSVConfigManager::saveCSVToFile(const String& filename, const String& csvData) {
    if (!LittleFS.begin()) {
        _lastError = "Failed to mount filesystem";
        return false;
    }
    
    File file = LittleFS.open(filename, "w");
    if (!file) {
        _lastError = "Failed to open file for writing: " + filename;
        return false;
    }
    
    size_t written = file.print(csvData);
    file.close();
    
    if (written != csvData.length()) {
        _lastError = "Failed to write complete data to file";
        return false;
    }
    
    return true;
}

String CSVConfigManager::loadCSVFromFile(const String& filename) {
    if (!LittleFS.begin()) {
        _lastError = "Failed to mount filesystem";
        return "";
    }
    
    File file = LittleFS.open(filename, "r");
    if (!file) {
        _lastError = "Failed to open file for reading: " + filename;
        return "";
    }
    
    String content = file.readString();
    file.close();
    
    return content;
}

// Placeholder implementations for sensor-specific methods
String CSVConfigManager::exportSensorsToCSV() {
    // Implementation for sensor export if needed
    return "";
}

bool CSVConfigManager::importSensorsFromCSV(const String& csvData) {
    // Implementation for sensor import if needed
    return false;
}


bool CSVConfigManager::_parseCSVLine(const String& line) {
    // Simple CSV parsing - split by commas
    int fieldIndex = 0;
    int startPos = 0;
    String fields[14]; // 14 fields in our CSV format
    
    for (int i = 0; i <= line.length(); i++) {
        if (i == line.length() || line.charAt(i) == ',') {
            if (fieldIndex < 14) {
                fields[fieldIndex] = line.substring(startPos, i);
                fields[fieldIndex].trim();
                // Remove quotes if present
                if (fields[fieldIndex].startsWith("\"") && fields[fieldIndex].endsWith("\"")) {
                    fields[fieldIndex] = fields[fieldIndex].substring(1, fields[fieldIndex].length() - 1);
                }
            }
            fieldIndex++;
            startPos = i + 1;
        }
    }
    
    if (fieldIndex < 14) {
        _lastError = "Insufficient fields in CSV line";
        return false;
    }
    
    // Parse fields
    int pointAddress = fields[0].toInt();
    
    // Skip sample line (point -1)
    if (pointAddress == -1) {
        return true;
    }
    
    String pointName = fields[1];
    String pointType = fields[2];
    int16_t lowThreshold = fields[6].toInt();
    int16_t highThreshold = fields[7].toInt();
    String romString = fields[8];
    String busNumberStr = fields[9]; // Changed from chipSelectStr
    
    // Update measurement point
    MeasurementPoint* point = _controller.getMeasurementPoint(pointAddress);
    if (point) {
        point->setName(pointName);
        point->setLowAlarmThreshold(lowThreshold);
        point->setHighAlarmThreshold(highThreshold);
        
        // Bind sensor if specified
        if (!romString.isEmpty()) {
            _controller.bindSensorToPointByRom(romString, pointAddress);
        } else if (!busNumberStr.isEmpty()) {
            int busNumber = busNumberStr.toInt();
            _controller.bindSensorToPointByBusNumber(busNumber, pointAddress); // Changed method name
        }
    }
    
    // Parse alarms for each type (rest remains the same)
    String alarmPriorities[4] = {fields[10], fields[11], fields[12], fields[13]};
    AlarmType alarmTypes[4] = {
        AlarmType::HIGH_TEMPERATURE,
        AlarmType::LOW_TEMPERATURE,
        AlarmType::SENSOR_ERROR,
        AlarmType::SENSOR_DISCONNECTED
    };
    
    for (int i = 0; i < 4; i++) {
        if (!alarmPriorities[i].isEmpty()) {
            AlarmPriority priority = _parsePriority(alarmPriorities[i]);
            if (!_controller.addAlarm(alarmTypes[i], pointAddress, priority)) {
                _lastError = "Failed to add alarm for point " + String(pointAddress);
                return false;
            }
        }
    }
    
    return true;
}


String CSVConfigManager::_getAlarmPriorityForPoint(int pointAddress, AlarmType alarmType) {
    // Find alarm of specific type for this point
    for (int i = 0; i < _controller.getAlarmCount(); i++) {
        Alarm* alarm = _controller.getAlarmByIndex(i);
        if (alarm && alarm->getPointAddress() == pointAddress && alarm->getType() == alarmType) {
            return _getPriorityString(alarm->getPriority());
        }
    }
    return ""; // No alarm of this type for this point
}

-------- [ Separator ] ------

File Name: src/ConfigManager.cpp
Size: 72.10 KB
Code:
#include "ConfigManager.h"
#include <ArduinoJson.h>


ConfigManager* ConfigManager::instance = nullptr;


// YAML configuration definition
const char* VARIABLES_DEF_YAML PROGMEM = R"~(
    Wifi settings:
      - st_ssid:
          label: WiFi SSID
          default: Beeline_2G_F13F37
      - st_pass:
          label: WiFi Password
          default: 1122334455667788
      - host_name:
          label: Device Hostname
          default: 'temp-monitor-{mac}'
    
    Device settings:
      - device_id:
          label: Device ID
          type: number
          min: 1
          max: 9999
          default: 1000
      - firmware_version:
          label: Firmware Version
          default: '1.0'
          readonly: true
      - measurement_period:
          label: Measurement Period (seconds)
          type: number
          min: 1
          max: 3600
          default: 10
    
    Alarm Acknowledged Delays:
      - ack_delay_critical:
          label: Critical Alarm Acknowledged Delay (minutes)
          type: number
          min: 1
          max: 1440
          default: 5
      - ack_delay_high:
          label: High Priority Alarm Acknowledged Delay (minutes)
          type: number
          min: 1
          max: 1440
          default: 10
      - ack_delay_medium:
          label: Medium Priority Alarm Acknowledged Delay (minutes)
          type: number
          min: 1
          max: 1440
          default: 15
      - ack_delay_low:
          label: Low Priority Alarm Acknowledged Delay (minutes)
          type: number
          min: 1
          max: 1440
          default: 30
    
    Modbus settings:
      - modbus_enabled:
          label: Enable Modbus RTU
          checked: true
      - modbus_address:
          label: Modbus Device Address
          type: number
          min: 1
          max: 247
          default: 1
      - modbus_baud_rate:
          label: Baud Rate
          options: '4800', '9600', '19200', '38400', '57600', '115200'
          default: '9600'
    )~";

ConfigManager::ConfigManager(TemperatureController& tempController)
    : conf("/config.ini", VARIABLES_DEF_YAML),
      controller(tempController), 
      csvManager(controller),
      settingsCSVManager(conf),
      portalActive(false) {
    
    instance = this;
    server = new WebServer(80);
    confHelper = new ConfigAssistHelper(conf);
}

ConfigManager::~ConfigManager() {
    if (server) {
        delete server;
    }
    
    if (confHelper) {
        delete confHelper;
    }
}

bool ConfigManager::begin() {
    // Initialize LittleFS
    if (!LittleFS.begin(true)) {
        Serial.println("LittleFS mount failed");
        return false;
    }
    
    // Set callback function for configuration changes
    conf.setRemotUpdateCallback(onConfigChanged);
    
    // IMPORTANT: Register custom routes BEFORE ConfigAssist setup

    if(server) {
        Serial.println("!!!!!!!!!!!!!SERVER STARTED!!!!!!!!!!!!");
    } else {
        Serial.println("!!!!!!!!!!!!!SERVER FAILED!!!!!!!!!!!!");
    }


    basicAPI();
    sensorAPI();
    csvImportExportAPI();
    pointsAPI();
    alarmsAPI();
    logsAPI();
    downloadAPI();
    

    

   




    

    

    
    

    





    


    
    

    


    

 // WiFi setup logging
 bool startAP = true;
 if (conf("st_ssid") != "" && conf("st_pass") != "") {
     LoggerManager::info("CONFIG", "Attempting WiFi connection to: " + String(conf("st_ssid")));
     if (connectWiFi(10000)) {
         startAP = false;
         LoggerManager::info("CONFIG", "WiFi connected successfully - IP: " + WiFi.localIP().toString());
     } else {
         LoggerManager::warning("CONFIG", "WiFi connection failed, starting AP mode");
     }
 } else {
     LoggerManager::info("CONFIG", "No WiFi credentials configured, starting AP mode");
 }
    
    // Setup WiFi
    // bool startAP = true;
    // if (conf("st_ssid") != "" && conf("st_pass") != "") {
    //     // Try to connect to WiFi if credentials are available
    //     if (connectWiFi(10000)) {
    //         startAP = false;
    //     }
    // }
    
    // Setup ConfigAssist with web server AFTER registering custom routes
    conf.setup(*server, startAP);
    
    // Start the web server
    server->begin();
    
    // Load sensor configuration
    //loadSensorConfig();
    loadPointsConfig();
    loadAlarmsConfig();
    Serial.println("CM.begin(): Sensor data loaded:");
    //Serial.println(controller.getSensorsJson());
    
    // Apply configuration to controller
    controller.setDeviceId(getDeviceId());
    LoggerManager::info("CONFIG", "Device ID set to: " + String(getDeviceId()));
    
    controller.setMeasurementPeriod(getMeasurementPeriod());
    LoggerManager::info("CONFIG", "Measurement period set to: " + String(getMeasurementPeriod()) + " seconds");

    // Load acknowledged delays
    controller.setAcknowledgedDelayCritical(getAcknowledgedDelayCritical() * 60 * 1000);
    controller.setAcknowledgedDelayHigh(getAcknowledgedDelayHigh() * 60 * 1000);
    controller.setAcknowledgedDelayMedium(getAcknowledgedDelayMedium() * 60 * 1000);
    controller.setAcknowledgedDelayLow(getAcknowledgedDelayLow() * 60 * 1000);
    LoggerManager::info("CONFIG", "Acknowledged delays configured");
    
    LoggerManager::info("CONFIG", "ConfigManager initialization completed successfully");
    
    return true;
}

void ConfigManager::update() {
    // Handle client requests
    server->handleClient();
}

bool ConfigManager::connectWiFi(int timeoutMs) {
    // Use ConfigAssistHelper to connect to WiFi
    bool connected = confHelper->connectToNetwork(timeoutMs, -1);
    
    if (connected) {
        Serial.print("Connected to WiFi. IP: ");
        Serial.println(WiFi.localIP().toString());
    } else {
        Serial.println("Failed to connect to WiFi");
    }
    
    return connected;
}

// Update the onConfigChanged method in ConfigManager.cpp
void ConfigManager::onConfigChanged(String key) {
    if (instance == nullptr) return;
    
    Serial.print("Config changed: ");
    Serial.print(key);
    Serial.print(" = ");
    Serial.println(instance->conf(key));
    
    if (key == "device_id") {
        instance->controller.setDeviceId(instance->conf(key).toInt());
    } else if (key == "measurement_period") {
        instance->controller.setMeasurementPeriod(instance->conf(key).toInt());
    } else if (key == "reset_min_max") {
        instance->resetMinMaxValues();
    } else if (key == "ack_delay_critical") {
        unsigned long delayMs = instance->conf(key).toInt() * 60 * 1000; // Convert minutes to milliseconds
        instance->controller.setAcknowledgedDelayCritical(delayMs);
        Serial.printf("Set critical acknowledged delay to %lu ms (%d minutes)\n", delayMs, instance->conf(key).toInt());
    } else if (key == "ack_delay_high") {
        unsigned long delayMs = instance->conf(key).toInt() * 60 * 1000;
        instance->controller.setAcknowledgedDelayHigh(delayMs);
        Serial.printf("Set high acknowledged delay to %lu ms (%d minutes)\n", delayMs, instance->conf(key).toInt());
    } else if (key == "ack_delay_medium") {
        unsigned long delayMs = instance->conf(key).toInt() * 60 * 1000;
        instance->controller.setAcknowledgedDelayMedium(delayMs);
        Serial.printf("Set medium acknowledged delay to %lu ms (%d minutes)\n", delayMs, instance->conf(key).toInt());
    } else if (key == "ack_delay_low") {
        unsigned long delayMs = instance->conf(key).toInt() * 60 * 1000;
        instance->controller.setAcknowledgedDelayLow(delayMs);
        Serial.printf("Set low acknowledged delay to %lu ms (%d minutes)\n", delayMs, instance->conf(key).toInt());
    }
}



void ConfigManager::resetMinMaxValues() {
    controller.resetMinMaxValues();
}



// Save all measurement points and their bindings
void ConfigManager::savePointsConfig() {
    LoggerManager::info("CONFIG_SAVE", "Saving points configuration to /points2.ini");
    Serial.println("Save points to config ....");
    ConfigAssist pointsConf("/points2.ini", false);

    // DS18B20 points
    for (uint8_t i = 0; i < 50; ++i) {
        MeasurementPoint* point = controller.getDS18B20Point(i);
        if (!point) continue;
        String key = "ds_" + String(point->getAddress());
        pointsConf[key + "_name"] = point->getName();
        pointsConf[key + "_low_alarm"] = String(point->getLowAlarmThreshold());
        pointsConf[key + "_high_alarm"] = String(point->getHighAlarmThreshold());

        Sensor* bound = point->getBoundSensor();
        if (bound && bound->getType() == SensorType::DS18B20) {
            pointsConf[key + "_sensor_rom"] = bound->getDS18B20RomString();
            pointsConf[key + "_sensor_bus"] = controller.getSensorBus(bound);
        } else {
            pointsConf[key + "_sensor_rom"] = "";
            pointsConf[key + "_sensor_bus"] = "";
        }
    }

    // PT1000 points
    for (uint8_t i = 0; i < 10; ++i) {
        MeasurementPoint* point = controller.getPT1000Point(i);
        if (!point) continue;
        String key = "pt_" + String(point->getAddress());
        pointsConf[key + "_name"] = point->getName();
        pointsConf[key + "_low_alarm"] = String(point->getLowAlarmThreshold());
        pointsConf[key + "_high_alarm"] = String(point->getHighAlarmThreshold());

        Sensor* bound = point->getBoundSensor();
        if (bound && bound->getType() == SensorType::PT1000) {
            pointsConf[key + "_sensor_cs"] = String(bound->getPT1000ChipSelectPin());
        } else {
            pointsConf[key + "_sensor_cs"] = "";
        }
    }
    pointsConf.saveConfigFile();
}

// // Load all measurement points and their bindings
// void ConfigManager::loadPointsConfig() {
//     ConfigAssist pointsConf("/points2.ini", false);

//     // DS18B20 points
//     for (uint8_t i = 0; i < 50; ++i) {
//         String key = "ds_" + String(i);
//         MeasurementPoint* point = controller.getDS18B20Point(i);
//         if (!point) continue;
//         point->setName(pointsConf(key + "_name"));
//         point->setLowAlarmThreshold(pointsConf(key + "_low_alarm").toInt());
//         point->setHighAlarmThreshold(pointsConf(key + "_high_alarm").toInt());
//         String rom = pointsConf(key + "_sensor_rom");
//         if (rom.length() == 16) {
//             Serial.println("ROM from file: " + rom);
//             controller.bindSensorToPointByRom(rom, i);
//         } else {
//             controller.unbindSensorFromPoint(i);
//         }
//     }

//     // PT1000 points
//     for (uint8_t i = 0; i < 10; ++i) {
//         uint8_t address = 50 + i;
//         String key = "pt_" + String(address);
//         MeasurementPoint* point = controller.getPT1000Point(i);
//         if (!point) continue;
//         point->setName(pointsConf(key + "_name"));
//         point->setLowAlarmThreshold(pointsConf(key + "_low_alarm").toInt());
//         point->setHighAlarmThreshold(pointsConf(key + "_high_alarm").toInt());
//         int cs = pointsConf(key + "_sensor_cs").toInt();
//         if (cs > 0) {
//             controller.bindSensorToPointByChipSelect(cs, address);
//         } else {
//             controller.unbindSensorFromPoint(address);
//         }
//     }
// }

void ConfigManager::loadPointsConfig() {
    ConfigAssist pointsConf("/points2.ini", false);
    LoggerManager::info("CONFIG_LOAD", "Loading points configuration from /points2.ini");

    // DS18B20 points
    for (uint8_t i = 0; i < 50; ++i) {
        String key = "ds_" + String(i);
        MeasurementPoint* point = controller.getDS18B20Point(i);
        if (!point) continue;
        point->setName(pointsConf(key + "_name"));
        point->setLowAlarmThreshold(pointsConf(key + "_low_alarm").toInt());
        point->setHighAlarmThreshold(pointsConf(key + "_high_alarm").toInt());
        uint8_t bus = pointsConf(key + "_sensor_bus").toInt();
        String rom = pointsConf(key + "_sensor_rom");
        if (rom.length() == 16) {
            // Ensure the sensor exists and is initialized before binding
            Sensor* sensor = controller.findSensorByRom(rom);
            if (!sensor) {
                uint8_t romArr[8];
                for (int j = 0; j < 8; ++j)
                    romArr[j] = strtol(rom.substring(j*2, j*2+2).c_str(), nullptr, 16);
                String sensorName = "DS18B20_" + rom;
                sensor = new Sensor(SensorType::DS18B20, 0, sensorName);
                sensor->setupDS18B20(controller.getOneWirePin(bus), romArr);
                if (!sensor->initialize()) {
                    //sensor->setErrorStatus(0x01); // Mark as error (not connected)
                }
                controller.addSensor(sensor);
            }
            
            controller.bindSensorToPointByRom(rom, i);
        } else {
            controller.unbindSensorFromPoint(i);
        }
    }

    // PT1000 points
    for (uint8_t i = 0; i < 10; ++i) {
        uint8_t address = 50 + i;
        String key = "pt_" + String(address);
        MeasurementPoint* point = controller.getPT1000Point(i);
        if (!point) continue;
        point->setName(pointsConf(key + "_name"));
        point->setLowAlarmThreshold(pointsConf(key + "_low_alarm").toInt());
        point->setHighAlarmThreshold(pointsConf(key + "_high_alarm").toInt());
        int cs = pointsConf(key + "_sensor_cs").toInt();
        if (cs > 0) {
            // Ensure the sensor exists and is initialized before binding
            Sensor* sensor = controller.findSensorByChipSelect(cs);
            if (!sensor) {
                String sensorName = "PT1000_CS" + String(cs);
                sensor = new Sensor(SensorType::PT1000, 0, sensorName);
                sensor->setupPT1000(cs, i);
                if (!sensor->initialize()) {
                    //sensor->setErrorStatus(0x01); // Mark as error (not connected)
                }
                controller.addSensor(sensor);
            }
            controller.bindSensorToPointByChipSelect(cs, address);
        } else {
            controller.unbindSensorFromPoint(address);
        }
    }
    controller.applyConfigToRegisterMap();
}


// Update a measurement point and its binding in config
bool ConfigManager::updatePointInConfig(uint8_t address, const String& name, int16_t lowAlarm, int16_t highAlarm,
                                        const String& ds18b20RomString, int pt1000ChipSelect) {
    MeasurementPoint* point = controller.getMeasurementPoint(address);
    if (!point) return false;
    point->setName(name);
    point->setLowAlarmThreshold(lowAlarm);
    point->setHighAlarmThreshold(highAlarm);
    if (!ds18b20RomString.isEmpty()) {
        controller.bindSensorToPointByRom(ds18b20RomString, address);
    } else if (pt1000ChipSelect >= 0) {
        controller.bindSensorToPointByChipSelect(pt1000ChipSelect, address);
    } else {
        controller.unbindSensorFromPoint(address);
    }
    savePointsConfig();
    return true;
}


void ConfigManager::saveAlarmsConfig() {
    Serial.println("Save alarms to config....");
    ConfigAssist alarmsConf("/alarms.ini", false);
    
    // Clear existing entries by setting them to empty strings
    // ConfigAssist will treat empty strings as non-existent
    for (int i = 0; i < 1000; i++) { // Check reasonable number of possible alarms
        String alarmKey = "alarm" + String(i);
        if (alarmsConf.exists(alarmKey + "_type")) {
            alarmsConf[alarmKey + "_type"] = "";
            alarmsConf[alarmKey + "_priority"] = "";
            alarmsConf[alarmKey + "_point"] = "";
            alarmsConf[alarmKey + "_enabled"] = "";
        } else {
            break; // No more entries to clear
        }
    }
    
    // Save current alarms
    int alarmIndex = 0;
    for (int i = 0; i < controller.getAlarmCount(); ++i) {
        Alarm* alarm = controller.getAlarmByIndex(i);
        if (!alarm) continue;
        
        String alarmKey = "alarm" + String(alarmIndex++);
        alarmsConf[alarmKey + "_type"] = String(static_cast<int>(alarm->getType()));
        alarmsConf[alarmKey + "_priority"] = String(static_cast<int>(alarm->getPriority()));
        alarmsConf[alarmKey + "_point"] = String(alarm->getPointAddress());
        alarmsConf[alarmKey + "_enabled"] = alarm->isEnabled() ? "1" : "0";
        alarmsConf[alarmKey + "_hysteresis"] = String(alarm->getHysteresis());
    }
    
    alarmsConf.saveConfigFile();
    Serial.printf("Saved %d alarms to config\n", alarmIndex);
}




void ConfigManager::loadAlarmsConfig() {
    Serial.println("Loading alarms configuration...");
    ConfigAssist alarmsConf("/alarms.ini", false);
    
    // Clear existing configured alarms first
    for (auto alarm : controller.getConfiguredAlarms()) {
        delete alarm;
    }
    controller.clearConfiguredAlarms();
    
    int loadedCount = 0;
    int alarmIndex = 0;
    
    // Load alarms sequentially
    while (true) {
        String alarmKey = "alarm" + String(alarmIndex++);
        
        // Check if all required keys exist
        String typeKey = alarmKey + "_type";
        String priorityKey = alarmKey + "_priority";
        String pointKey = alarmKey + "_point";
        String enabledKey = alarmKey + "_enabled";
        int16_t hysteresis = alarmsConf(alarmKey + "_hysteresis").toInt();
        if (hysteresis == 0) hysteresis = 1; // Default to 1 if not set
        
        
        if (!alarmsConf.exists(typeKey)) {
            break; // No more alarms to load
        }
        
        // Get values and validate they're not empty
        String typeStr = alarmsConf(typeKey);
        String priorityStr = alarmsConf(priorityKey);
        String pointStr = alarmsConf(pointKey);
        String enabledStr = alarmsConf(enabledKey);
        
        // Skip empty entries (these were cleared)
        if (typeStr.isEmpty() || priorityStr.isEmpty() || 
            pointStr.isEmpty() || enabledStr.isEmpty()) {
            Serial.printf("Skipping empty alarm entry at index %d\n", alarmIndex - 1);
            continue;
        }
        
        // Convert and validate values
        int type = typeStr.toInt();
        int priority = priorityStr.toInt();
        int pointAddress = pointStr.toInt();
        bool enabled = (enabledStr == "1");
        
        // Validate enum ranges
        if (type < 0 || type > 3 || priority < 0 || priority > 3) {
            Serial.printf("Skipping alarm %d: invalid type (%d) or priority (%d)\n", 
                         alarmIndex - 1, type, priority);
            continue;
        }
        
        // Validate point address
        if (pointAddress < 0 || pointAddress >= 60) {
            Serial.printf("Skipping alarm %d: invalid point address (%d)\n", 
                         alarmIndex - 1, pointAddress);
            continue;
        }
        
        // Create alarm
        bool success = controller.addAlarm(
            static_cast<AlarmType>(type),
            pointAddress,
            static_cast<AlarmPriority>(priority)
        );
        
        if (success) {
            // Set enabled state
            Alarm* alarm = controller.findAlarm("alarm_" + String(pointAddress) + "_" + String(type));
            if (alarm) {
                alarm->setEnabled(enabled);
                alarm->setHysteresis(hysteresis);
                loadedCount++;
                Serial.printf("Loaded alarm: type=%d, priority=%d, point=%d, enabled=%s, hyst=%d\n",
                             type, priority, pointAddress, enabled ? "true" : "false", hysteresis);
            }
        }
    }
    
    Serial.printf("Loaded %d valid alarm configurations\n", loadedCount);
}

void ConfigManager::basicAPI(){

    // Add route for the main page
    server->on("/dashboard.html", HTTP_GET, [this]() {
        if (LittleFS.exists("/dashboard.html")) {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->sendHeader("Cache-Control", "max-age=3600");
            File file = LittleFS.open("/dashboard.html", "r");
            server->streamFile(file, "text/html");
            file.close();
            Serial.println("SERVER: /dashboard.html");
        } else {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->send(200, "text/html", "<html><body><h1>Temperature Monitoring System</h1><p><a href='/cfg'>Configuration</a></p><p><a href='/sensors.html'>Sensors</a></p></body></html>");
        }
    });
    
    // Add route for the sensors page
    server->on("/sensors.html", HTTP_GET, [this]() {
        if (LittleFS.exists("/sensors.html")) {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->sendHeader("Cache-Control", "max-age=3600");
            File file = LittleFS.open("/sensors.html", "r");
            server->streamFile(file, "text/html");
            file.close();
            Serial.println("SERVER: /sensors.html");
        } else {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/plain");
            server->sendHeader("Connection", "close");
            server->send(404, "text/plain", "Sensors page not found");
        }
    });
    server->on("/points.html", HTTP_GET, [this]() {
        if (LittleFS.exists("/points.html")) {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->sendHeader("Cache-Control", "max-age=3600");
            File file = LittleFS.open("/points.html", "r");
            server->streamFile(file, "text/html");
            Serial.println("SERVER: /points.html");
            file.close();
        } else {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/plain");
            server->sendHeader("Connection", "close");
            server->send(404, "text/plain", "Points page not found");
        }
    });




    server->on("/alarms.html", HTTP_GET, [this]() {
        if (LittleFS.exists("/alarms.html")) {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->sendHeader("Cache-Control", "max-age=3600");
            File file = LittleFS.open("/alarms.html", "r");
            server->streamFile(file, "text/html");
            file.close();
            Serial.println("SERVER: /alarms.html");
        } else {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->send(200, "text/html", "<html><body><h1>Temperature Monitoring System</h1><p><a href='/cfg'>Configuration</a></p><p><a href='/sensors.html'>Sensors</a></p></body></html>");
        }
    });

    server->on("/alarm-history.html", HTTP_GET, [this]() {
        if (LittleFS.exists("/alarm-history.html")) {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->sendHeader("Cache-Control", "max-age=3600");
            File file = LittleFS.open("/alarm-history.html", "r");
            server->streamFile(file, "text/html");
            file.close();
            Serial.println("SERVER: /alarm-history.html");
        } else {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->send(200, "text/html", "<html><body><h1>Temperature Monitoring System</h1><p><a href='/cfg'>Configuration</a></p><p><a href='/sensors.html'>Sensors</a></p></body></html>");
        }
    });

    server->on("/event-logs.html", HTTP_GET, [this]() {
        if (LittleFS.exists("/event-logs.html")) {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->sendHeader("Cache-Control", "max-age=3600");
            File file = LittleFS.open("/event-logs.html", "r");
            server->streamFile(file, "text/html");
            Serial.println("SERVER: /event-logs.html");
            file.close();
        } else {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/plain");
            server->sendHeader("Connection", "close");
            server->send(404, "text/plain", "event-logs page not found");
        }
    });

    server->on("/download-logs.html", HTTP_GET, [this]() {
        if (LittleFS.exists("/download-logs.html")) {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/html");
            server->sendHeader("Connection", "close");
            server->sendHeader("Cache-Control", "max-age=3600");
            File file = LittleFS.open("/download-logs.html", "r");
            server->streamFile(file, "text/html");
            Serial.println("SERVER: /download-logs.html");
            file.close();
        } else {
            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/plain");
            server->sendHeader("Connection", "close");
            server->send(404, "text/plain", "download-logs page not found");
        }
    });

    

    // Add CORS support for OPTIONS requests
    server->on("/api/sensors", HTTP_OPTIONS, [this]() {
        server->sendHeader("HTTP/1.1 204 No Content", "");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->sendHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
        server->sendHeader("Access-Control-Allow-Headers", "Content-Type");
        server->send(204);
    });

};
void ConfigManager::sensorAPI(){
    // API endpoints for sensor data
    server->on("/api/sensors", HTTP_GET, [this]() {
        server->sendHeader("HTTP/1.1 200 OK", "");
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Connection", "close");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->sendHeader("Cache-Control", "no-store");
        server->send(200, "application/json", controller.getSensorsJson());
    });
    
    server->on("/api/status", HTTP_GET, [this]() {
        server->sendHeader("HTTP/1.1 200 OK", "");
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Connection", "close");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->sendHeader("Cache-Control", "no-store");
        server->send(200, "application/json", controller.getSystemStatusJson());
    });
    
    server->on("/api/reset-minmax", HTTP_POST, [this]() {
        controller.resetMinMaxValues();
        server->sendHeader("HTTP/1.1 200 OK", "");
        server->sendHeader("Content-Type", "text/plain");
        server->sendHeader("Connection", "close");
        server->send(200, "text/plain", "Min/Max values reset");
    });
    
    // API endpoint for sensor discovery
    server->on("/api/discover", HTTP_POST, [this]() {
        bool discoveredDS = controller.discoverDS18B20Sensors();
        bool discoveredPT = controller.discoverPTSensors();
        bool discovered = discoveredDS || discoveredPT;
        
        if (discovered) {

            server->sendHeader("HTTP/1.1 200 OK", "");
            server->sendHeader("Content-Type", "text/plain");
            server->sendHeader("Connection", "close");
            server->send(200, "text/plain", "Sensors discovered");
        } else {
            server->sendHeader("HTTP/1.1 404 Not Found", "");
            server->sendHeader("Content-Type", "text/plain");
            server->sendHeader("Connection", "close");
            server->send(404, "text/plain", "No sensors found");
        }
    });

    // POST /api/sensor-bind
    server->on("/api/sensor-bind", HTTP_POST, [this]() {
        if (server->hasArg("plain")) {
            DynamicJsonDocument doc(256);
            
            DeserializationError err = deserializeJson(doc, server->arg("plain"));
            
            if (!err) {
                uint8_t pointAddress = doc["pointAddress"];
                if (doc.containsKey("romString")) {
                    Serial.println("ROM:\n" + doc.as<String>());
                    String rom = doc["romString"].as<String>();
                    if (controller.bindSensorToPointByRom(rom, pointAddress)) {
                        //Serial.println("Save points to config ROM\n");
                        savePointsConfig();
                        server->send(200, "text/plain", "Bound");
                        return;
                    }
                } else if (doc.containsKey("chipSelect")) {
                    int cs = doc["chipSelect"];
                    Serial.println("CS:\n" + doc.as<String>());
                    if (controller.bindSensorToPointByChipSelect(cs, pointAddress)) {
                        //Serial.println("Save points to config ROM\n");
                        savePointsConfig();
                        server->send(200, "text/plain", "Bound");
                        return;
                    }
                }
            }
        }
        server->send(400, "text/plain", "Bad Request");
    });

    // POST /api/sensor-unbind
    server->on("/api/sensor-unbind", HTTP_POST, [this]() {
        if (server->hasArg("plain")) {
            DynamicJsonDocument doc(128);
            DeserializationError err = deserializeJson(doc, server->arg("plain"));
            if (!err) {
                if (doc.containsKey("romString")) {
                    String rom = doc["romString"].as<String>();
                    // Find point bound to this ROM and unbind
                    for (uint8_t i = 0; i < 50; ++i) {
                        Sensor* bound = controller.getDS18B20Point(i)->getBoundSensor();
                        if (bound && bound->getDS18B20RomString() == rom) {
                            if(controller.unbindSensorFromPoint(i)){
                                savePointsConfig();
                            server->send(200, "text/plain", "Unbound");
                            return;

                            };
                            
                        }
                    }
                } else if (doc.containsKey("chipSelect")) {
                    int cs = doc["chipSelect"];
                    for (uint8_t i = 0; i < 10; ++i) {
                        Sensor* bound = controller.getPT1000Point(i)->getBoundSensor();
                        if (bound && bound->getPT1000ChipSelectPin() == cs) {
                            if(controller.unbindSensorFromPoint(50 + i)){
                                savePointsConfig();
                                server->send(200, "text/plain", "Unbound");
                                return;
                            };

                        }
                    }
                }
            }
        }
        server->send(400, "text/plain", "Bad Request");
    });



};
void ConfigManager::csvImportExportAPI(){

     // Combined points and alarms export
     server->on("/api/export/config", HTTP_GET, [this]() {
        String csv = csvManager.exportPointsWithAlarmsToCSV();
        server->sendHeader("Content-Type", "text/csv");
        server->sendHeader("Content-Disposition", "attachment; filename=config.csv");
        server->send(200, "text/csv", csv);
    });

    // Combined points and alarms import
    server->on("/api/import/config", HTTP_POST, [this]() {
        if (!server->hasArg("plain")) {
            server->send(400, "application/json", "{\"error\":\"No CSV data provided\"}");
            return;
        }
        
        bool success = csvManager.importPointsWithAlarmsFromCSV(server->arg("plain"));
        if (success) {
            savePointsConfig();
            saveAlarmsConfig();
            server->send(200, "application/json", "{\"status\":\"success\",\"message\":\"Configuration imported successfully\"}");
        } else {
            String error = csvManager.getLastError();
            server->send(400, "application/json", "{\"status\":\"error\",\"message\":\"" + error + "\"}");
        }
    });


    // Add these to your ConfigManager::begin() method after existing API endpoints

    // CSV Export endpoint
    server->on("/api/csv/export", HTTP_GET, [this]() {
        CSVConfigManager csvManager(controller);
        String csvData = csvManager.exportPointsWithAlarmsToCSV();
        
        if (csvData.length() > 0) {
            String filename = "temperature_config_" + String(millis()) + ".csv";
            server->sendHeader("Content-Type", "text/csv");
            server->sendHeader("Content-Disposition", "attachment; filename=\"" + filename + "\"");
            server->send(200, "text/csv", csvData);
        } else {
            server->send(500, "application/json", "{\"error\":\"Failed to generate CSV\"}");
        }
    });

    // CSV Import endpoint
   // In ConfigManager.cpp, update the CSV import endpoint:
    server->on("/api/csv/import", HTTP_POST, [this]() {
        // This will be called after file upload is complete
    }, [this]() {
        // Handle file upload
        HTTPUpload& upload = server->upload();
        static String csvContent;
        
        if (upload.status == UPLOAD_FILE_START) {
            csvContent = "";
            LoggerManager::info("CONFIG_IMPORT", 
                "CSV upload started - filename: " + String(upload.filename.c_str()));
            Serial.printf("Upload Start: %s\n", upload.filename.c_str());
        } else if (upload.status == UPLOAD_FILE_WRITE) {
            csvContent += String((char*)upload.buf, upload.currentSize);
        } else if (upload.status == UPLOAD_FILE_END) {
            Serial.printf("Upload End: %s (%u bytes)\n", upload.filename.c_str(), upload.totalSize);
            LoggerManager::info("CONFIG_IMPORT", 
                "CSV upload completed - size: " + String(upload.totalSize) + " bytes");
            
            // Process the uploaded CSV
            if (csvManager.importPointsWithAlarmsFromCSV(csvContent)) {
                saveAlarmsConfig();
                savePointsConfig();
                LoggerManager::info("CONFIG_IMPORT", "CSV import successful");
                server->send(200, "application/json", "{\"success\":true}");
            } else {
                String error = csvManager.getLastError();
                LoggerManager::error("CONFIG_IMPORT", "CSV import failed: " + error);
                server->send(400, "application/json", "{\"success\":false,\"error\":\"" + error + "\"}");
            }
            csvContent = "";
        }
    });
    // Settings CSV Export endpoint
    server->on("/api/settings/export", HTTP_GET, [this]() {
        String csvData = settingsCSVManager.exportSettingsToCSV();
        
        if (csvData.length() > 0) {
            String filename = "device_settings_" + String(millis()) + ".csv";
            server->sendHeader("Content-Type", "text/csv");
            server->sendHeader("Content-Disposition", "attachment; filename=\"" + filename + "\"");
            server->send(200, "text/csv", csvData);
        } else {
            server->send(500, "application/json", "{\"error\":\"Failed to generate settings CSV\"}");
        }
    });

    // Settings CSV Import endpoint
    server->on("/api/settings/import", HTTP_POST, [this]() {
        // This will be called after file upload is complete
    }, [this]() {
        // Handle file upload
        HTTPUpload& upload = server->upload();
        static String csvContent;
        
        if (upload.status == UPLOAD_FILE_START) {
            csvContent = "";
            Serial.printf("Settings Upload Start: %s\n", upload.filename.c_str());
        } else if (upload.status == UPLOAD_FILE_WRITE) {
            csvContent += String((char*)upload.buf, upload.currentSize);
        } else if (upload.status == UPLOAD_FILE_END) {
            Serial.printf("Settings Upload End: %s (%u bytes)\n", upload.filename.c_str(), upload.totalSize);
            
            // Process the uploaded CSV
            if (settingsCSVManager.importSettingsFromCSV(csvContent)) {
                // Save configuration after successful import
                conf.saveConfigFile();
                server->send(200, "application/json", "{\"success\":true,\"message\":\"Settings imported successfully. Device will restart.\"}");
                
                // Restart device to apply new settings
                delay(1000);
                ESP.restart();
            } else {
                String error = settingsCSVManager.getLastError();
                server->send(400, "application/json", "{\"success\":false,\"error\":\"" + error + "\"}");
            }
            csvContent = "";
        }
    });

};
void ConfigManager::pointsAPI(){
    // GET points
    server->on("/api/points", HTTP_GET, [this]() {
        server->sendHeader("Content-Type", "application/json");
        server->send(200, "application/json", controller.getPointsJson());
    });

    // PUT point update
    server->on("/api/points", HTTP_PUT, [this]() {
        if (!server->hasArg("plain")) {
            server->send(400, "application/json", "{\"error\":\"No data\"}");
            return;
        }
        DynamicJsonDocument doc(512);
        DeserializationError err = deserializeJson(doc, server->arg("plain"));
        if (err) {
            server->send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
            return;
        }
        Serial.println("/api/points HTTP_PUT:" + doc.as<String>());
        uint8_t address = doc["address"];
        String name = doc["name"].as<String>();
        int16_t low = doc["lowAlarmThreshold"];
        int16_t high = doc["highAlarmThreshold"];


        MeasurementPoint* point = controller.getMeasurementPoint(address);
        if (!point) {
            server->send(404, "application/json", "{\"error\":\"Point not found\"}");
            return;
        }
        point->setName(name);
        point->setLowAlarmThreshold(low);
        point->setHighAlarmThreshold(high);
        Serial.printf("Point: %s. LAS: %d, HAS: %d\n Delay....\n", point->getName(), point->getLowAlarmThreshold(), point->getHighAlarmThreshold());
        delay(5000);
        controller.applyConfigToRegisterMap();
        // Save to config if needed
        savePointsConfig(); // implement this to persist changes

        server->send(200, "application/json", "{\"success\":true}");
    });

};
void ConfigManager::alarmsAPI(){

    // Get alarms configuration
    server->on("/api/alarms", HTTP_GET, [this]() {
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", controller.getAlarmsJson());
    });

    // Add/Update alarm configuration
    server->on("/api/alarms", HTTP_POST, [this]() {
        if (!server->hasArg("plain")) {
            server->send(400, "application/json", "{\"error\":\"No data\"}");
            return;
        }
        
        DynamicJsonDocument doc(512);
        DeserializationError err = deserializeJson(doc, server->arg("plain"));
        if (err) {
            server->send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
            return;
        }
        
        AlarmType type = static_cast<AlarmType>(doc["type"].as<int>());
        uint8_t pointAddress = doc["pointAddress"].as<int>();
        AlarmPriority priority = static_cast<AlarmPriority>(doc["priority"].as<int>());
        
        bool success = controller.addAlarm(type, pointAddress, priority);
        if (success) {
            saveAlarmsConfig();
            server->send(200, "application/json", "{\"status\":\"success\"}");
        } else {
            server->send(400, "application/json", "{\"error\":\"Failed to add alarm\"}");
        }
    });

    // Delete alarm configuration
    server->on("/api/alarms", HTTP_DELETE, [this]() {
        if (!server->hasArg("configKey")) {
            server->send(400, "application/json", "{\"error\":\"No configKey provided\"}");
            return;
        }
        
        String configKey = server->arg("configKey");
        bool success = controller.removeAlarm(configKey);
        if (success) {
            saveAlarmsConfig();
            server->send(200, "application/json", "{\"status\":\"deleted\"}");
        } else {
            server->send(404, "application/json", "{\"error\":\"Alarm not found\"}");
        }
    });

    // Add these endpoints to your setupWebServer() method in ConfigManager.cpp

    // Get alarms configuration
    server->on("/api/alarms", HTTP_GET, [this]() {
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", controller.getAlarmsJson());
    });

    // Add/Update alarm configuration
    server->on("/api/alarms", HTTP_POST, [this]() {
        if (!server->hasArg("plain")) {
            server->send(400, "application/json", "{\"error\":\"No data\"}");
            return;
        }
        
        DynamicJsonDocument doc(512);
        DeserializationError err = deserializeJson(doc, server->arg("plain"));
        if (err) {
            server->send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
            return;
        }
        
        AlarmType type = static_cast<AlarmType>(doc["type"].as<int>());
        uint8_t pointAddress = doc["pointAddress"].as<int>();
        AlarmPriority priority = static_cast<AlarmPriority>(doc["priority"].as<int>());
        
        bool success = controller.addAlarm(type, pointAddress, priority);
        if (success) {
            saveAlarmsConfig();
            server->send(200, "application/json", "{\"status\":\"success\"}");
        } else {
            server->send(400, "application/json", "{\"error\":\"Failed to add alarm\"}");
        }
    });

    // Update alarm configuration
    server->on("/api/alarms", HTTP_PUT, [this]() {
        if (!server->hasArg("plain")) {
            server->send(400, "application/json", "{\"error\":\"No data\"}");
            return;
        }
        
        DynamicJsonDocument doc(512);
        DeserializationError err = deserializeJson(doc, server->arg("plain"));
        if (err) {
            server->send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
            return;
        }
        
        String configKey = doc["configKey"].as<String>();
        AlarmPriority priority = static_cast<AlarmPriority>(doc["priority"].as<int>());
        bool enabled = doc["enabled"].as<bool>();
        
        bool success = controller.updateAlarm(configKey, priority, enabled);
        if (success) {
            saveAlarmsConfig();
            server->send(200, "application/json", "{\"status\":\"updated\"}");
        } else {
            server->send(404, "application/json", "{\"error\":\"Alarm not found\"}");
        }
    });

    // Delete alarm configuration
    server->on("/api/alarms", HTTP_DELETE, [this]() {
        if (!server->hasArg("configKey")) {
            server->send(400, "application/json", "{\"error\":\"No configKey provided\"}");
            return;
        }
        
        String configKey = server->arg("configKey");
        bool success = controller.removeAlarm(configKey);
        if (success) {
            saveAlarmsConfig();
            server->send(200, "application/json", "{\"status\":\"deleted\"}");
        } else {
            server->send(404, "application/json", "{\"error\":\"Alarm not found\"}");
        }
    });

    // Acknowledge specific alarm
    server->on("/api/alarms/acknowledge", HTTP_POST, [this]() {
        if (!server->hasArg("plain")) {
            server->send(400, "application/json", "{\"error\":\"No data\"}");
            return;
        }

        DynamicJsonDocument doc(512);
        DeserializationError err = deserializeJson(doc, server->arg("plain"));
        if (err) {
            server->send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
            return;
        }

        String configKey = doc["configKey"].as<String>();
        
        // Find alarm in configured alarms
        Alarm* alarm = controller.findAlarm(configKey);
        if (!alarm) {
            server->send(404, "application/json", "{\"error\":\"Alarm not found\"}");
            return;
        }

        // Find corresponding active alarm and acknowledge it
        bool acknowledged = false;
        for (auto activeAlarm : controller.getActiveAlarms()) {
            if (activeAlarm->getSource() == alarm->getSource() && 
                activeAlarm->getType() == alarm->getType()) {
                activeAlarm->acknowledge();
                acknowledged = true;
                Serial.printf("Acknowledged alarm: %s for point %d\n", 
                            activeAlarm->getTypeString().c_str(),
                            activeAlarm->getSource()->getAddress());
                break;
            }
        }

        if (acknowledged) {
            server->send(200, "application/json", "{\"status\":\"acknowledged\"}");
        } else {
            server->send(404, "application/json", "{\"error\":\"No active alarm found to acknowledge\"}");
        }
    });

    // Acknowledge all active alarms
    server->on("/api/alarms/acknowledge-all", HTTP_POST, [this]() {
        std::vector<Alarm*> activeAlarms = controller.getActiveAlarms();
        int acknowledgedCount = 0;
        
        for (auto alarm : activeAlarms) {
            if (!alarm->isAcknowledged()) {
                alarm->acknowledge();
                acknowledgedCount++;
                Serial.printf("Acknowledged alarm: %s for point %d\n", 
                            alarm->getTypeString().c_str(),
                            alarm->getSource() ? alarm->getSource()->getAddress() : -1);
            }
        }
        
        DynamicJsonDocument response(256);
        response["status"] = "success";
        response["acknowledgedCount"] = acknowledgedCount;
        response["message"] = String(acknowledgedCount) + " alarms acknowledged";
        
        String output;
        serializeJson(response, output);
        server->send(200, "application/json", output);
    });

    // Clear resolved alarms
    server->on("/api/alarms/clear-resolved", HTTP_POST, [this]() {
        std::vector<Alarm*> configuredAlarms = controller.getConfiguredAlarms();
        int clearedCount = 0;
        
        // Remove resolved alarms from configured alarms
        for (auto it = configuredAlarms.begin(); it != configuredAlarms.end();) {
            if ((*it)->isResolved()) {
                String configKey = (*it)->getConfigKey();
                bool removed = controller.removeAlarm(configKey);
                if (removed) {
                    clearedCount++;
                    Serial.printf("Cleared resolved alarm: %s\n", configKey.c_str());
                }
                // Note: iterator is handled by removeAlarm method
                it = configuredAlarms.begin(); // Restart iteration after removal
            } else {
                ++it;
            }
        }
        
        // Save configuration after clearing
        if (clearedCount > 0) {
            saveAlarmsConfig();
        }
        
        DynamicJsonDocument response(256);
        response["status"] = "success";
        response["clearedCount"] = clearedCount;
        response["message"] = String(clearedCount) + " resolved alarms cleared";
        
        String output;
        serializeJson(response, output);
        server->send(200, "application/json", output);
    });

    // Get active alarms only (for dashboard/monitoring)
    server->on("/api/alarms/active", HTTP_GET, [this]() {
        DynamicJsonDocument doc(4096);
        JsonArray alarmArray = doc.createNestedArray("alarms");
        
        for (auto alarm : controller.getActiveAlarms()) {
            JsonObject obj = alarmArray.createNestedObject();
            obj["type"] = static_cast<int>(alarm->getType());
            obj["stage"] = static_cast<int>(alarm->getStage());
            obj["priority"] = static_cast<int>(alarm->getPriority());
            obj["timestamp"] = alarm->getTimestamp();
            obj["acknowledgedTime"] = alarm->getAcknowledgedTime();
            obj["message"] = alarm->getMessage();
            obj["isActive"] = alarm->isActive();
            obj["isAcknowledged"] = alarm->isAcknowledged();
            
            if (alarm->getSource()) {
                obj["pointAddress"] = alarm->getSource()->getAddress();
                obj["pointName"] = alarm->getSource()->getName();
                obj["currentTemp"] = alarm->getSource()->getCurrentTemp();
            }
        }
        
        String output;
        serializeJson(doc, output);
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", output);
    });

    // Get alarm statistics
    server->on("/api/alarms/stats", HTTP_GET, [this]() {
        std::vector<Alarm*> activeAlarms = controller.getActiveAlarms();
        
        int criticalCount = 0, highCount = 0, mediumCount = 0, lowCount = 0;
        int newCount = 0, activeCount = 0, acknowledgedCount = 0;
        
        for (auto alarm : activeAlarms) {
            // Count by priority
            switch (alarm->getPriority()) {
                case AlarmPriority::PRIORITY_CRITICAL: criticalCount++; break;
                case AlarmPriority::PRIORITY_HIGH: highCount++; break;
                case AlarmPriority::PRIORITY_MEDIUM: mediumCount++; break;
                case AlarmPriority::PRIORITY_LOW: lowCount++; break;
            }
            
            // Count by stage
            switch (alarm->getStage()) {
                case AlarmStage::NEW: newCount++; break;
                case AlarmStage::ACTIVE: activeCount++; break;
                case AlarmStage::ACKNOWLEDGED: acknowledgedCount++; break;
                default: break;
            }
        }
        
        DynamicJsonDocument doc(512);
        doc["totalActive"] = activeAlarms.size();
        doc["totalConfigured"] = controller.getAlarmCount();
        
        JsonObject byPriority = doc.createNestedObject("byPriority");
        byPriority["critical"] = criticalCount;
        byPriority["high"] = highCount;
        byPriority["medium"] = mediumCount;
        byPriority["low"] = lowCount;
        
        JsonObject byStage = doc.createNestedObject("byStage");
        byStage["new"] = newCount;
        byStage["active"] = activeCount;
        byStage["acknowledged"] = acknowledgedCount;
        
        String output;
        serializeJson(doc, output);
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", output);
    });

    // Get acknowledged delays
    server->on("/api/alarms/delays", HTTP_GET, [this]() {
        DynamicJsonDocument doc(512);
        doc["critical"] = getAcknowledgedDelayCritical();
        doc["high"] = getAcknowledgedDelayHigh();
        doc["medium"] = getAcknowledgedDelayMedium();
        doc["low"] = getAcknowledgedDelayLow();
        
        String output;
        serializeJson(doc, output);
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", output);
    });

    // Update acknowledged delays
    server->on("/api/alarms/delays", HTTP_PUT, [this]() {
        if (!server->hasArg("plain")) {
            server->send(400, "application/json", "{\"error\":\"No data\"}");
            return;
        }
        
        DynamicJsonDocument doc(512);
        DeserializationError err = deserializeJson(doc, server->arg("plain"));
        if (err) {
            server->send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
            return;
        }
        
        bool updated = false;
        
        if (doc.containsKey("critical")) {
            int minutes = doc["critical"].as<int>();
            if (minutes >= 1 && minutes <= 1440) {
                conf["ack_delay_critical"] = String(minutes);
                controller.setAcknowledgedDelayCritical(minutes * 60 * 1000);
                updated = true;
            }
        }
        
        if (doc.containsKey("high")) {
            int minutes = doc["high"].as<int>();
            if (minutes >= 1 && minutes <= 1440) {
                conf["ack_delay_high"] = String(minutes);
                controller.setAcknowledgedDelayHigh(minutes * 60 * 1000);
                updated = true;
            }
        }
        
        if (doc.containsKey("medium")) {
            int minutes = doc["medium"].as<int>();
            if (minutes >= 1 && minutes <= 1440) {
                conf["ack_delay_medium"] = String(minutes);
                controller.setAcknowledgedDelayMedium(minutes * 60 * 1000);
                updated = true;
            }
        }
        
        if (doc.containsKey("low")) {
            int minutes = doc["low"].as<int>();
            if (minutes >= 1 && minutes <= 1440) {
                conf["ack_delay_low"] = String(minutes);
                controller.setAcknowledgedDelayLow(minutes * 60 * 1000);
                updated = true;
            }
        }
        
        if (updated) {
            conf.saveConfigFile();
            server->send(200, "application/json", "{\"status\":\"updated\"}");
        } else {
            server->send(400, "application/json", "{\"error\":\"No valid delays provided\"}");
        }
    });

    // GET /api/alarm-config - Get alarm configuration for all measurement points
    server->on("/api/alarm-config", HTTP_GET, [this]() {
        DynamicJsonDocument doc(8192); // Increased size for all points
        JsonArray pointsArray = doc.createNestedArray("points");
        
        // Get DS18B20 points (0-49)
        for (uint8_t i = 0; i < 50; ++i) {
            MeasurementPoint* point = controller.getMeasurementPoint(i);
            if (!point) continue;
            
            JsonObject pointObj = pointsArray.createNestedObject();
            pointObj["address"] = point->getAddress();
            pointObj["name"] = point->getName();
            pointObj["currentTemp"] = point->getCurrentTemp();
            pointObj["sensorBound"] = (point->getBoundSensor() != nullptr);
            pointObj["lowThreshold"] = point->getLowAlarmThreshold();
            pointObj["highThreshold"] = point->getHighAlarmThreshold();
            // For now, set default priorities and hysteresis since MeasurementPoint doesn't store these
            pointObj["lowPriority"] = 2; // Medium priority as default
            pointObj["highPriority"] = 3; // High priority as default
            pointObj["errorPriority"] = 3; // High priority as default
            pointObj["hysteresis"] = 2; // Default hysteresis
        }
        
        // Get PT1000 points (50-59)
        for (uint8_t i = 50; i < 60; ++i) {
            MeasurementPoint* point = controller.getMeasurementPoint(i);
            if (!point) continue;
            
            JsonObject pointObj = pointsArray.createNestedObject();
            pointObj["address"] = point->getAddress();
            pointObj["name"] = point->getName();
            pointObj["currentTemp"] = point->getCurrentTemp();
            pointObj["sensorBound"] = (point->getBoundSensor() != nullptr);
            pointObj["lowThreshold"] = point->getLowAlarmThreshold();
            pointObj["highThreshold"] = point->getHighAlarmThreshold();
            // For now, set default priorities and hysteresis since MeasurementPoint doesn't store these
            pointObj["lowPriority"] = 2; // Medium priority as default
            pointObj["highPriority"] = 3; // High priority as default
            pointObj["errorPriority"] = 3; // High priority as default
            pointObj["hysteresis"] = 2; // Default hysteresis
        }
        
        String output;
        serializeJson(doc, output);
        
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", output);
    });

    // POST /api/alarm-config - Update alarm configuration for multiple points
    server->on("/api/alarm-config", HTTP_POST, [this]() {
        if (!server->hasArg("plain")) {
            server->send(400, "application/json", "{\"error\":\"No data provided\"}");
            return;
        }
        
        DynamicJsonDocument doc(8192); // Large enough for multiple points
        DeserializationError err = deserializeJson(doc, server->arg("plain"));
        if (err) {
            server->send(400, "application/json", "{\"error\":\"Invalid JSON format\"}");
            return;
        }
        
        if (!doc.containsKey("changes") || !doc["changes"].is<JsonArray>()) {
            server->send(400, "application/json", "{\"error\":\"Missing or invalid 'changes' array\"}");
            return;
        }
        
        JsonArray changes = doc["changes"];
        int updatedCount = 0;
        int errorCount = 0;
        String errors = "";
        
        // Apply changes to each point
        for (JsonVariant changeVar : changes) {
            JsonObject change = changeVar.as<JsonObject>();
            
            if (!change.containsKey("address")) {
                errorCount++;
                errors += "Missing address in change entry; ";
                continue;
            }
            
            uint8_t address = change["address"];
            MeasurementPoint* point = controller.getMeasurementPoint(address);
            
            if (!point) {
                errorCount++;
                errors += "Point " + String(address) + " not found; ";
                continue;
            }
            
            try {
                // Update point name if provided
                if (change.containsKey("name")) {
                    point->setName(change["name"].as<String>());
                }
                
                // Update thresholds if provided
                if (change.containsKey("lowThreshold")) {
                    point->setLowAlarmThreshold(change["lowThreshold"].as<int16_t>());
                }
                if (change.containsKey("highThreshold")) {
                    point->setHighAlarmThreshold(change["highThreshold"].as<int16_t>());
                }
                
                // TODO: Priority and hysteresis configuration will be handled through alarm system
                // For now, we only update name and thresholds since MeasurementPoint doesn't store priorities/hysteresis
                // Note: Priority and hysteresis are managed through configured alarms in the alarm system
                
                updatedCount++;
                
            } catch (...) {
                errorCount++;
                errors += "Error updating point " + String(address) + "; ";
            }
        }
        
        // Apply configuration to register map and save
        if (updatedCount > 0) {
            controller.applyConfigToRegisterMap();
            savePointsConfig(); // Save the updated configuration
        }
        
        // Send response
        DynamicJsonDocument response(1024);
        response["success"] = (errorCount == 0);
        response["updatedCount"] = updatedCount;
        response["errorCount"] = errorCount;
        response["message"] = String(updatedCount) + " points updated successfully";
        
        if (errorCount > 0) {
            response["errors"] = errors;
        }
        
        String output;
        serializeJson(response, output);
        server->send((errorCount == 0) ? 200 : 207, "application/json", output); // 207 = Multi-Status
    });

};

// Add these methods to your ConfigManager.cpp file in the logsAPI() function

void ConfigManager::logsAPI() {
    // Get alarm history
    server->on("/api/alarm-history", HTTP_GET, [this]() {
        String startDate = server->arg("start");
        String endDate = server->arg("end");
        
        if (startDate.isEmpty() || endDate.isEmpty()) {
            server->send(400, "application/json", "{\"success\":false,\"error\":\"Missing date parameters\"}");
            return;
        }
        
        // Use static method
        String historyJson = LoggerManager::getAlarmHistoryJson(startDate, endDate);
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", historyJson);
    });
    
    // Export alarm history as CSV
    server->on("/api/alarm-history/export", HTTP_GET, [this]() {
        String startDate = server->arg("start");
        String endDate = server->arg("end");
        
        if (startDate.isEmpty() || endDate.isEmpty()) {
            server->send(400, "application/json", "{\"success\":false,\"error\":\"Missing date parameters\"}");
            return;
        }
        
        // Use static method
        String csvData = LoggerManager::getAlarmHistoryCsv(startDate, endDate);
        
        if (csvData.length() > 0) {
            String filename = "alarm_history_" + startDate + "_to_" + endDate + ".csv";
            server->sendHeader("Content-Type", "text/csv");
            server->sendHeader("Content-Disposition", "attachment; filename=\"" + filename + "\"");
            server->send(200, "text/csv", csvData);
        } else {
            server->send(404, "application/json", "{\"success\":false,\"error\":\"No alarm history found\"}");
        }
    });
    
    // Get available alarm log files
    server->on("/api/alarm-history/files", HTTP_GET, [this]() {
        DynamicJsonDocument doc(2048);
        JsonArray filesArray = doc.createNestedArray("files");
        
        std::vector<String> files = LoggerManager::getAlarmStateLogFiles();
        for (const String& file : files) {
            filesArray.add(file);
        }
        
        String output;
        serializeJson(doc, output);
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", output);
    });

    // NEW EVENT LOG ENDPOINTS
    
    // Get event logs
    server->on("/api/event-logs", HTTP_GET, [this]() {
        String startDate = server->arg("start");
        String endDate = server->arg("end");
        
        if (startDate.isEmpty() || endDate.isEmpty()) {
            server->send(400, "application/json", "{\"success\":false,\"error\":\"Missing date parameters\"}");
            return;
        }
        
        String eventLogsJson = LoggerManager::getEventLogsJson(startDate, endDate);
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", eventLogsJson);
    });
    
    // Export event logs as CSV
    server->on("/api/event-logs/export", HTTP_GET, [this]() {
        String startDate = server->arg("start");
        String endDate = server->arg("end");
        
        if (startDate.isEmpty() || endDate.isEmpty()) {
            server->send(400, "application/json", "{\"success\":false,\"error\":\"Missing date parameters\"}");
            return;
        }
        
        String csvData = LoggerManager::getEventLogsCsv(startDate, endDate);
        
        if (csvData.length() > 0) {
            String filename = "event_logs_" + startDate + "_to_" + endDate + ".csv";
            server->sendHeader("Content-Type", "text/csv");
            server->sendHeader("Content-Disposition", "attachment; filename=\"" + filename + "\"");
            server->send(200, "text/csv", csvData);
        } else {
            server->send(404, "application/json", "{\"success\":false,\"error\":\"No event logs found\"}");
        }
    });
    
    // Get available event log files
    server->on("/api/event-logs/files", HTTP_GET, [this]() {
        DynamicJsonDocument doc(2048);
        JsonArray filesArray = doc.createNestedArray("files");
        
        std::vector<String> files = LoggerManager::getEventLogFilesStatic();
        for (const String& file : files) {
            filesArray.add(file);
        }
        
        String output;
        serializeJson(doc, output);
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", output);
    });
    
    // Get event log statistics
    server->on("/api/event-logs/stats", HTTP_GET, [this]() {
        String startDate = server->arg("start");
        String endDate = server->arg("end");
        
        if (startDate.isEmpty() || endDate.isEmpty()) {
            server->send(400, "application/json", "{\"success\":false,\"error\":\"Missing date parameters\"}");
            return;
        }
        
        String statsJson = LoggerManager::getEventLogStatsJson(startDate, endDate);
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->send(200, "application/json", statsJson);
    });
}

void ConfigManager::downloadAPI() {
    // API endpoint to list all data log files
    server->on("/api/data-log-files", HTTP_GET, [this]() {
        DynamicJsonDocument doc(4096);
        doc["success"] = true;
        JsonArray filesArray = doc.createNestedArray("files");
        
        // Get list of temperature data log files
        std::vector<String> files = LoggerManager::getLogFiles();
        for (const String& filename : files) {
            JsonObject fileObj = filesArray.createNestedObject();
            fileObj["filename"] = filename;
            
            // Get file info using static method
            size_t fileSize;
            String date;
            if (LoggerManager::getFileInfo(filename, "data", fileSize, date)) {
                fileObj["size"] = fileSize;
                fileObj["date"] = date;
            } else {
                fileObj["size"] = 0;
                fileObj["date"] = "";
            }
        }
        
        String output;
        serializeJson(doc, output);
        
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->sendHeader("Cache-Control", "no-store");
        server->send(200, "application/json", output);
    });

    // API endpoint to list event log files
    server->on("/api/event-log-files", HTTP_GET, [this]() {
        DynamicJsonDocument doc(4096);
        doc["success"] = true;
        JsonArray filesArray = doc.createNestedArray("files");
        
        // Get list of event log files
        std::vector<String> files = LoggerManager::getEventLogFilesStatic();
        for (const String& filename : files) {
            JsonObject fileObj = filesArray.createNestedObject();
            fileObj["filename"] = filename;
            
            // Get file info using static method
            size_t fileSize;
            String date;
            if (LoggerManager::getFileInfo(filename, "event", fileSize, date)) {
                fileObj["size"] = fileSize;
                fileObj["date"] = date;
            } else {
                fileObj["size"] = 0;
                fileObj["date"] = "";
            }
        }
        
        String output;
        serializeJson(doc, output);
        
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->sendHeader("Cache-Control", "no-store");
        server->send(200, "application/json", output);
    });

    // API endpoint to list alarm log files
    server->on("/api/alarm-log-files", HTTP_GET, [this]() {
        DynamicJsonDocument doc(4096);
        doc["success"] = true;
        JsonArray filesArray = doc.createNestedArray("files");
        
        // Get list of alarm state log files
        std::vector<String> files = LoggerManager::getAlarmStateLogFiles();
        for (const String& filename : files) {
            JsonObject fileObj = filesArray.createNestedObject();
            fileObj["filename"] = filename;
            
            // Get file info using static method
            size_t fileSize;
            String date;
            if (LoggerManager::getFileInfo(filename, "alarm", fileSize, date)) {
                fileObj["size"] = fileSize;
                fileObj["date"] = date;
            } else {
                fileObj["size"] = 0;
                fileObj["date"] = "";
            }
        }
        
        String output;
        serializeJson(doc, output);
        
        server->sendHeader("Content-Type", "application/json");
        server->sendHeader("Access-Control-Allow-Origin", "*");
        server->sendHeader("Cache-Control", "no-store");
        server->send(200, "application/json", output);
    });

    // API endpoint to download temperature data log files
    server->on("/api/data-log-download", HTTP_GET, [this]() {
        String filename = server->arg("file");
        
        if (filename.isEmpty()) {
            server->send(400, "text/plain", "Missing file parameter");
            return;
        }
        
        // Security check - only allow files that start with "temp_log_" and end with ".csv"
        if (!filename.startsWith("temp_log_") || !filename.endsWith(".csv")) {
            server->send(403, "text/plain", "Invalid file type");
            return;
        }
        
        // Open file using static method
        File file = LoggerManager::openLogFile(filename, "data");
        if (!file) {
            server->send(404, "text/plain", "File not found");
            return;
        }
        
        // Set headers for file download
        server->sendHeader("Content-Type", "text/csv");
        server->sendHeader("Content-Disposition", "attachment; filename=" + filename);
        server->sendHeader("Access-Control-Allow-Origin", "*");
        
        // Stream the file directly
        server->streamFile(file, "text/csv");
        file.close();
        
        Serial.printf("Downloaded data log file: %s\n", filename.c_str());
    });

    // API endpoint to download event log files
    server->on("/api/event-log-download", HTTP_GET, [this]() {
        String filename = server->arg("file");
        
        if (filename.isEmpty()) {
            server->send(400, "text/plain", "Missing file parameter");
            return;
        }
        
        // Security check - only allow files that start with "events_" and end with ".csv"
        if (!filename.startsWith("events_") || !filename.endsWith(".csv")) {
            server->send(403, "text/plain", "Invalid file type");
            return;
        }
        
        // Open file using static method
        File file = LoggerManager::openLogFile(filename, "event");
        if (!file) {
            server->send(404, "text/plain", "File not found");
            return;
        }
        
        // Set headers for file download
        server->sendHeader("Content-Type", "text/csv");
        server->sendHeader("Content-Disposition", "attachment; filename=" + filename);
        server->sendHeader("Access-Control-Allow-Origin", "*");
        
        // Stream the file directly
        server->streamFile(file, "text/csv");
        file.close();
        
        Serial.printf("Downloaded event log file: %s\n", filename.c_str());
    });

    // API endpoint to download alarm state log files
    server->on("/api/alarm-log-download", HTTP_GET, [this]() {
        String filename = server->arg("file");
        
        if (filename.isEmpty()) {
            server->send(400, "text/plain", "Missing file parameter");
            return;
        }
        
        // Security check - only allow files that start with "alarm_states_" and end with ".csv"
        if (!filename.startsWith("alarm_states_") || !filename.endsWith(".csv")) {
            server->send(403, "text/plain", "Invalid file type");
            return;
        }
        
        // Open file using static method
        File file = LoggerManager::openLogFile(filename, "alarm");
        if (!file) {
            server->send(404, "text/plain", "File not found");
            return;
        }
        
        // Set headers for file download
        server->sendHeader("Content-Type", "text/csv");
        server->sendHeader("Content-Disposition", "attachment; filename=" + filename);
        server->sendHeader("Access-Control-Allow-Origin", "*");
        
        // Stream the file directly
        server->streamFile(file, "text/csv");
        file.close();
        
        Serial.printf("Downloaded alarm state log file: %s\n", filename.c_str());
    });
}

-------- [ Separator ] ------

File Name: src/IndicatorInterface.cpp
Size: 29.11 KB
Code:
#include "IndicatorInterface.h"


// Static instance for interrupt handling
IndicatorInterface* IndicatorInterface::_instance = nullptr;

IndicatorInterface::IndicatorInterface(TwoWire& i2cBus, uint8_t pcf_i2cAddress, int intPin)
    : _i2cBus(&i2cBus), _pcf_i2cAddress(pcf_i2cAddress), _intPin(intPin), _pcf8575(pcf_i2cAddress),
      _directionMask(0x0000), _modeMask(0x0000), _currentState(0xFFFF), _lastState(0xFFFF),
      _lastReadTime(0), _pollInterval(50), _interruptFlag(false), _useInterrupts(false),
      _interruptCallback(nullptr),
      _oledSleepDelay(30000), _oledLines(3), _textBufferSize(0), _oledOn(true),
      _oledBlink(false), _blinkTimeOn(500), _blinkTimeOff(500), _lastBlinkTime(0),
      _blinkState(true), _lastActivityTime(0), _oledSleeping(false),
      _lastScrollTime(0), _scrollDelay(200), _charWidth(6), _lineHeight(12),
      _maxCharsPerLine(21),
      _savedTextBufferSize(0), _savedOledLines(3), _isBlinkingOK(false), 
      _isBlinkingCross(false), _blinkDelayTime(500), _lastBlinkToggle(0), _blinkShowSpecial(true)  {
    
    // Set static instance for interrupt handling
    _instance = this;
    
    // Configure interrupt usage
    _useInterrupts = (intPin >= 0);

    // Initialize scroll offsets
    for (int i = 0; i < 5; i++) {
        _scrollOffset[i] = 0;
    }
    
}

U8G2_SH1106_128X64_NONAME_F_HW_I2C IndicatorInterface::u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);

IndicatorInterface::~IndicatorInterface() {
    if (_useInterrupts && _intPin >= 0) {
        detachInterrupt(digitalPinToInterrupt(_intPin));
    }
    _instance = nullptr;
}

bool IndicatorInterface::begin() {
    // Initialize I2C if not already done
    if (!_i2cBus) {
        return false;
    }
    
    // Initialize PCF8575
    if (!_pcf8575.begin()) {
        return false;
    }
    
    // Configure interrupt pin if specified
    if (_useInterrupts) {
        _configureInterruptPin();
    }
    
    // Initialize all pins as inputs (HIGH state)
    _pcf8575.write16(0xFFFF);
    delay(100);
    _clearInterrupt();
    
    // Read initial state
    _currentState = _readPCF();
    _lastState = _currentState;
    _lastReadTime = millis();

    //OLED INIT
    u8g2.begin();
    _initOLED();
    
    return true;
}

void IndicatorInterface::_configureInterruptPin() {
    if (_intPin < 0) return;
    
    // Configure pin based on ESP32 capabilities
    if (_intPin == 34 || _intPin == 35 || _intPin == 36 || _intPin == 39) {
        // Input-only pins without internal pull-up
        pinMode(_intPin, INPUT);
        // Note: External pull-up resistor (4.7kΩ) required!
    } else {
        // Regular GPIO pins with internal pull-up
        pinMode(_intPin, INPUT_PULLUP);
    }
    
    // Attach interrupt
    attachInterrupt(digitalPinToInterrupt(_intPin), _staticInterruptHandler, FALLING);
}

void IndicatorInterface::setDirection(uint16_t directionMask) {
    _directionMask = directionMask;
    
    // Update PCF8575 state to reflect direction changes
    uint16_t newState = _currentState;
    
    // Set input pins HIGH (input mode for PCF8575)
    for (int i = 0; i < 16; i++) {
        if (!isOutput(i)) {
            newState |= (1 << i);
        }
    }
    
    _writePCF(newState);
}

void IndicatorInterface::setMode(uint16_t modeMask) {
    _modeMask = modeMask;
}

void IndicatorInterface::setPortNames(const std::map<std::string, uint8_t>& portNames) {
    _portNames = portNames;
    
    // Build reverse mapping
    _portNumbers.clear();
    for (const auto& pair : _portNames) {
        _portNumbers[pair.second] = pair.first;
    }
}

void IndicatorInterface::setPortName(const std::string& name, uint8_t portNumber) {
    if (portNumber > 15) return;
    
    _portNames[name] = portNumber;
    _portNumbers[portNumber] = name;
}

bool IndicatorInterface::writePort(const std::string& portName, bool state) {
    auto it = _portNames.find(portName);
    if (it == _portNames.end()) {
        return false;
    }
    return writePort(it->second, state);
}

bool IndicatorInterface::writePort(uint8_t portNumber, bool state) {
    if (portNumber > 15 || !isOutput(portNumber)) {
        return false;
    }
    
    // Apply mode logic (inversion if needed)
    bool actualState = _applyModeLogic(portNumber, state);
    
    // Update current state
    uint16_t newState = _currentState;
    
    // Always keep input pins HIGH
    for (int i = 0; i < 16; i++) {
        if (!isOutput(i)) {
            newState |= (1 << i);
        }
    }
    
    // Set the specific output pin
    if (actualState) {
        newState |= (1 << portNumber);
    } else {
        newState &= ~(1 << portNumber);
    }
    
    _writePCF(newState);
    return true;
}

void IndicatorInterface::writePorts(uint16_t portMask) {
    uint16_t newState = _currentState;
    
    // Apply direction mask - only write to outputs
    for (int i = 0; i < 16; i++) {
        if (isOutput(i)) {
            bool state = (portMask >> i) & 0x01;
            bool actualState = _applyModeLogic(i, state);
            
            if (actualState) {
                newState |= (1 << i);
            } else {
                newState &= ~(1 << i);
            }
        } else {
            // Keep input pins HIGH
            newState |= (1 << i);
        }
    }
    
    _writePCF(newState);
}

void IndicatorInterface::setAllOutputs(bool state) {
    uint16_t newState = _currentState;
    
    for (int i = 0; i < 16; i++) {
        if (isOutput(i)) {
            bool actualState = _applyModeLogic(i, state);
            
            if (actualState) {
                newState |= (1 << i);
            } else {
                newState &= ~(1 << i);
            }
        } else {
            // Keep input pins HIGH
            newState |= (1 << i);
        }
    }
    
    _writePCF(newState);
}

void IndicatorInterface::setAllOutputsHigh() {
    setAllOutputs(true);
}

void IndicatorInterface::setAllOutputsLow() {
    setAllOutputs(false);
}

uint16_t IndicatorInterface::getCurrentState() {
    if (_useInterrupts) {
        // In interrupt mode, state is updated automatically
        return _currentState;
    } else {
        // In polling mode, read current state
        if (millis() - _lastReadTime >= _pollInterval) {
            _updateState();
        }
        return _currentState;
    }
}

bool IndicatorInterface::readPort(const std::string& portName) {
    auto it = _portNames.find(portName);
    if (it == _portNames.end()) {
        return false;
    }
    return readPort(it->second);
}

bool IndicatorInterface::readPort(uint8_t portNumber) {
    if (portNumber > 15) {
        return false;
    }
    
    uint16_t currentState = getCurrentState();
    bool rawState = (currentState >> portNumber) & 0x01;
    
    // Apply mode logic (reverse inversion for reading)
    return _reverseModeLogic(portNumber, rawState);
}

bool IndicatorInterface::isOutput(uint8_t portNumber) {
    return (_directionMask >> portNumber) & 0x01;
}

bool IndicatorInterface::isInput(uint8_t portNumber) {
    return !isOutput(portNumber);
}

bool IndicatorInterface::isInverted(uint8_t portNumber) {
    return (_modeMask >> portNumber) & 0x01;
}

uint8_t IndicatorInterface::getPortNumber(const std::string& portName) {
    auto it = _portNames.find(portName);
    return (it != _portNames.end()) ? it->second : 255;
}

std::string IndicatorInterface::getPortName(uint8_t portNumber) {
    auto it = _portNumbers.find(portNumber);
    return (it != _portNumbers.end()) ? it->second : "";
}

// void IndicatorInterface::handleInterrupt() {
//     if (_interruptFlag) {
//         _interruptFlag = false;
//         _updateState();
//     }
// }

void IndicatorInterface::setInterruptCallback(void (*callback)(uint16_t currentState, uint16_t changedPins)) {
    _interruptCallback = callback;
}

void IndicatorInterface::printPortStates() {
    uint16_t state = getCurrentState();
    
    Serial.println("=== Port States ===");
    Serial.print("Raw state: 0x");
    Serial.println(state, HEX);
    
    for (int i = 15; i >= 0; i--) {
        bool rawState = (state >> i) & 0x01;
        bool logicalState = _reverseModeLogic(i, rawState);
        
        Serial.print("P");
        Serial.print(i);
        Serial.print(": ");
        Serial.print(rawState ? "HIGH" : "LOW");
        Serial.print(" (");
        Serial.print(isOutput(i) ? "OUT" : "IN");
        if (isInverted(i)) Serial.print(",INV");
        Serial.print(") = ");
        Serial.print(logicalState ? "TRUE" : "FALSE");
        
        std::string name = getPortName(i);
        if (!name.empty()) {
            Serial.print(" [");
            Serial.print(name.c_str());
            Serial.print("]");
        }
        Serial.println();
    }
}

void IndicatorInterface::printConfiguration() {
    Serial.println("=== Configuration ===");
    Serial.print("I2C Address: 0x");
    Serial.println(_pcf_i2cAddress, HEX);
    Serial.print("INT Pin: ");
    Serial.println(_intPin);
    Serial.print("Use Interrupts: ");
    Serial.println(_useInterrupts ? "YES" : "NO");
    Serial.print("Direction Mask: 0x");
    Serial.println(_directionMask, HEX);
    Serial.print("Mode Mask: 0x");
    Serial.println(_modeMask, HEX);
    
    Serial.println("Port Names:");
    for (const auto& pair : _portNames) {
        Serial.print("  ");
        Serial.print(pair.first.c_str());
        Serial.print(" = P");
        Serial.println(pair.second);
    }
}

// Private methods
void IndicatorInterface::_updateState() {
    uint16_t newState = _readPCF();
    uint16_t changedPins = _currentState ^ newState;
    
    _lastState = _currentState;
    _currentState = newState;
    _lastReadTime = millis();
    
    // Call interrupt callback if pins changed
    if (changedPins != 0 && _interruptCallback) {
        _interruptCallback(_currentState, changedPins);
    }
}

void IndicatorInterface::_clearInterrupt() {
    _pcf8575.read16();
    delay(1);
    _pcf8575.read16();
}

uint16_t IndicatorInterface::_readPCF() {
    return _pcf8575.read16();
}

void IndicatorInterface::_writePCF(uint16_t state) {
    _pcf8575.write16(state);
    delay(5);
    _clearInterrupt();
    _currentState = state;
}

bool IndicatorInterface::_applyModeLogic(uint8_t portNumber, bool state) {
    // Fixed: Normal mode = no inversion, Inverted mode = invert
    return isInverted(portNumber) ? !state : state;
}

bool IndicatorInterface::_reverseModeLogic(uint8_t portNumber, bool state) {
    // Fixed: For reading, apply same logic as writing
    return isInverted(portNumber) ? !state : state;
}

void IRAM_ATTR IndicatorInterface::_staticInterruptHandler() {
    if (_instance) {
        _instance->_interruptFlag = true;
    }
}


void IndicatorInterface::setPortInverted(const std::string& portName, bool inverted) {
    auto it = _portNames.find(portName);
    if (it != _portNames.end()) {
        setPortInverted(it->second, inverted);
    }
}

void IndicatorInterface::setPortInverted(uint8_t portNumber, bool inverted) {
    if (portNumber > 15) return;
    
    if (inverted) {
        _modeMask |= (1 << portNumber);   // Set bit to 1 for inverted
    } else {
        _modeMask &= ~(1 << portNumber);  // Set bit to 0 for normal
    }
}


void IndicatorInterface::_initOLED() {
    u8g2.enableUTF8Print();
    u8g2.clearBuffer();
    _calculateDisplayParams();
    u8g2.sendBuffer();
    _lastActivityTime = millis();
}

void IndicatorInterface::setOledSleepDelay(long sleepDelay) {
    _oledSleepDelay = sleepDelay;
    _wakeOLED();
}

void IndicatorInterface::setOledMode(int lines) {
    if (lines < 1) lines = 1;
    if (lines > 5) lines = 5;
    
    _oledLines = lines;
    _calculateDisplayParams();
    _wakeOLED();
}

void IndicatorInterface::printText(String buffer[], int bufferSize) {
    _textBufferSize = min(bufferSize, 5);
    
    for (int i = 0; i < _textBufferSize; i++) {
        // Only reset scroll offset if the text actually changed
        if (_textBuffer[i] != buffer[i]) {
            _textBuffer[i] = buffer[i];
            _scrollOffset[i] = 0; // Reset only when text changes
        }
    }
    
    // Clear unused lines
    for (int i = _textBufferSize; i < 5; i++) {
        _textBuffer[i] = "";
        _scrollOffset[i] = 0;
    }
    
    _lastActivityTime = millis();
    _wakeOLED();
    _updateOLEDDisplay();
}


void IndicatorInterface::setOLEDblink(int timeOn, int timeOff, bool blinkOn) {
    _oledBlink = blinkOn;
    _blinkTimeOn = timeOn;
    _blinkTimeOff = timeOff;
    _lastBlinkTime = millis();
    _blinkState = true;
    
    if (blinkOn) {
        _wakeOLED();
    }
}

void IndicatorInterface::setOLEDOff() {
    _oledOn = false;
    _oledBlink = false;
    u8g2.setPowerSave(1);
}

void IndicatorInterface::setOLEDOn() {
    _oledOn = true;
    _oledSleeping = false;
    u8g2.setPowerSave(0);
    _updateOLEDDisplay();
    _wakeOLED();
}

void IndicatorInterface::updateOLED() {
    if (!_oledOn) return;
    
    _handleOLEDSleep();
    if (_oledSleeping) return;
    
    // Handle special blinking first - if active, skip other operations
    if (_isBlinkingOK || _isBlinkingCross) {
        _handleSpecialBlink();
        return;  // Don't handle regular blink/scroll when special blinking
    }
    
    _handleOLEDBlink();
    _handleScrolling();
}

void IndicatorInterface::update() {
    updateBlinking();
    updateOLED();
}


// void IndicatorInterface::updateOLED() {
//     if (!_oledOn) return;
    
//     _handleOLEDSleep();
//     if (_oledSleeping) return;
    
//     _handleOLEDBlink();
//     _handleSpecialBlink();  // Add this line
//     _handleScrolling();
// }



void IndicatorInterface::_calculateDisplayParams() {
    int displayHeight = u8g2.getDisplayHeight(); // 64 pixels
    
    // Calculate optimal line height for each mode to use full display height
    switch (_oledLines) {
        case 1:
            // Use largest font and center it
            u8g2.setFont(u8g2_font_10x20_t_cyrillic);
            _lineHeight = displayHeight; // Full height for single line
            _charWidth = 10;
            _maxCharsPerLine = 12;
            break;
            
        case 2:
            // Use medium-large font
            //u8g2.setFont(u8g2_font_9x15_t_cyrillic);
            u8g2.setFont(u8g2_font_10x20_t_cyrillic);
            _lineHeight = displayHeight / 2; // 32px per line
            _charWidth = 9;
            _maxCharsPerLine = 14;
            break;
            
        case 3:
            // Use medium font
            //u8g2.setFont(u8g2_font_7x13_t_cyrillic);
            // u8g2.setFont(u8g2_font_9x15_t_cyrillic);
            u8g2.setFont(u8g2_font_10x20_t_cyrillic);
            _lineHeight = displayHeight / 3; // ~21px per line
            _charWidth = 7;
            _maxCharsPerLine = 18;
            break;
            
        case 4:
            // Use smaller font
            //u8g2.setFont(u8g2_font_5x7_t_cyrillic);
            u8g2.setFont(u8g2_font_9x15_t_cyrillic);
            _lineHeight = displayHeight / 4; // 16px per line
            _charWidth = 5;
            _maxCharsPerLine = 25;
            break;
            
        case 5:
        default:
            // Use smallest font
            u8g2.setFont(u8g2_font_9x15_t_cyrillic);
            // u8g2.setFont(u8g2_font_4x6_t_cyrillic);
            _lineHeight = displayHeight / 5; // ~12px per line
            _charWidth = 4;
            _maxCharsPerLine = 32;
            break;
    }
}


// void IndicatorInterface::_calculateDisplayParams() {
//     // Set font based on number of lines
//     switch (_oledLines) {
//         case 1:
//             u8g2.setFont(u8g2_font_10x20_t_cyrillic);
//             _lineHeight = 24;
//             _charWidth = 10;
//             _maxCharsPerLine = 12;
//             break;
//         case 2:
//             u8g2.setFont(u8g2_font_9x15_t_cyrillic);
//             _lineHeight = 20;
//             _charWidth = 9;
//             _maxCharsPerLine = 14;
//             break;
//         case 3:
//             u8g2.setFont(u8g2_font_7x13_t_cyrillic);
//             _lineHeight = 16;
//             _charWidth = 7;
//             _maxCharsPerLine = 18;
//             break;
//         case 4:
//             u8g2.setFont(u8g2_font_5x7_t_cyrillic);
//             _lineHeight = 12;
//             _charWidth = 6;
//             _maxCharsPerLine = 21;
//             break;
//         case 5:
//         default:
//             u8g2.setFont(u8g2_font_4x6_t_cyrillic);
//             _lineHeight = 10;
//             _charWidth = 5;
//             _maxCharsPerLine = 25;
//             break;
//     }
// }

void IndicatorInterface::_updateOLEDDisplay() {
    if (!_oledOn || _oledSleeping) return;
    
    u8g2.clearBuffer();
    _calculateDisplayParams();
    
    // Set font position to top for consistent positioning
    u8g2.setFontPosTop();
    
    int displayHeight = u8g2.getDisplayHeight(); // 64 pixels
    
    for (int i = 0; i < _oledLines && i < _textBufferSize; i++) {
        int yPos;
        
        if (_oledLines == 1) {
            // Center single line vertically
            int fontHeight = u8g2.getFontAscent() - u8g2.getFontDescent();
            yPos = (displayHeight - fontHeight) / 2;
        } else {
            // Distribute lines evenly across display height
            yPos = (i * displayHeight) / _oledLines;
        }
        
        _drawTextLine(i, yPos);
    }
    
    u8g2.sendBuffer();
}


void IndicatorInterface::_drawTextLine(int lineIndex, int yPos) {
    if (lineIndex >= _textBufferSize) return;
    
    String text = _textBuffer[lineIndex];
    int textLength = text.length();
    
    if (textLength <= _maxCharsPerLine) {
        // Short text - display normally
        u8g2.drawStr(0, yPos, text.c_str());
    } else {
        // Long text - apply scrolling
        int offset = _scrollOffset[lineIndex];
        String displayText;
        
        if (offset < 0) {
            // Smooth entry from left with spaces
            int spaceCount = -offset;
            displayText = String(' ', spaceCount) + text;
            displayText = displayText.substring(0, _maxCharsPerLine);
        } else if (offset <= textLength - _maxCharsPerLine) {
            // Normal scrolling within text
            displayText = text.substring(offset, offset + _maxCharsPerLine);
        } else {
            // Smooth exit with trailing spaces
            int spaceCount = offset - (textLength - _maxCharsPerLine);
            displayText = text.substring(textLength - _maxCharsPerLine);
            displayText += String(' ', min(spaceCount, _maxCharsPerLine));
            displayText = displayText.substring(0, _maxCharsPerLine);
        }
        
        u8g2.drawStr(0, yPos, displayText.c_str());
    }
}





void IndicatorInterface::_handleOLEDSleep() {
    if (_oledSleepDelay < 0) return;  // Never sleep
    
    if (!_oledSleeping && (millis() - _lastActivityTime) > _oledSleepDelay) {
        _oledSleeping = true;
        u8g2.setPowerSave(1);
    }
}

void IndicatorInterface::_handleOLEDBlink() {
    if (!_oledBlink || _oledSleeping) return;
    
    unsigned long currentTime = millis();
    unsigned long elapsed = currentTime - _lastBlinkTime;
    
    if (_blinkState && elapsed > _blinkTimeOn) {
        // Turn off
        u8g2.setPowerSave(1);
        _blinkState = false;
        _lastBlinkTime = currentTime;
    } else if (!_blinkState && elapsed > _blinkTimeOff) {
        // Turn on
        u8g2.setPowerSave(0);
        _updateOLEDDisplay();
        _blinkState = true;
        _lastBlinkTime = currentTime;
    }
}

void IndicatorInterface::_handleScrolling() {
    if (millis() - _lastScrollTime < _scrollDelay) return;
    
    bool needsUpdate = false;
    
    for (int i = 0; i < _textBufferSize; i++) {
        int textLength = _textBuffer[i].length();
        
        if (textLength > _maxCharsPerLine) {
            _scrollOffset[i]++;
            
            // Add pause at the end before wrapping - this prevents immediate reset
            int maxScroll = textLength - _maxCharsPerLine + 5; // +5 for pause at end
            
            if (_scrollOffset[i] > maxScroll) {
                _scrollOffset[i] = 0; // Start from negative for smooth entry
            }
            needsUpdate = true;
        } else {
            // Only reset offset for short lines
            _scrollOffset[i] = 0;
        }
    }
    
    if (needsUpdate) {
        _lastScrollTime = millis();
        _updateOLEDDisplay();
    }
}



void IndicatorInterface::_wakeOLED() {
    if (_oledOn) {
        _lastActivityTime = millis();
        _oledSleeping = false;
        u8g2.setPowerSave(0);
    }
}

// Modify existing handleInterrupt() method to wake OLED:
void IndicatorInterface::handleInterrupt() {
    if (_interruptFlag) {
        _interruptFlag = false;
        _updateState();
        _wakeOLED();  // Wake OLED on any interrupt
    }
}

// Add this method to IndicatorInterface.cpp
// void IndicatorInterface::_fixSH1106Offset() {
//     // Set column start address to 2 for SH1106
//     u8g2.sendF("ca", 0x10 | 0, 0x10 | 2);  // Set lower and higher column start address
// }

void IndicatorInterface::pushLine(String newLine) {
    // Shift all lines down
    for (int i = 4; i > 0; i--) {
        _textBuffer[i] = _textBuffer[i-1];
    }
    
    // Add new line at the top
    _textBuffer[0] = newLine;
    
    // Ensure we have the right number of lines
    if (_textBufferSize < _oledLines) {
        _textBufferSize++;
    } else {
        _textBufferSize = _oledLines;
    }
    
    // Reset scroll offsets
    for (int i = 0; i < 5; i++) {
        _scrollOffset[i] = 0;
    }
    
    _updateOLEDDisplay();
    _wakeOLED();
}

void IndicatorInterface::displayOK() {
    // Remove this line: stopBlinking(); // Stop any current blinking
    
    u8g2.clearBuffer();
    
    // Use the largest available font for OK
    u8g2.setFont(u8g2_font_logisoso42_tf);
    u8g2.setFontPosCenter();
    
    // Calculate center position
    int displayWidth = u8g2.getDisplayWidth();
    int displayHeight = u8g2.getDisplayHeight();
    
    String okText = "OK";
    int textWidth = u8g2.getUTF8Width(okText.c_str());
    
    int x = (displayWidth - textWidth) / 2;
    int y = displayHeight / 2;
    
    // Draw OK in center
    u8g2.drawUTF8(x, y + 5, okText.c_str());
    
    // Add a border around OK
    u8g2.drawFrame(x - 5, y - u8g2.getFontAscent() / 2 - 5, 
                   textWidth + 10, u8g2.getFontAscent() + u8g2.getFontDescent() + 20);
    
    u8g2.sendBuffer();
    _wakeOLED();
}

void IndicatorInterface::displayCross() {
    u8g2.clearBuffer();
    
    int displayWidth = u8g2.getDisplayWidth();
    int displayHeight = u8g2.getDisplayHeight();
    
    // Calculate center and radius for circle
    int centerX = displayWidth / 2;
    int centerY = displayHeight / 2;
    int radius = min(displayWidth, displayHeight) / 2 - 4;
    
    // Draw thicker circle by drawing multiple concentric circles
    for (int r = radius; r > radius - 3; r--) {
        u8g2.drawCircle(centerX, centerY, r);
    }
    
    // Cross parameters - made smaller
    int crossSize = (radius * 5) / 10;  // Reduced from 70% to 50% of radius
    int thickness = 4;  // Cross arm thickness
    int halfThickness = thickness / 2;
    
    // Draw main diagonal (top-left to bottom-right)
    for (int i = -crossSize; i <= crossSize; i++) {
        int x1 = centerX + i - halfThickness;
        int y1 = centerY + i - halfThickness;
        
        // Draw small filled rectangles along the diagonal
        u8g2.drawBox(x1, y1, thickness, thickness);
    }
    
    // Draw anti-diagonal (top-right to bottom-left)
    for (int i = -crossSize; i <= crossSize; i++) {
        int x1 = centerX + i - halfThickness;
        int y1 = centerY - i - halfThickness;
        
        // Draw small filled rectangles along the anti-diagonal
        u8g2.drawBox(x1, y1, thickness, thickness);
    }
    
    u8g2.sendBuffer();
    _wakeOLED();
}

// void IndicatorInterface::displayCross() {
//     // Remove this line: stopBlinking(); // Stop any current blinking
    
//     u8g2.clearBuffer();
    
//     int displayWidth = u8g2.getDisplayWidth();
//     int displayHeight = u8g2.getDisplayHeight();
    
//     // Calculate center and radius for circle
//     int centerX = displayWidth / 2;
//     int centerY = displayHeight / 2;
//     int radius = min(displayWidth, displayHeight) / 2 - 4;
    
//     // Draw circle
//     u8g2.drawCircle(centerX, centerY, radius);
    
//     // Draw cross inside circle
//     int crossSize = radius - 8;
    
//     // Draw X (cross) - make it thicker
//     for (int offset = -1; offset <= 1; offset++) {
//         u8g2.drawLine(centerX - crossSize + offset, centerY - crossSize, 
//                       centerX + crossSize + offset, centerY + crossSize);
//         u8g2.drawLine(centerX + crossSize + offset, centerY - crossSize, 
//                       centerX - crossSize + offset, centerY + crossSize);
//         u8g2.drawLine(centerX - crossSize, centerY - crossSize + offset, 
//                       centerX + crossSize, centerY + crossSize + offset);
//         u8g2.drawLine(centerX + crossSize, centerY - crossSize + offset, 
//                       centerX - crossSize, centerY + crossSize + offset);
//     }
    
//     u8g2.sendBuffer();
//     _wakeOLED();
// }


void IndicatorInterface::blinkOK(int blinkDelay) {
    // Stop any regular OLED blinking first
    _oledBlink = false;
    
    _saveCurrentText();
    _isBlinkingOK = true;
    _isBlinkingCross = false;
    _blinkDelayTime = blinkDelay;
    _lastBlinkToggle = millis();
    _blinkShowSpecial = true;
    
    displayOK();  // Start with OK showing
}

void IndicatorInterface::blinkCross(int blinkDelay) {
    // Stop any regular OLED blinking first
    _oledBlink = false;
    
    _saveCurrentText();
    _isBlinkingOK = false;
    _isBlinkingCross = true;
    _blinkDelayTime = blinkDelay;
    _lastBlinkToggle = millis();
    _blinkShowSpecial = true;
    
    displayCross();  // Start with cross showing
}


void IndicatorInterface::stopBlinking() {
    _isBlinkingOK = false;
    _isBlinkingCross = false;
    _restoreCurrentText();
}

void IndicatorInterface::_saveCurrentText() {
    // Save current text buffer
    for (int i = 0; i < 5; i++) {
        _savedTextBuffer[i] = _textBuffer[i];
    }
    _savedTextBufferSize = _textBufferSize;
    _savedOledLines = _oledLines;
}

void IndicatorInterface::_restoreCurrentText() {
    // Restore saved text buffer
    for (int i = 0; i < 5; i++) {
        _textBuffer[i] = _savedTextBuffer[i];
    }
    _textBufferSize = _savedTextBufferSize;
    _oledLines = _savedOledLines;
    
    _updateOLEDDisplay();
}

void IndicatorInterface::_handleSpecialBlink() {
    if (!_isBlinkingOK && !_isBlinkingCross) return;
    
    unsigned long currentTime = millis();
    if (currentTime - _lastBlinkToggle >= _blinkDelayTime) {
        _blinkShowSpecial = !_blinkShowSpecial;
        _lastBlinkToggle = currentTime;
        
        if (_blinkShowSpecial) {
            // Show OK or Cross
            if (_isBlinkingOK) {
                displayOK();
            } else if (_isBlinkingCross) {
                displayCross();
            }
        } else {
            // Show original text
            _restoreCurrentText();
        }
    }
}



void IndicatorInterface::startBlinking(const std::string& portName, unsigned long onTime, unsigned long offTime) {
    LoggerManager::info("INDICATION", 
        String(portName.c_str()) + " start blinking");
    // Check if port is already blinking
    for (auto& blinkPort : _blinkingPorts) {
        if (blinkPort.portName == portName) {
            // Update existing blinking parameters
            blinkPort.onTime = onTime;
            blinkPort.offTime = offTime;
            blinkPort.isActive = true;
            return;
        }
    }
    
    // Add new blinking port
    BlinkingPort newBlink;
    newBlink.portName = portName;
    newBlink.onTime = onTime;
    newBlink.offTime = offTime;
    newBlink.lastToggleTime = millis();
    newBlink.currentState = true;  // Start with ON
    newBlink.isActive = true;
    
    _blinkingPorts.push_back(newBlink);
    
    // Set initial state to ON
    writePort(portName, true);
}

void IndicatorInterface::stopBlinking(const std::string& portName) {
    LoggerManager::info("INDICATION", 
        String(portName.c_str()) + " stop blinking");
    for (auto it = _blinkingPorts.begin(); it != _blinkingPorts.end(); ++it) {
        if (it->portName == portName) {
            it->isActive = false;
            // Turn off the port when stopping blink
            writePort(portName, false);
            _blinkingPorts.erase(it);
            return;
        }
    }
}

void IndicatorInterface::updateBlinking() {
    unsigned long currentTime = millis();
    
    for (auto& blinkPort : _blinkingPorts) {
        if (!blinkPort.isActive) continue;
        
        unsigned long elapsed = currentTime - blinkPort.lastToggleTime;
        unsigned long targetTime = blinkPort.currentState ? blinkPort.onTime : blinkPort.offTime;
        
        if (elapsed >= targetTime) {
            // Toggle state
            blinkPort.currentState = !blinkPort.currentState;
            blinkPort.lastToggleTime = currentTime;
            
            // Update hardware
            writePort(blinkPort.portName, blinkPort.currentState);
        }
    }
}

bool IndicatorInterface::isBlinking(const std::string& portName) {
    for (const auto& blinkPort : _blinkingPorts) {
        if (blinkPort.portName == portName && blinkPort.isActive) {
            return true;
        }
    }
    return false;
}

-------- [ Separator ] ------

File Name: src/LoggerManager.cpp
Size: 63.11 KB
Code:
#include "LoggerManager.h"
#include "TemperatureController.h"  // Full include in .cpp file
#include "MeasurementPoint.h"       // Add this include


LoggerManager* LoggerManager::_instance = nullptr;

LoggerManager::LoggerManager(TemperatureController& controller, TimeManager& timeManager, fs::FS& filesystem)
    : _controller(&controller), _timeManager(&timeManager), _fs(&filesystem),
      _logFrequency(60000), _lastLogTime(0), _headerWritten(false),
      _enabled(true), _logDirectory(""), _dailyFiles(true), _lastError(""),
      _lastGeneratedHeader(""), _headerChanged(false), _fileSequenceNumber(0),
      _eventLoggingEnabled(true), _eventLogDirectory(""), _currentEventLogFile(""), _lastEventLogDate(""),
      _alarmStateLoggingEnabled(true), _alarmStateLogDirectory(""), _currentAlarmStateLogFile(""), _lastAlarmStateLogDate("") {
        _instance = this;
}


LoggerManager::~LoggerManager() {
    closeCurrentFile();
}

bool LoggerManager::begin() {
    if (!_enabled) return false;
    if(_enabled) {
    if (!_ensureDirectoryExists()) {
        _lastError = "Failed to create log directory";
        return false;
    }
    
    // Recover from existing files after reboot
    if (!_recoverFromExistingFiles()) {
        Serial.println("Warning: Could not recover from existing files, starting fresh");
        // Initialize fresh
        _fileSequenceNumber = 0;
        _headerWritten = false;
    }
    
    // Generate current header for comparison
    _lastGeneratedHeader = _generateCSVHeader();
    
    // Generate log file name with recovered sequence number
    _currentLogFile = _generateLogFileNameWithSequence();
    _lastLogDate = _getCurrentDateString();
   
    // Initialize alarm state logging
    if (_alarmStateLoggingEnabled) {
        _lastAlarmStateLogDate = _getCurrentDateString();
        _currentAlarmStateLogFile = _generateAlarmStateLogFileName();
        
        if (!_ensureAlarmStateLogExists()) {
            Serial.println("Warning: Could not initialize alarm state log file");
        } else {
            Serial.printf("Alarm state logging initialized. Log file: %s\n", _currentAlarmStateLogFile.c_str());
            logInfo("SYSTEM", "LoggerManager alarm state logging initialized successfully");
        }
    }
    
    Serial.printf("LoggerManager initialized. Log file: %s\n", _currentLogFile.c_str());
    Serial.printf("File sequence number: %d\n", _fileSequenceNumber);
    Serial.printf("Log frequency: %lu ms\n", _logFrequency);
    } else {
        Serial.println("No SD card");
        _enabled = false;
        return false;
    }
    
    return true;
}

bool LoggerManager::init() {
    //if (!_enabled) return false;
    if(_enabled) {

    if (!_ensureDirectoryExists()) {
        _lastError = "Failed to create log directory";
        return false;
    }
    
    // Initialize event logging
    if (_eventLoggingEnabled) {
        _lastEventLogDate = _getCurrentDateString();
        _currentEventLogFile = _generateEventLogFileName();
        
        if (!_ensureEventLogExists()) {
            Serial.println("Warning: Could not initialize event log file");
        } else {
            Serial.printf("Event logging initialized. Event log file: %s\n", _currentEventLogFile.c_str());
            
            // Log system startup event
            logInfo("SYSTEM", "LoggerManager event logging initialized successfully");
        }
    }
    
    Serial.printf("LoggerManager event logging initialized. Log file: %s\n", _currentLogFile.c_str());
    } else {
        Serial.println("No SD card");
        _enabled = false;
        return false;
        

    }
    
    return true;
}



void LoggerManager::setLogFrequency(unsigned long frequencyMs) {
    if (frequencyMs < 1000) frequencyMs = 1000; // Minimum 1 second
    _logFrequency = frequencyMs;
    Serial.printf("Log frequency set to %lu ms\n", _logFrequency);
}

unsigned long LoggerManager::getLogFrequency() const {
    return _logFrequency;
}

void LoggerManager::setEnabled(bool enabled) {
    _enabled = enabled;
    Serial.printf("Logging %s\n", enabled ? "enabled" : "disabled");
}

bool LoggerManager::isEnabled() const {
    return _enabled;
}

void LoggerManager::setDailyFiles(bool enabled) {
    _dailyFiles = enabled;
}

bool LoggerManager::isDailyFiles() const {
    return _dailyFiles;
}

void LoggerManager::setLogDirectory(const String& directory) {
    _logDirectory = directory;
    if (!_logDirectory.startsWith("/")) {
        _logDirectory = "/" + _logDirectory;
    }
}

String LoggerManager::getLogDirectory() {
    return _instance->_logDirectory;
}

void LoggerManager::update() {
    if (!_enabled) return;
    
    unsigned long currentTime = millis();
    
    // Check if it's time to log temperature data
    if (currentTime - _lastLogTime >= _logFrequency) {
        // Check if we need new daily files
        if (_dailyFiles) {
            String currentDate = _getCurrentDateString();
            if (currentDate != _lastLogDate) {
                // New day - recover from existing files for new date
                _recoverFromExistingFiles();
                _lastLogDate = currentDate;
                
                // Also update event log file for new day
                if (_eventLoggingEnabled && currentDate != _lastEventLogDate) {
                    _lastEventLogDate = currentDate;
                    _currentEventLogFile = _generateEventLogFileName();
                    logInfo("SYSTEM", "New day - event log file created: " + _currentEventLogFile);
                }
            }
        }
        
        // Check if header has changed (point names changed)
        if (_hasHeaderChanged()) {
            Serial.println("Header changed - creating new log file");
            _incrementSequenceNumber();
            createNewLogFile();
            
            // Log the configuration change event
            if (_eventLoggingEnabled) {
                logWarning("CONFIG", "Measurement point configuration changed - new data log file created");
            }
        }
        
        logDataNow();
    }
}




bool LoggerManager::logDataNow() {
    if (!_enabled) return false;
    
    // Write header if this is a new file
    if (!_headerWritten) {
        if (!_writeHeader()) {
            return false;
        }
        _headerWritten = true;
    }
    
    // Write data row
    if (!_writeDataRow()) {
        return false;
    }
    
    _lastLogTime = millis();
    return true;
}




String LoggerManager::getCurrentLogFile() const {
    return _currentLogFile;
}

bool LoggerManager::closeCurrentFile() {
    // SD library automatically handles file closing
    return true;
}

unsigned long LoggerManager::getLastLogTime() const {
    return _lastLogTime;
}

String LoggerManager::getLastError() const {
    return _lastError;
}

// Private methods implementation

String LoggerManager::_generateLogFileName() {
    String dateStr = _getCurrentDateString();
    return _generateLogFileNameWithSequence();
}

String LoggerManager::_generateLogFileNameWithSequence() {
    
    String dateStr = _getCurrentDateString();
    String filename;
    
    // Always ensure we have a valid path starting with /
    if (_logDirectory.isEmpty()) {
        filename = "/temp_log_" + dateStr + "_" + String(_fileSequenceNumber) + ".csv";
    } else {
        // Ensure _logDirectory starts with /
        String dir = _logDirectory;
        if (!dir.startsWith("/")) {
            dir = "/" + dir;
        }
        filename = dir + "/temp_log_" + dateStr + "_" + String(_fileSequenceNumber) + ".csv";
    }
    
    return filename;
}



String LoggerManager::_generateCSVHeader() {
    String header = "Date,Time";
    
    // Add all 60 measurement points (0-59)
    for (int i = 0; i < 60; i++) {
        MeasurementPoint* point = _controller->getMeasurementPoint(i);
        if (point) {
            String pointName = point->getName();
            if (pointName.isEmpty()) {
                pointName = "Point_" + String(i);
            }
            header += "," + String(i) + "." + _escapeCSVField(pointName);
        } else {
            header += "," + String(i) + ".Point_" + String(i);
        }
    }
    
    header += "\n";
    return header;
}

bool LoggerManager::_writeHeader() {
    if (!_enabled) return false;
    File file = _fs->open(_currentLogFile.c_str(), FILE_WRITE);
    if (!file) {
        _lastError = "Failed to open log file for header writing: " + _currentLogFile;
        return false;
    }
    
    String header = _generateCSVHeader();
    size_t written = file.print(header);
    file.close();
    
    if (written != header.length()) {
        _lastError = "Failed to write complete header";
        return false;
    }
    
    Serial.printf("Header written to %s\n", _currentLogFile.c_str());
    return true;
}

bool LoggerManager::_writeDataRow() {
    if (!_enabled) return false;
    File file = _fs->open(_currentLogFile.c_str(), FILE_APPEND);
    if (!file) {
        _lastError = "Failed to open log file for data writing: " + _currentLogFile;
        return false;
    }
    
    // Build data row
    String dataRow = _getCurrentDateString() + "," + _getCurrentTimeString();
    
    // Add temperature data for all 60 points
    for (int i = 0; i < 60; i++) {
        MeasurementPoint* point = _controller->getMeasurementPoint(i);
        if (point && point->getBoundSensor()) {
            // Point has a bound sensor, log actual temperature
            dataRow += "," + String(point->getCurrentTemp());
        } else {
            // No bound sensor, log empty value
            dataRow += ",";
        }
    }
    
    dataRow += "\n";
    
    size_t written = file.print(dataRow);
    file.close();
    
    if (written != dataRow.length()) {
        _lastError = "Failed to write complete data row";
        return false;
    }
    
    return true;
}

String LoggerManager::_escapeCSVField(const String& field) {
    if (field.indexOf(',') >= 0 || field.indexOf('"') >= 0 || field.indexOf('\n') >= 0) {
        String escaped = "\"";
        for (int i = 0; i < field.length(); i++) {
            if (field.charAt(i) == '"') {
                escaped += "\"\"";
            } else {
                escaped += field.charAt(i);
            }
        }
        escaped += "\"";
        return escaped;
    }
    return field;
}

bool LoggerManager::_ensureDirectoryExists() {
    if (!_enabled) return false;
    // For SD card, always use root directory
    if (_logDirectory.isEmpty() || _logDirectory == "/") {
        return true; // Root directory always exists
    }
    
    // Try to check if custom directory exists, but don't fail if it doesn't
    File dir = _fs->open(_logDirectory.c_str());
    if (!dir) {
        Serial.printf("Directory %s does not exist, using root directory\n", _logDirectory.c_str());
        _logDirectory = ""; // Fall back to root
        return true;
    }
    
    if (!dir.isDirectory()) {
        dir.close();
        Serial.printf("Path %s exists but is not a directory, using root\n", _logDirectory.c_str());
        _logDirectory = ""; // Fall back to root
        return true;
    }
    
    dir.close();
    return true;
}

String LoggerManager::_getCurrentDateString() {
    if (_timeManager && _timeManager->isTimeSet()) {
        return _timeManager->getDateString(); // Assuming this method exists
    } else {
        // Fallback to millis-based date
        unsigned long days = millis() / (24UL * 60UL * 60UL * 1000UL);
        return "Day_" + String(days);
    }
}

String LoggerManager::_getCurrentTimeString() {
    if (_timeManager && _timeManager->isTimeSet()) {
        return _timeManager->getTimeString(); // Assuming this method exists
    } else {
        // Fallback to millis-based time
        unsigned long totalSeconds = (millis() / 1000) % (24 * 60 * 60);
        int hours = totalSeconds / 3600;
        int minutes = (totalSeconds % 3600) / 60;
        int seconds = totalSeconds % 60;
        
        char timeStr[9];
        sprintf(timeStr, "%02d:%02d:%02d", hours, minutes, seconds);
        return String(timeStr);
    }
}



bool LoggerManager::deleteLogFile(const String& filename) {
    if (!_enabled) return false;
    String fullPath = _logDirectory + "/" + filename;
    return _fs->remove(fullPath.c_str());
}

size_t LoggerManager::getLogFileSize() const {
    if (!_enabled) return -1;
    File file = _fs->open(_currentLogFile.c_str(), FILE_READ);
    if (!file) return 0;
    
    size_t size = file.size();
    file.close();
    return size;
}


bool LoggerManager::_hasHeaderChanged() {
    String currentHeader = _generateCSVHeader();
    
    // If this is the first time, store the header
    if (_lastGeneratedHeader.isEmpty()) {
        _lastGeneratedHeader = currentHeader;
        return false;
    }
    
    // Compare with last generated header
    if (currentHeader != _lastGeneratedHeader) {
        Serial.println("Header change detected:");
        Serial.println("Old header: " + _lastGeneratedHeader);
        Serial.println("New header: " + currentHeader);
        
        _lastGeneratedHeader = currentHeader;
        return true;
    }
    
    return false;
}

void LoggerManager::_incrementSequenceNumber() {
    _fileSequenceNumber++;
    Serial.printf("File sequence number incremented to: %d\n", _fileSequenceNumber);
}





void LoggerManager::forceNewFile() {
    if (!_enabled) return;
    _incrementSequenceNumber();
    createNewLogFile();
    Serial.println("Manually forced new log file creation");
}

int LoggerManager::getCurrentSequenceNumber() const {
    return _fileSequenceNumber;
}

void LoggerManager::resetSequenceNumber() {
    _fileSequenceNumber = 0;
    Serial.println("File sequence number reset to 0");
}

bool LoggerManager::_recoverFromExistingFiles() {
    if (!_enabled) return false;
    String currentDate = _getCurrentDateString();
    
    // Find all files for today
    std::vector<String> todaysFiles = _getFilesForDate(currentDate);
    
    if (todaysFiles.empty()) {
        // No files for today, start fresh
        _fileSequenceNumber = 0;
        _headerWritten = false;
        Serial.printf("No existing files for date %s, starting with sequence 0\n", currentDate.c_str());
        return true;
    }
    
    // Find the highest sequence number for today
    int highestSequence = _findHighestSequenceForDate(currentDate);
    
    // Find the latest file (highest sequence number)
    String latestFile = _findLatestFileForDate(currentDate);
    
    if (latestFile.isEmpty()) {
        // Couldn't find latest file, start fresh
        _fileSequenceNumber = 0;
        _headerWritten = false;
        Serial.println("Could not determine latest file, starting fresh");
        return false;
    }
    
    // Read header from latest file
    String existingHeader = _readHeaderFromFile(latestFile);
    String currentHeader = _generateCSVHeader();
    
    if (existingHeader.isEmpty()) {
        // Could not read header, assume file is incomplete
        _fileSequenceNumber = highestSequence;
        _headerWritten = false;
        Serial.printf("Could not read header from %s, will rewrite\n", latestFile.c_str());
        return true;
    }
    
    // Compare headers
    if (existingHeader == currentHeader) {
        // Headers match, continue with existing file
        _fileSequenceNumber = highestSequence;
        _headerWritten = true;
        _currentLogFile = latestFile;
        Serial.printf("Recovered: Using existing file %s (sequence %d)\n", 
                     latestFile.c_str(), _fileSequenceNumber);
        return true;
    } else {
        // Headers don't match, need new file
        _fileSequenceNumber = highestSequence + 1;
        _headerWritten = false;
        Serial.printf("Header changed, creating new file with sequence %d\n", _fileSequenceNumber);
        Serial.println("Old header: " + existingHeader);
        Serial.println("New header: " + currentHeader);
        return true;
    }
}

std::vector<String> LoggerManager::_getFilesForDate(const String& dateStr) {

    std::vector<String> files;
    
    // Open directory (root if _logDirectory is empty)
    String dirPath = _logDirectory.isEmpty() ? "/" : _logDirectory;
    File dir = _fs->open(dirPath.c_str());
    
    if (!dir || !dir.isDirectory()) {
        Serial.printf("Could not open directory: %s\n", dirPath.c_str());
        return files;
    }
    
    // Pattern to match: temp_log_YYYY-MM-DD_N.csv
    String pattern = "temp_log_" + dateStr + "_";
    
    File file = dir.openNextFile();
    while (file) {
        String filename = String(file.name());
        
        // Check if filename matches our pattern and is a CSV file
        if (filename.startsWith(pattern) && filename.endsWith(".csv")) {
            String fullPath = dirPath;
            if (!fullPath.endsWith("/")) fullPath += "/";
            fullPath += filename;
            files.push_back(fullPath);
        }
        
        file = dir.openNextFile();
    }
    
    dir.close();
    
    Serial.printf("Found %d files for date %s\n", files.size(), dateStr.c_str());
    return files;
}

int LoggerManager::_findHighestSequenceForDate(const String& dateStr) {
    std::vector<String> files = _getFilesForDate(dateStr);
    int highestSequence = -1;
    
    for (const String& filepath : files) {
        int sequence = _extractSequenceNumber(filepath);
        if (sequence > highestSequence) {
            highestSequence = sequence;
        }
    }
    
    return highestSequence >= 0 ? highestSequence : 0;
}

String LoggerManager::_findLatestFileForDate(const String& dateStr) {
    std::vector<String> files = _getFilesForDate(dateStr);
    String latestFile = "";
    int highestSequence = -1;
    
    for (const String& filepath : files) {
        int sequence = _extractSequenceNumber(filepath);
        if (sequence > highestSequence) {
            highestSequence = sequence;
            latestFile = filepath;
        }
    }
    
    return latestFile;
}

int LoggerManager::_extractSequenceNumber(const String& filename) {
    // Extract sequence number from filename like: temp_log_2025-06-15_3.csv
    int lastUnderscore = filename.lastIndexOf('_');
    int dotIndex = filename.lastIndexOf('.');
    
    if (lastUnderscore == -1 || dotIndex == -1 || lastUnderscore >= dotIndex) {
        return -1; // Invalid format
    }
    
    String sequenceStr = filename.substring(lastUnderscore + 1, dotIndex);
    return sequenceStr.toInt();
}

String LoggerManager::_readHeaderFromFile(const String& filename) {

    File file = _fs->open(filename.c_str(), FILE_READ);
    if (!file) {
        Serial.printf("Could not open file for header reading: %s\n", filename.c_str());
        return "";
    }
    
    // Read first line (header)
    String header = "";
    while (file.available()) {
        char c = file.read();
        if (c == '\n') {
            break;
        }
        header += c;
    }
    
    file.close();
    
    // Add newline back for comparison
    if (!header.isEmpty()) {
        header += "\n";
    }
    
    return header;
}


bool LoggerManager::createNewLogFile() {
    if (!_enabled) return false;
    closeCurrentFile();
    
    // Generate new filename with current sequence number
    _currentLogFile = _generateLogFileNameWithSequence();
    _headerWritten = false;
    
    // Update the stored header to current state
    _lastGeneratedHeader = _generateCSVHeader();
    
    Serial.printf("Created new log file: %s (sequence: %d)\n", 
                 _currentLogFile.c_str(), _fileSequenceNumber);
    return true;
}



// Event logging configuration methods
void LoggerManager::setEventLoggingEnabled(bool enabled) {
    _eventLoggingEnabled = enabled;
    Serial.printf("Event logging %s\n", enabled ? "enabled" : "disabled");
}

bool LoggerManager::isEventLoggingEnabled() const {
    return _eventLoggingEnabled;
}

void LoggerManager::setEventLogDirectory(const String& directory) {
    _eventLogDirectory = directory;
    if (!_eventLogDirectory.startsWith("/")) {
        _eventLogDirectory = "/" + _eventLogDirectory;
    }
}

String LoggerManager::getEventLogDirectory() const {
    return _eventLogDirectory;
}

// Main event logging method
bool LoggerManager::logEvent(const String& source, const String& description, const String& priority) {
    if (!_enabled) return false;
    if (!_eventLoggingEnabled) return false;
    
    // Check if we need a new event log file for today
    String currentDate = _getCurrentDateString();
    if (currentDate != _lastEventLogDate) {
        _lastEventLogDate = currentDate;
        _currentEventLogFile = _generateEventLogFileName();
    }
    
    // Ensure event log file exists
    if (!_ensureEventLogExists()) {
        return false;
    }
    
    // Generate timestamp
    String timestamp = _getCurrentDateString() + " " + _getCurrentTimeString();
    
    // Write event row
    return _writeEventRow(timestamp, source, description, priority);
}

// Convenience methods for different priority levels
bool LoggerManager::logInfo(const String& source, const String& description) {
    if (!_enabled) return false;
    return logEvent(source, description, "INFO");
}

bool LoggerManager::logWarning(const String& source, const String& description) {
    if (!_enabled) return false;
    return logEvent(source, description, "WARNING");
}

bool LoggerManager::logError(const String& source, const String& description) {
    if (!_enabled) return false;
    return logEvent(source, description, "ERROR");
}

bool LoggerManager::logCritical(const String& source, const String& description) {
    if (!_enabled) return false;
    return logEvent(source, description, "CRITICAL");
}

// Event log file management
String LoggerManager::getCurrentEventLogFile() const {
    return _currentEventLogFile;
}

std::vector<String> LoggerManager::getEventLogFiles() {

    std::vector<String> files;
    
    String dirPath = _eventLogDirectory.isEmpty() ? "/" : _eventLogDirectory;
    File dir = _fs->open(dirPath.c_str());
    
    if (!dir || !dir.isDirectory()) {
        return files;
    }
    
    File file = dir.openNextFile();
    while (file) {
        String filename = String(file.name());
        if (filename.startsWith("events_") && filename.endsWith(".csv")) {
            String fullPath = dirPath;
            if (!fullPath.endsWith("/")) fullPath += "/";
            fullPath += filename;
            files.push_back(fullPath);
        }
        file = dir.openNextFile();
    }
    
    dir.close();
    return files;
}

bool LoggerManager::deleteEventLogFile(const String& filename) {
    if (!_enabled) return false;
    String fullPath = _eventLogDirectory.isEmpty() ? "/" : _eventLogDirectory;
    if (!fullPath.endsWith("/")) fullPath += "/";
    fullPath += filename;
    return _fs->remove(fullPath.c_str());
}

// Private event logging methods
String LoggerManager::_generateEventLogFileName() {
    String dateStr = _getCurrentDateString();
    String filename;
    
    if (_eventLogDirectory.isEmpty()) {
        filename = "/events_" + dateStr + ".csv";  // Always start with /
    } else {
        String dir = _eventLogDirectory;
        if (!dir.startsWith("/")) {
            dir = "/" + dir;
        }
        filename = dir + "/events_" + dateStr + ".csv";
    }
    
    return filename;
}


bool LoggerManager::_ensureEventLogExists() {
    if (!_enabled) return false;
    // Check if event log file exists
    File file = _fs->open(_currentEventLogFile.c_str(), FILE_READ);
    if (file) {
        file.close();
        return true; // File exists
    }
    
    // File doesn't exist, create it with header
    return _writeEventHeader();
}

bool LoggerManager::_writeEventHeader() {
    if (!_enabled) return false;
    File file = _fs->open(_currentEventLogFile.c_str(), FILE_WRITE);
    if (!file) {
        _lastError = "Failed to open event log file for header writing: " + _currentEventLogFile;
        return false;
    }
    
    String header = "Timestamp,Source,Description,Priority\n";
    size_t written = file.print(header);
    file.close();
    
    if (written != header.length()) {
        _lastError = "Failed to write complete event log header";
        return false;
    }
    
    Serial.printf("Event log header written to %s\n", _currentEventLogFile.c_str());
    return true;
}

bool LoggerManager::_writeEventRow(const String& timestamp, const String& source, 
                                  const String& description, const String& priority) {
    if (!_enabled) return false;
    File file = _fs->open(_currentEventLogFile.c_str(), FILE_APPEND);
    if (!file) {
        _lastError = "Failed to open event log file for writing: " + _currentEventLogFile;
        return false;
    }
    
    // Build event row with proper CSV escaping
    String eventRow = _escapeCSVField(timestamp) + "," + 
                     _escapeCSVField(source) + "," + 
                     _escapeCSVField(description) + "," + 
                     _escapeCSVField(priority) + "\n";
    
    size_t written = file.print(eventRow);
    file.close();
    
    if (written != eventRow.length()) {
        _lastError = "Failed to write complete event log row";
        return false;
    }
    
    // Also print to serial for debugging
    Serial.printf("[%s] %s: %s (%s)\n", timestamp.c_str(), source.c_str(), description.c_str(), priority.c_str());
    
    return true;
}


// Alarm state logging configuration methods
void LoggerManager::setAlarmStateLoggingEnabled(bool enabled) {
    _alarmStateLoggingEnabled = enabled;
    Serial.printf("Alarm state logging %s\n", enabled ? "enabled" : "disabled");
}

bool LoggerManager::isAlarmStateLoggingEnabled() const {
    return _alarmStateLoggingEnabled;
}

void LoggerManager::setAlarmStateLogDirectory(const String& directory) {
    _alarmStateLogDirectory = directory;
    if (!_alarmStateLogDirectory.startsWith("/") && !_alarmStateLogDirectory.isEmpty()) {
        _alarmStateLogDirectory = "/" + _alarmStateLogDirectory;
    }
}

String LoggerManager::getAlarmStateLogDirectory() const {
    return _alarmStateLogDirectory;
}

// Static method for alarm state logging
bool LoggerManager::logAlarmStateChange(int pointNumber, const String& pointName, 
                                       const String& alarmType, const String& alarmPriority,
                                       const String& previousState, const String& newState,
                                       int16_t currentTemp, int16_t threshold) {
    
    return _instance ? _instance->logAlarmState(pointNumber, pointName, alarmType, alarmPriority,
                                               previousState, newState, currentTemp, threshold) : false;
}

// Instance method for alarm state logging
bool LoggerManager::logAlarmState(int pointNumber, const String& pointName, 
                                 const String& alarmType, const String& alarmPriority,
                                 const String& previousState, const String& newState,
                                 int16_t currentTemp, int16_t threshold) {
    if (!_enabled) return false;
    if (!_alarmStateLoggingEnabled) return false;
    
    // Check if we need a new alarm state log file for today
    String currentDate = _getCurrentDateString();
    if (currentDate != _lastAlarmStateLogDate) {
        _lastAlarmStateLogDate = currentDate;
        _currentAlarmStateLogFile = _generateAlarmStateLogFileName();
    }
    
    // Ensure alarm state log file exists
    if (!_ensureAlarmStateLogExists()) {
        return false;
    }
    
    // Generate timestamp
    String timestamp = _getCurrentDateString() + " " + _getCurrentTimeString();
    
    // Write alarm state row
    return _writeAlarmStateRow(timestamp, pointNumber, pointName, alarmType, alarmPriority,
                              previousState, newState, currentTemp, threshold);
}

// Private methods for alarm state logging
String LoggerManager::_generateAlarmStateLogFileName() {

    String dateStr = _getCurrentDateString();
    String filename;
    
    if (_alarmStateLogDirectory.isEmpty()) {
        filename = "/alarm_states_" + dateStr + ".csv";
    } else {
        String dir = _alarmStateLogDirectory;
        if (!dir.startsWith("/")) {
            dir = "/" + dir;
        }
        filename = dir + "/alarm_states_" + dateStr + ".csv";
    }
    
    return filename;
}

bool LoggerManager::_ensureAlarmStateLogExists() {
    if (!_enabled) return false;
    // Check if alarm state log file exists
    File file = _fs->open(_currentAlarmStateLogFile.c_str(), FILE_READ);
    if (file) {
        file.close();
        return true; // File exists
    }
    
    // File doesn't exist, create it with header
    return _writeAlarmStateHeader();
}

bool LoggerManager::_writeAlarmStateHeader() {
    if (!_enabled) return false;
    File file = _fs->open(_currentAlarmStateLogFile.c_str(), FILE_WRITE);
    if (!file) {
        _lastError = "Failed to open alarm state log file for header writing: " + _currentAlarmStateLogFile;
        return false;
    }
    
    String header = "Timestamp,PointNumber,PointName,AlarmType,AlarmPriority,PreviousState,NewState,CurrentTemperature,Threshold\n";
    size_t written = file.print(header);
    file.close();
    
    if (written != header.length()) {
        _lastError = "Failed to write complete alarm state log header";
        return false;
    }
    
    Serial.printf("Alarm state log header written to %s\n", _currentAlarmStateLogFile.c_str());
    return true;
}

bool LoggerManager::_writeAlarmStateRow(const String& timestamp, int pointNumber, const String& pointName,
                                       const String& alarmType, const String& alarmPriority,
                                       const String& previousState, const String& newState,
                                       int16_t currentTemp, int16_t threshold) {
    if (!_enabled) return false;
    File file = _fs->open(_currentAlarmStateLogFile.c_str(), FILE_APPEND);
    if (!file) {
        _lastError = "Failed to open alarm state log file for writing: " + _currentAlarmStateLogFile;
        return false;
    }
    
    // Build alarm state row with proper CSV escaping
    String alarmStateRow = _escapeCSVField(timestamp) + "," + 
                          String(pointNumber) + "," +
                          _escapeCSVField(pointName) + "," + 
                          _escapeCSVField(alarmType) + "," + 
                          _escapeCSVField(alarmPriority) + "," + 
                          _escapeCSVField(previousState) + "," + 
                          _escapeCSVField(newState) + "," + 
                          String(currentTemp) + "," + 
                          String(threshold) + "\n";
    
    size_t written = file.print(alarmStateRow);
    file.close();
    
    if (written != alarmStateRow.length()) {
        _lastError = "Failed to write complete alarm state log row";
        return false;
    }
    
    // Also print to serial for debugging
    Serial.printf("[ALARM_STATE] %s: Point %d (%s) %s %s: %s -> %s (Temp: %d, Threshold: %d)\n", 
                 timestamp.c_str(), pointNumber, pointName.c_str(), alarmType.c_str(), 
                 alarmPriority.c_str(), previousState.c_str(), newState.c_str(), currentTemp, threshold);
    
    return true;
}

// Alarm state log management
String LoggerManager::getCurrentAlarmStateLogFile() const {
    return _currentAlarmStateLogFile;
}

// std::vector<String> LoggerManager::getAlarmStateLogFiles() {

//     std::vector<String> files;
    
//     String dirPath = _instance->_alarmStateLogDirectory.isEmpty() ? "/" : _instance->_alarmStateLogDirectory;
//     File dir = _instance->_fs->open(dirPath.c_str());
    
//     if (!dir || !dir.isDirectory()) {
//         return files;
//     }
    
//     File file = dir.openNextFile();
//     while (file) {
//         String filename = String(file.name());
//         if (filename.startsWith("alarm_states_") && filename.endsWith(".csv")) {
//             String fullPath = dirPath;
//             if (!fullPath.endsWith("/")) fullPath += "/";
//             fullPath += filename;
//             files.push_back(fullPath);
//         }
//         file = dir.openNextFile();
//     }
    
//     dir.close();
//     return files;
// }

bool LoggerManager::deleteAlarmStateLogFile(const String& filename) {
    String fullPath = _alarmStateLogDirectory.isEmpty() ? "/" : _alarmStateLogDirectory;
    if (!fullPath.endsWith("/")) fullPath += "/";
    fullPath += filename;
    return _fs->remove(fullPath.c_str());
}


// Add to LoggerManager.cpp:
bool LoggerManager::_isSDCardAvailable() {
    // Try to open the filesystem
    File testFile = _fs->open("/");
    if (!testFile) {
        return false;
    }
    testFile.close();
    return true;
}


String LoggerManager::getAlarmHistoryJson(const String& startDate, const String& endDate) {
    if (!_instance) {
        return "{\"success\":false,\"error\":\"LoggerManager not initialized\"}";
    }
    
    DynamicJsonDocument doc(16384); // Large document for history
    doc["success"] = true;
    JsonArray historyArray = doc.createNestedArray("history");
    
    // Get all alarm log files in the date range
    std::vector<String> files = _getAlarmLogFilesInRange(startDate, endDate);
    
    if (files.empty()) {
        doc["success"] = false;
        doc["error"] = "No alarm log files found in the specified date range";
        String output;
        serializeJson(doc, output);
        return output;
    }
    
    // Read and parse each file
    // for (const String& filename : files) {
    //     String fullPath = _instance->_alarmStateLogDirectory.isEmpty() ? "/" : _instance->_alarmStateLogDirectory;
    //     if (!fullPath.endsWith("/")) fullPath += "/";
    //     fullPath += filename;
        
    //     File file = _instance->_fs->open(fullPath.c_str(), FILE_READ);
    //     if (!file) {
    //         continue;
    //     }

    for (const String& filename : files) {
        String fullPath = _instance->_alarmStateLogDirectory.isEmpty() ? "/" : _instance->_alarmStateLogDirectory;
        if (!fullPath.endsWith("/")) fullPath += "/";
        fullPath += filename;
        
        Serial.printf("Opening file: %s\n", fullPath.c_str());
        
        File file = _instance->_fs->open(fullPath.c_str(), FILE_READ);
        if (!file) {
            Serial.printf("Failed to open file: %s\n", fullPath.c_str());
            continue;
        }
        
        // Skip header line
        if (file.available()) {
            file.readStringUntil('\n');
        }
        
        // Read data lines
        while (file.available()) {
            String line = file.readStringUntil('\n');
            line.trim();
            if (line.isEmpty()) continue;
            
            DynamicJsonDocument entryDoc(512);
            if (_parseAlarmStateLogEntry(line, entryDoc)) {
                JsonObject entry = historyArray.createNestedObject();
                entry["timestamp"] = entryDoc["timestamp"];
                entry["pointNumber"] = entryDoc["pointNumber"];
                entry["pointName"] = entryDoc["pointName"];
                entry["alarmType"] = entryDoc["alarmType"];
                entry["alarmPriority"] = entryDoc["alarmPriority"];
                entry["previousState"] = entryDoc["previousState"];
                entry["newState"] = entryDoc["newState"];
                entry["currentTemperature"] = entryDoc["currentTemperature"];
                entry["threshold"] = entryDoc["threshold"];
            }
        }
        
        file.close();
    }
    
    doc["totalEntries"] = historyArray.size();
    
    String output;
    serializeJson(doc, output);
    return output;
}

String LoggerManager::getAlarmHistoryCsv(const String& startDate, const String& endDate) {
    if (!_instance) {
        return "";
    }
    
    String csv = "Timestamp,PointNumber,PointName,AlarmType,AlarmPriority,PreviousState,NewState,CurrentTemperature,Threshold\n";
    
    // Get all alarm log files in the date range
    std::vector<String> files = _getAlarmLogFilesInRange(startDate, endDate);
    
    if (files.empty()) {
        return "";
    }
    
    // Read and merge data from all files
    for (const String& filename : files) {
        String fullPath = _instance->_alarmStateLogDirectory.isEmpty() ? "/" : _instance->_alarmStateLogDirectory;
        if (!fullPath.endsWith("/")) fullPath += "/";
        fullPath += filename;
        
        File file = _instance->_fs->open(fullPath.c_str(), FILE_READ);
        if (!file) {
            continue;
        }
        
        // Skip header line
        if (file.available()) {
            file.readStringUntil('\n');
        }
        
        // Copy data lines
        while (file.available()) {
            String line = file.readStringUntil('\n');
            line.trim();
            if (!line.isEmpty()) {
                csv += line + "\n";
            }
        }
        
        file.close();
    }
    
    return csv;
}

std::vector<String> LoggerManager::_getAlarmLogFilesInRange(const String& startDate, const String& endDate) {
    std::vector<String> matchingFiles;
    
    if (!_instance) {
        return matchingFiles;
    }
    
    String dirPath = _instance->_alarmStateLogDirectory.isEmpty() ? "/" : _instance->_alarmStateLogDirectory;
    Serial.printf("Searching for alarm log files in directory: %s\n", dirPath.c_str());
    File dir = _instance->_fs->open(dirPath.c_str());
    
    if (!dir || !dir.isDirectory()) {
        Serial.printf("Could not open directory: %s\n", dirPath.c_str());
        return matchingFiles;
    }
    
    String normalizedStart = _normalizeDate(startDate);
    Serial.printf("Normalized start date: %s\n", normalizedStart.c_str());
    String normalizedEnd = _normalizeDate(endDate);
    Serial.printf("Normalized end date: %s\n", normalizedEnd.c_str());
    
    File file = dir.openNextFile();
    while (file) {
        String filename = String(file.name());
        Serial.printf("Checking file: %s\n", filename.c_str());
        
        // Check if it's an alarm state log file
        if (filename.startsWith("alarm_states_") && filename.endsWith(".csv")) {
            // Extract date from filename (alarm_states_YYYY-MM-DD.csv)
            // The date starts after "alarm_states_" which is 13 characters
            String fileDate = filename.substring(13); // Remove "alarm_states_" prefix
            fileDate = fileDate.substring(0, fileDate.lastIndexOf('.')); // Remove .csv extension
            
            Serial.printf("Extracted file date: %s\n", fileDate.c_str());
            
            // Check if date is within range
            if (fileDate >= normalizedStart && fileDate <= normalizedEnd) {
                Serial.printf("File date %s is within range [%s, %s]\n", fileDate.c_str(), normalizedStart.c_str(), normalizedEnd.c_str());
                matchingFiles.push_back(filename);
            } else {
                Serial.printf("File date %s is outside range [%s, %s]\n", fileDate.c_str(), normalizedStart.c_str(), normalizedEnd.c_str());
            }
        }
        
        file = dir.openNextFile();
    }
    
    dir.close();
    
    Serial.printf("Found %d matching files\n", matchingFiles.size());
    
    // Sort files by date
    std::sort(matchingFiles.begin(), matchingFiles.end());
    
    return matchingFiles;
}
bool LoggerManager::_parseAlarmStateLogEntry(const String& line, DynamicJsonDocument& entry) {
    // This method doesn't need instance access, so it can remain unchanged
    // Parse CSV line: Timestamp,PointNumber,PointName,AlarmType,AlarmPriority,PreviousState,NewState,CurrentTemperature,Threshold
    int fieldIndex = 0;
    int startPos = 0;
    String fields[9];
    bool inQuotes = false;
    
    for (int i = 0; i <= line.length(); i++) {
        char c = (i < line.length()) ? line.charAt(i) : ',';
        
        if (c == '"') {
            inQuotes = !inQuotes;
        } else if (c == ',' && !inQuotes) {
            if (fieldIndex < 9) {
                fields[fieldIndex] = line.substring(startPos, i);
                // Remove quotes if present
                if (fields[fieldIndex].startsWith("\"") && fields[fieldIndex].endsWith("\"")) {
                    fields[fieldIndex] = fields[fieldIndex].substring(1, fields[fieldIndex].length() - 1);
                }
                fields[fieldIndex].trim();
            }
            fieldIndex++;
            startPos = i + 1;
        }
    }
    
    if (fieldIndex < 8) { // We need at least 9 fields (0-8)
        return false;
    }
    
    // Parse fields into JSON
    entry["timestamp"] = fields[0];
    entry["pointNumber"] = fields[1].toInt();
    entry["pointName"] = fields[2];
    entry["alarmType"] = fields[3];
    entry["alarmPriority"] = fields[4];
    entry["previousState"] = fields[5];
    entry["newState"] = fields[6];
    entry["currentTemperature"] = fields[7].toInt();
    entry["threshold"] = fields[8].toInt();
    
    return true;
}

String LoggerManager::_normalizeDate(const String& dateStr) {
    // This method doesn't need instance access, so it can remain unchanged
    // Ensure date is in YYYY-MM-DD format
    String normalized = dateStr;
    normalized.trim();
    
    // If date contains slashes, replace with dashes
    normalized.replace("/", "-");
    
    // Ensure proper formatting with leading zeros
    int firstDash = normalized.indexOf('-');
    int secondDash = normalized.lastIndexOf('-');
    
    if (firstDash > 0 && secondDash > firstDash) {
        String year = normalized.substring(0, firstDash);
        String month = normalized.substring(firstDash + 1, secondDash);
        String day = normalized.substring(secondDash + 1);
        
        // Pad with zeros if needed
        if (month.length() == 1) month = "0" + month;
        if (day.length() == 1) day = "0" + day;
        
        normalized = year + "-" + month + "-" + day;
    }
    
    return normalized;
}

// String LoggerManager::getEventLogsJson(const String& startDate, const String& endDate) {
//     if (!_instance) {
//         return "{\"success\":false,\"error\":\"LoggerManager not initialized\"}";
//     }
    
//     DynamicJsonDocument doc(16384); // Large document for logs
//     doc["success"] = true;
//     JsonArray logsArray = doc.createNestedArray("logs");
    
//     // Get all event log files in the date range
//     std::vector<String> files = _getEventLogFilesInRange(startDate, endDate);
    
//     if (files.empty()) {
//         doc["success"] = false;
//         doc["error"] = "No event log files found in the specified date range";
//         String output;
//         serializeJson(doc, output);
//         return output;
//     }
    
//     // Read and parse each file
//     for (const String& filename : files) {
//         String fullPath = _instance->_eventLogDirectory.isEmpty() ? "/" : _instance->_eventLogDirectory;
//         if (!fullPath.endsWith("/")) fullPath += "/";
//         fullPath += filename;
        
//         Serial.printf("Opening event log file: %s\n", fullPath.c_str());
        
//         File file = _instance->_fs->open(fullPath.c_str(), FILE_READ);
//         if (!file) {
//             Serial.printf("Failed to open event log file: %s\n", fullPath.c_str());
//             continue;
//         }
        
//         // Skip header line
//         if (file.available()) {
//             file.readStringUntil('\n');
//         }
        
//         // Read data lines
//         while (file.available()) {
//             String line = file.readStringUntil('\n');
//             line.trim();
//             if (line.isEmpty()) continue;
            
//             DynamicJsonDocument entryDoc(512);
//             if (_parseEventLogEntry(line, entryDoc)) {
//                 JsonObject entry = logsArray.createNestedObject();
//                 entry["timestamp"] = entryDoc["timestamp"];
//                 entry["source"] = entryDoc["source"];
//                 entry["description"] = entryDoc["description"];
//                 entry["priority"] = entryDoc["priority"];
//             }
//         }
        
//         file.close();
//     }
    
//     doc["totalEntries"] = logsArray.size();
    
//     String output;
//     serializeJson(doc, output);
//     return output;
// }

// String LoggerManager::getEventLogsCsv(const String& startDate, const String& endDate) {
//     if (!_instance) {
//         return "";
//     }
    
//     String csv = "Timestamp,Source,Description,Priority\n";
    
//     // Get all event log files in the date range
//     std::vector<String> files = _getEventLogFilesInRange(startDate, endDate);
    
//     if (files.empty()) {
//         return "";
//     }
    
//     // Read and merge data from all files
//     for (const String& filename : files) {
//         String fullPath = _instance->_eventLogDirectory.isEmpty() ? "/" : _instance->_eventLogDirectory;
//         if (!fullPath.endsWith("/")) fullPath += "/";
//         fullPath += filename;
        
//         File file = _instance->_fs->open(fullPath.c_str(), FILE_READ);
//         if (!file) {
//             continue;
//         }
        
//         // Skip header line
//         if (file.available()) {
//             file.readStringUntil('\n');
//         }
        
//         // Copy data lines
//         while (file.available()) {
//             String line = file.readStringUntil('\n');
//             line.trim();
//             if (!line.isEmpty()) {
//                 csv += line + "\n";
//             }
//         }
        
//         file.close();
//     }
    
//     return csv;
// }

// std::vector<String> LoggerManager::_getEventLogFilesInRange(const String& startDate, const String& endDate) {
//     std::vector<String> matchingFiles;
    
//     if (!_instance) {
//         return matchingFiles;
//     }
    
//     String dirPath = _instance->_eventLogDirectory.isEmpty() ? "/" : _instance->_eventLogDirectory;
//     Serial.printf("Searching for event log files in directory: %s\n", dirPath.c_str());
//     File dir = _instance->_fs->open(dirPath.c_str());
    
//     if (!dir || !dir.isDirectory()) {
//         Serial.printf("Could not open directory: %s\n", dirPath.c_str());
//         return matchingFiles;
//     }
    
//     String normalizedStart = _normalizeDate(startDate);
//     Serial.printf("Normalized start date: %s\n", normalizedStart.c_str());
//     String normalizedEnd = _normalizeDate(endDate);
//     Serial.printf("Normalized end date: %s\n", normalizedEnd.c_str());
    
//     File file = dir.openNextFile();
//     while (file) {
//         String filename = String(file.name());
//         Serial.printf("Checking file: %s\n", filename.c_str());
        
//         // Check if it's an event log file
//         if (filename.startsWith("events_") && filename.endsWith(".csv")) {
//             // Extract date from filename (events_YYYY-MM-DD.csv)
//             String fileDate = filename.substring(7); // Remove "events_" prefix
//             fileDate = fileDate.substring(0, fileDate.lastIndexOf('.')); // Remove .csv extension
            
//             Serial.printf("Extracted file date: %s\n", fileDate.c_str());
            
//             // Check if date is within range
//             if (fileDate >= normalizedStart && fileDate <= normalizedEnd) {
//                 Serial.printf("File date %s is within range [%s, %s]\n", fileDate.c_str(), normalizedStart.c_str(), normalizedEnd.c_str());
//                 matchingFiles.push_back(filename);
//             }
//         }
        
//         file = dir.openNextFile();
//     }
    
//     dir.close();
    
//     Serial.printf("Found %d matching event log files\n", matchingFiles.size());
    
//     // Sort files by date
//     std::sort(matchingFiles.begin(), matchingFiles.end());
    
//     return matchingFiles;
// }

// bool LoggerManager::_parseEventLogEntry(const String& line, DynamicJsonDocument& entry) {
//     // Parse CSV line: Timestamp,Source,Description,Priority
//     int fieldIndex = 0;
//     int startPos = 0;
//     String fields[4];
//     bool inQuotes = false;
    
//     for (int i = 0; i <= line.length(); i++) {
//         char c = (i < line.length()) ? line.charAt(i) : ',';
        
//         if (c == '"') {
//             inQuotes = !inQuotes;
//         } else if (c == ',' && !inQuotes) {
//             if (fieldIndex < 4) {
//                 fields[fieldIndex] = line.substring(startPos, i);
//                 // Remove quotes if present
//                 if (fields[fieldIndex].startsWith("\"") && fields[fieldIndex].endsWith("\"")) {
//                     fields[fieldIndex] = fields[fieldIndex].substring(1, fields[fieldIndex].length() - 1);
//                 }
//                 fields[fieldIndex].trim();
//             }
//             fieldIndex++;
//             startPos = i + 1;
//         }
//     }
    
//     if (fieldIndex < 3) { // We need at least 4 fields (0-3)
//         return false;
//     }
    
//     // Parse fields into JSON
//     entry["timestamp"] = fields[0];
//     entry["source"] = fields[1];
//     entry["description"] = fields[2];
//     entry["priority"] = fields[3];
    
//     return true;
// }


// Add these methods to your LoggerManager.cpp file

// Static method to get event logs as JSON
String LoggerManager::getEventLogsJson(const String& startDate, const String& endDate) {
    if (!_instance) {
        return "{\"success\":false,\"error\":\"LoggerManager not initialized\"}";
    }
    
    DynamicJsonDocument doc(16384); // Large document for logs
    doc["success"] = true;
    JsonArray logsArray = doc.createNestedArray("logs");
    
    // Get all event log files in the date range
    std::vector<String> files = _getEventLogFilesInRange(startDate, endDate);
    
    if (files.empty()) {
        doc["success"] = false;
        doc["error"] = "No event log files found in the specified date range";
        String output;
        serializeJson(doc, output);
        return output;
    }
    
    // Read and parse each file
    for (const String& filename : files) {
        String fullPath = _instance->_eventLogDirectory.isEmpty() ? "/" : _instance->_eventLogDirectory;
        if (!fullPath.endsWith("/")) fullPath += "/";
        fullPath += filename;
        
        Serial.printf("Opening event log file: %s\n", fullPath.c_str());
        
        File file = _instance->_fs->open(fullPath.c_str(), FILE_READ);
        if (!file) {
            Serial.printf("Failed to open event log file: %s\n", fullPath.c_str());
            continue;
        }
        
        // Skip header line
        if (file.available()) {
            file.readStringUntil('\n');
        }
        
        // Read data lines
        while (file.available()) {
            String line = file.readStringUntil('\n');
            line.trim();
            if (line.isEmpty()) continue;
            
            DynamicJsonDocument entryDoc(512);
            if (_parseEventLogEntry(line, entryDoc)) {
                JsonObject entry = logsArray.createNestedObject();
                entry["timestamp"] = entryDoc["timestamp"];
                entry["source"] = entryDoc["source"];
                entry["description"] = entryDoc["description"];
                entry["priority"] = entryDoc["priority"];
            }
        }
        
        file.close();
    }
    
    doc["totalEntries"] = logsArray.size();
    
    String output;
    serializeJson(doc, output);
    return output;
}

// Static method to get event logs as CSV
String LoggerManager::getEventLogsCsv(const String& startDate, const String& endDate) {
    if (!_instance) {
        return "";
    }
    
    String csv = "Timestamp,Source,Description,Priority\n";
    
    // Get all event log files in the date range
    std::vector<String> files = _getEventLogFilesInRange(startDate, endDate);
    
    if (files.empty()) {
        return "";
    }
    
    // Read and merge data from all files
    for (const String& filename : files) {
        String fullPath = _instance->_eventLogDirectory.isEmpty() ? "/" : _instance->_eventLogDirectory;
        if (!fullPath.endsWith("/")) fullPath += "/";
        fullPath += filename;
        
        File file = _instance->_fs->open(fullPath.c_str(), FILE_READ);
        if (!file) {
            continue;
        }
        
        // Skip header line
        if (file.available()) {
            file.readStringUntil('\n');
        }
        
        // Copy data lines
        while (file.available()) {
            String line = file.readStringUntil('\n');
            line.trim();
            if (!line.isEmpty()) {
                csv += line + "\n";
            }
        }
        
        file.close();
    }
    
    return csv;
}

// Static method to get event log files in range
std::vector<String> LoggerManager::_getEventLogFilesInRange(const String& startDate, const String& endDate) {
    std::vector<String> matchingFiles;
    
    if (!_instance) {
        return matchingFiles;
    }
    
    String dirPath = _instance->_eventLogDirectory.isEmpty() ? "/" : _instance->_eventLogDirectory;
    Serial.printf("Searching for event log files in directory: %s\n", dirPath.c_str());
    File dir = _instance->_fs->open(dirPath.c_str());
    
    if (!dir || !dir.isDirectory()) {
        Serial.printf("Could not open directory: %s\n", dirPath.c_str());
        return matchingFiles;
    }
    
    String normalizedStart = _normalizeDate(startDate);
    Serial.printf("Normalized start date: %s\n", normalizedStart.c_str());
    String normalizedEnd = _normalizeDate(endDate);
    Serial.printf("Normalized end date: %s\n", normalizedEnd.c_str());
    
    File file = dir.openNextFile();
    while (file) {
        String filename = String(file.name());
        Serial.printf("Checking file: %s\n", filename.c_str());
        
        // Check if it's an event log file
        if (filename.startsWith("events_") && filename.endsWith(".csv")) {
            // Extract date from filename (events_YYYY-MM-DD.csv)
            String fileDate = filename.substring(7); // Remove "events_" prefix
            fileDate = fileDate.substring(0, fileDate.lastIndexOf('.')); // Remove .csv extension
            
            Serial.printf("Extracted file date: %s\n", fileDate.c_str());
            
            // Check if date is within range
            if (fileDate >= normalizedStart && fileDate <= normalizedEnd) {
                Serial.printf("File date %s is within range [%s, %s]\n", fileDate.c_str(), normalizedStart.c_str(), normalizedEnd.c_str());
                matchingFiles.push_back(filename);
            }
        }
        
        file = dir.openNextFile();
    }
    
    dir.close();
    
    Serial.printf("Found %d matching event log files\n", matchingFiles.size());
    
    // Sort files by date
    std::sort(matchingFiles.begin(), matchingFiles.end());
    
    return matchingFiles;
}

// Static method to parse event log entry
bool LoggerManager::_parseEventLogEntry(const String& line, DynamicJsonDocument& entry) {
    // Parse CSV line: Timestamp,Source,Description,Priority
    int fieldIndex = 0;
    int startPos = 0;
    String fields[4];
    bool inQuotes = false;
    
    for (int i = 0; i <= line.length(); i++) {
        char c = (i < line.length()) ? line.charAt(i) : ',';
        
        if (c == '"') {
            inQuotes = !inQuotes;
        } else if (c == ',' && !inQuotes) {
            if (fieldIndex < 4) {
                fields[fieldIndex] = line.substring(startPos, i);
                // Remove quotes if present
                if (fields[fieldIndex].startsWith("\"") && fields[fieldIndex].endsWith("\"")) {
                    fields[fieldIndex] = fields[fieldIndex].substring(1, fields[fieldIndex].length() - 1);
                }
                fields[fieldIndex].trim();
            }
            fieldIndex++;
            startPos = i + 1;
        }
    }
    
    if (fieldIndex < 3) { // We need at least 4 fields (0-3)
        return false;
    }
    
    // Parse fields into JSON
    entry["timestamp"] = fields[0];
    entry["source"] = fields[1];
    entry["description"] = fields[2];
    entry["priority"] = fields[3];
    
    return true;
}

// Static method to get event log statistics
String LoggerManager::getEventLogStatsJson(const String& startDate, const String& endDate) {
    if (!_instance) {
        return "{\"success\":false,\"error\":\"LoggerManager not initialized\"}";
    }
    
    DynamicJsonDocument doc(1024);
    doc["success"] = true;
    
    // Initialize counters
    int totalEntries = 0;
    int criticalCount = 0;
    int errorCount = 0;
    int warningCount = 0;
    int infoCount = 0;
    
    // Get all event log files in the date range
    std::vector<String> files = _getEventLogFilesInRange(startDate, endDate);
    
    // Count entries by priority
    for (const String& filename : files) {
        String fullPath = _instance->_eventLogDirectory.isEmpty() ? "/" : _instance->_eventLogDirectory;
        if (!fullPath.endsWith("/")) fullPath += "/";
        fullPath += filename;
        
        File file = _instance->_fs->open(fullPath.c_str(), FILE_READ);
        if (!file) {
            continue;
        }
        
        // Skip header line
        if (file.available()) {
            file.readStringUntil('\n');
        }
        
        // Read data lines
        while (file.available()) {
            String line = file.readStringUntil('\n');
            line.trim();
            if (line.isEmpty()) continue;
            
            totalEntries++;
            
            // Quick parse to get priority (last field)
            int lastComma = line.lastIndexOf(',');
            if (lastComma != -1) {
                String priority = line.substring(lastComma + 1);
                priority.trim();
                
                // Remove quotes if present
                if (priority.startsWith("\"") && priority.endsWith("\"")) {
                    priority = priority.substring(1, priority.length() - 1);
                }
                
                if (priority == "CRITICAL") {
                    criticalCount++;
                } else if (priority == "ERROR") {
                    errorCount++;
                } else if (priority == "WARNING") {
                    warningCount++;
                } else if (priority == "INFO") {
                    infoCount++;
                }
            }
        }
        
        file.close();
    }
    
    // Build statistics JSON
    doc["totalEntries"] = totalEntries;
    doc["dateRange"]["start"] = startDate;
    doc["dateRange"]["end"] = endDate;
    doc["filesFound"] = files.size();
    
    JsonObject priorityStats = doc.createNestedObject("priorityStats");
    priorityStats["critical"] = criticalCount;
    priorityStats["error"] = errorCount;
    priorityStats["warning"] = warningCount;
    priorityStats["info"] = infoCount;
    
    String output;
    serializeJson(doc, output);
    return output;
}

// Static method to get event log files
std::vector<String> LoggerManager::getEventLogFilesStatic() {
    std::vector<String> files;
    
    if (!_instance) {
        return files;
    }
    
    String dirPath = _instance->_eventLogDirectory.isEmpty() ? "/" : _instance->_eventLogDirectory;
    File dir = _instance->_fs->open(dirPath.c_str());
    
    if (!dir || !dir.isDirectory()) {
        return files;
    }
    
    File file = dir.openNextFile();
    while (file) {
        String filename = String(file.name());
        if (filename.startsWith("events_") && filename.endsWith(".csv")) {
            files.push_back(filename);
        }
        file = dir.openNextFile();
    }
    
    dir.close();
    
    // Sort files by date
    std::sort(files.begin(), files.end());
    
    return files;
}



// Static method to get temperature data log files
std::vector<String> LoggerManager::getLogFiles() {
    std::vector<String> files;
    if (!_instance) {
        return files;
    }
    
    String dirPath = _instance->_logDirectory.isEmpty() ? "/" : _instance->_logDirectory;
    File dir = _instance->_fs->open(dirPath.c_str());
    if (!dir || !dir.isDirectory()) {
        return files;
    }
    
    File file = dir.openNextFile();
    while (file) {
        String filename = String(file.name());
        if (filename.startsWith("temp_log_") && filename.endsWith(".csv")) {
            files.push_back(filename);
        }
        file = dir.openNextFile();
    }
    
    dir.close();
    std::sort(files.begin(), files.end());
    return files;
}

// Static method to get alarm state log files
std::vector<String> LoggerManager::getAlarmStateLogFiles() {
    std::vector<String> files;
    if (!_instance) {
        return files;
    }
    
    String dirPath = _instance->_alarmStateLogDirectory.isEmpty() ? "/" : _instance->_alarmStateLogDirectory;
    File dir = _instance->_fs->open(dirPath.c_str());
    if (!dir || !dir.isDirectory()) {
        return files;
    }
    
    File file = dir.openNextFile();
    while (file) {
        String filename = String(file.name());
        if (filename.startsWith("alarm_states_") && filename.endsWith(".csv")) {
            files.push_back(filename);
        }
        file = dir.openNextFile();
    }
    
    dir.close();
    std::sort(files.begin(), files.end());
    return files;
}

// Static method to get file information
bool LoggerManager::getFileInfo(const String& filename, const String& type, size_t& fileSize, String& date) {
    if (!_instance) {
        return false;
    }
    
    String dirPath = getLogDirectoryPath(type);
    String fullPath = dirPath;
    if (!fullPath.endsWith("/") && !fullPath.isEmpty()) fullPath += "/";
    fullPath += filename;
    
    File file = _instance->_fs->open(fullPath.c_str(), FILE_READ);
    if (!file) {
        return false;
    }
    
    fileSize = file.size();
    file.close();
    
    // Extract date from filename based on type
    if (type == "data" && filename.startsWith("temp_log_") && filename.endsWith(".csv")) {
        int firstUnderscore = filename.indexOf('_', 5); // Skip "temp_"
        int secondUnderscore = filename.indexOf('_', firstUnderscore + 1);
        if (firstUnderscore > 0 && secondUnderscore > firstUnderscore) {
            date = filename.substring(firstUnderscore + 1, secondUnderscore);
        }
    } else if (type == "event" && filename.startsWith("events_") && filename.endsWith(".csv")) {
        date = filename.substring(7, filename.length() - 4);
    } else if (type == "alarm" && filename.startsWith("alarm_states_") && filename.endsWith(".csv")) {
        date = filename.substring(13, filename.length() - 4);
    }
    
    return true;
}

// Static method to open log files
File LoggerManager::openLogFile(const String& filename, const String& type) {
    if (!_instance) {
        return File();
    }
    
    String dirPath = getLogDirectoryPath(type);
    String fullPath = dirPath;
    if (!fullPath.endsWith("/") && !fullPath.isEmpty()) fullPath += "/";
    fullPath += filename;
    
    return _instance->_fs->open(fullPath.c_str(), FILE_READ);
}

// Static method to get directory path for different log types
String LoggerManager::getLogDirectoryPath(const String& type) {
    if (!_instance) {
        return "/";
    }
    
    if (type == "data") {
        return _instance->_logDirectory.isEmpty() ? "/" : _instance->_logDirectory;
    } else if (type == "event") {
        return _instance->_eventLogDirectory.isEmpty() ? "/" : _instance->_eventLogDirectory;
    } else if (type == "alarm") {
        return _instance->_alarmStateLogDirectory.isEmpty() ? "/" : _instance->_alarmStateLogDirectory;
    }
    
    return "/";
}


// std::vector<String> LoggerManager::getLogFiles() {

//     std::vector<String> files;
    
//     File dir = _fs->open(_logDirectory.c_str());
//     if (!dir || !dir.isDirectory()) {
//         return files;
//     }
    
//     File file = dir.openNextFile();
//     while (file) {
//         if (!file.isDirectory() && String(file.name()).endsWith(".csv")) {
//             files.push_back(String(file.name()));
//         }
//         file = dir.openNextFile();
//     }
    
//     dir.close();
//     return files;
// }

-------- [ Separator ] ------

File Name: src/MeasurementPoint.cpp
Size: 3.92 KB
Code:
#include "MeasurementPoint.h"


MeasurementPoint::MeasurementPoint(uint8_t address, const String& name)
    : address(address),
      name(name),
      currentTemp(0),
      minTemp(32767),
      maxTemp(-32768),
      lowAlarmThreshold(-10),
      highAlarmThreshold(50),
      alarmStatus(0),
      errorStatus(0),
      boundSensor(nullptr)
      //oneWireBus(0)
{
    // Nothing else needed
}

MeasurementPoint::~MeasurementPoint() {
    // Do not delete boundSensor here; ownership is external
    boundSensor = nullptr;
}

uint8_t MeasurementPoint::getAddress() const {
    return address;
}

String MeasurementPoint::getName() const {
    return name;
}

int16_t MeasurementPoint::getCurrentTemp() const {
    return currentTemp;
}

int16_t MeasurementPoint::getMinTemp() const {
    return minTemp;
}

int16_t MeasurementPoint::getMaxTemp() const {
    return maxTemp;
}

int16_t MeasurementPoint::getLowAlarmThreshold() const {
    return lowAlarmThreshold;
}

int16_t MeasurementPoint::getHighAlarmThreshold() const {
    return highAlarmThreshold;
}

uint8_t MeasurementPoint::getAlarmStatus() const {
    return alarmStatus;
}

uint8_t MeasurementPoint::getErrorStatus() const {
    return errorStatus;
}

void MeasurementPoint::setName(const String& newName) {
    if (newName != name) {
        String oldName = name.isEmpty() ? "Point_" + String(address) : name;
        name = newName;
        LoggerManager::info("POINT_CONFIG", 
            "Point " + String(address) + " name changed from '" + 
            oldName + "' to '" + name + "'");
    }
    //name = newName;
}

void MeasurementPoint::setLowAlarmThreshold(int16_t threshold) {

    if (lowAlarmThreshold != threshold) {
        LoggerManager::info("POINT_CONFIG", 
            "Point " + String(address) + " (" + name + 
            ") low alarm threshold changed from " + String(lowAlarmThreshold) + 
            "°C to " + String(threshold) + "°C");
        lowAlarmThreshold = threshold;
    }

    //lowAlarmThreshold = threshold;
    updateAlarmStatus();
}

void MeasurementPoint::setHighAlarmThreshold(int16_t threshold) {
    if (highAlarmThreshold != threshold) {
        LoggerManager::info("POINT_CONFIG", 
            "Point " + String(address) + " (" + name + 
            ") high alarm threshold changed from " + String(highAlarmThreshold) + 
            "°C to " + String(threshold) + "°C");
        highAlarmThreshold = threshold;
    }
    //highAlarmThreshold = threshold;
    updateAlarmStatus();
}

void MeasurementPoint::bindSensor(Sensor* sensor) {
    boundSensor = sensor;
}

void MeasurementPoint::unbindSensor() {
    boundSensor = nullptr;
}

Sensor* MeasurementPoint::getBoundSensor() const {
    return boundSensor;
}

void MeasurementPoint::update() {
    if (boundSensor != nullptr) {
        // Example: ask the sensor for the latest temperature
        //if (boundSensor->readTemperature()) {
            currentTemp = boundSensor->getCurrentTemp();
            //Serial.printf("\nPoint: %d. %s. Sensor: %s. Temp: %d\n", getAddress(), getName(), boundSensor->getName(), currentTemp);
            if (currentTemp < minTemp) minTemp = currentTemp;
            if (currentTemp > maxTemp) maxTemp = currentTemp;
            errorStatus = boundSensor->getErrorStatus();
        //} else {
            //errorStatus = boundSensor->getErrorStatus();
        //}
    } else {
        errorStatus = 0x01; // Example: error code for "not bound"
    }
    updateAlarmStatus();
}

void MeasurementPoint::resetMinMaxTemp() {
    minTemp = currentTemp;
    maxTemp = currentTemp;
}

void MeasurementPoint::updateAlarmStatus() {
    alarmStatus = 0;
    if (errorStatus != 0) return;
    if (currentTemp < lowAlarmThreshold) alarmStatus |= 0x01; // Low alarm bit
    if (currentTemp > highAlarmThreshold) alarmStatus |= 0x02; // High alarm bit
}

// void MeasurementPoint::setOneWireBus(uint8_t bus) {
//     oneWireBus = bus;

// }
// uint8_t MeasurementPoint::getOneWireBus() {
//     return oneWireBus;

// }

-------- [ Separator ] ------

File Name: src/RegisterMap.cpp
Size: 5.20 KB
Code:
#include "RegisterMap.h"

RegisterMap::RegisterMap() {
    deviceId = 1000;
    firmwareVersion = 0x0100;
    numActiveDS18B20 = 0;
    numActivePT1000 = 0;
    for (int i = 0; i < 7; i++) deviceStatus[i] = 0;
    for (int i = 0; i < 60; i++) {
        currentTemps[i] = 0;
        minTemps[i] = 32767;
        maxTemps[i] = -32768;
        alarmStatus[i] = 0;
        errorStatus[i] = 0;
        lowAlarmThresholds[i] = -10;
        highAlarmThresholds[i] = 50;
    }
}

bool RegisterMap::isValidAddress(uint16_t address) {
    if (address <= DEVICE_STATUS_END_REG) return true;
    if (address >= CURRENT_TEMP_DS18B20_START_REG && address <= CURRENT_TEMP_PT1000_END_REG) return true;
    if (address >= MIN_TEMP_DS18B20_START_REG && address <= MIN_TEMP_PT1000_END_REG) return true;
    if (address >= MAX_TEMP_DS18B20_START_REG && address <= MAX_TEMP_PT1000_END_REG) return true;
    if (address >= ALARM_STATUS_DS18B20_START_REG && address <= ALARM_STATUS_PT1000_END_REG) return true;
    if (address >= ERROR_STATUS_DS18B20_START_REG && address <= ERROR_STATUS_PT1000_END_REG) return true;
    if (address >= LOW_ALARM_DS18B20_START_REG && address <= LOW_ALARM_PT1000_END_REG) return true;
    if (address >= HIGH_ALARM_DS18B20_START_REG && address <= HIGH_ALARM_PT1000_END_REG) return true;
    return false;
}

bool RegisterMap::isReadOnlyRegister(uint16_t address) {
    // Only alarm thresholds are writable
    if (address >= LOW_ALARM_DS18B20_START_REG && address <= LOW_ALARM_PT1000_END_REG) return false;
    if (address >= HIGH_ALARM_DS18B20_START_REG && address <= HIGH_ALARM_PT1000_END_REG) return false;
    return true;
}

uint16_t RegisterMap::readHoldingRegister(uint16_t address) {
    if (!isValidAddress(address)) return 0xFFFF;

    if (address == DEVICE_ID_REG) return deviceId;
    if (address == FIRMWARE_VERSION_REG) return firmwareVersion;
    if (address == NUM_DS18B20_REG) return numActiveDS18B20;
    if (address == NUM_PT1000_REG) return numActivePT1000;
    if (address >= DEVICE_STATUS_START_REG && address <= DEVICE_STATUS_END_REG)
        return deviceStatus[address - DEVICE_STATUS_START_REG];

    // DS18B20 and PT1000 share the same arrays, just different index offsets
    if (address >= CURRENT_TEMP_DS18B20_START_REG && address <= CURRENT_TEMP_PT1000_END_REG)
        return currentTemps[address - CURRENT_TEMP_DS18B20_START_REG];
    if (address >= MIN_TEMP_DS18B20_START_REG && address <= MIN_TEMP_PT1000_END_REG)
        return minTemps[address - MIN_TEMP_DS18B20_START_REG];
    if (address >= MAX_TEMP_DS18B20_START_REG && address <= MAX_TEMP_PT1000_END_REG)
        return maxTemps[address - MAX_TEMP_DS18B20_START_REG];
    if (address >= ALARM_STATUS_DS18B20_START_REG && address <= ALARM_STATUS_PT1000_END_REG)
        return alarmStatus[address - ALARM_STATUS_DS18B20_START_REG];
    if (address >= ERROR_STATUS_DS18B20_START_REG && address <= ERROR_STATUS_PT1000_END_REG)
        return errorStatus[address - ERROR_STATUS_DS18B20_START_REG];
    if (address >= LOW_ALARM_DS18B20_START_REG && address <= LOW_ALARM_PT1000_END_REG)
        return lowAlarmThresholds[address - LOW_ALARM_DS18B20_START_REG];
    if (address >= HIGH_ALARM_DS18B20_START_REG && address <= HIGH_ALARM_PT1000_END_REG)
        return highAlarmThresholds[address - HIGH_ALARM_DS18B20_START_REG];

    return 0xFFFF;
}

bool RegisterMap::writeHoldingRegister(uint16_t address, uint16_t value) {
    if (!isValidAddress(address)) return false;
    if (isReadOnlyRegister(address)) return false;

    // Only alarm thresholds are writable
    if (address >= LOW_ALARM_DS18B20_START_REG && address <= LOW_ALARM_PT1000_END_REG) {
        lowAlarmThresholds[address - LOW_ALARM_DS18B20_START_REG] = static_cast<int16_t>(value);
        return true;
    }
    if (address >= HIGH_ALARM_DS18B20_START_REG && address <= HIGH_ALARM_PT1000_END_REG) {
        highAlarmThresholds[address - HIGH_ALARM_DS18B20_START_REG] = static_cast<int16_t>(value);
        return true;
    }
    return false;
}

void RegisterMap::updateFromMeasurementPoint(const MeasurementPoint& point) {
    uint8_t idx = point.getAddress();
    // DS18B20: 0-49, PT1000: 50-59
    if (idx < 60) {
        currentTemps[idx] = point.getCurrentTemp();
        minTemps[idx] = point.getMinTemp();
        maxTemps[idx] = point.getMaxTemp();
        alarmStatus[idx] = point.getAlarmStatus();
        errorStatus[idx] = point.getErrorStatus();
        // Thresholds are updated by config methods, not here
    }
}

void RegisterMap::applyConfigToMeasurementPoint(MeasurementPoint& point) {
    uint8_t idx = point.getAddress();
    if (idx < 60) {
        point.setLowAlarmThreshold(lowAlarmThresholds[idx]);
        point.setHighAlarmThreshold(highAlarmThresholds[idx]);
        //Serial.printf("applyConfigToMeasurementPoint(%d): LAS: %d, HAS: %d\n", idx, lowAlarmThresholds[idx], highAlarmThresholds[idx]);
    }
}

void RegisterMap::applyConfigFromMeasurementPoint(const MeasurementPoint& point) {
    uint8_t idx = point.getAddress();
    if (idx < 60) {
        lowAlarmThresholds[idx] = point.getLowAlarmThreshold();
        highAlarmThresholds[idx] = point.getHighAlarmThreshold();
        //Serial.printf("applyConfigFromMeasurementPoint(%d): LAS: %d, HAS: %d\n", idx, lowAlarmThresholds[idx], highAlarmThresholds[idx]);
    }
}

-------- [ Separator ] ------

File Name: src/Sensor.cpp
Size: 7.31 KB
Code:
#include "Sensor.h"

//SPI PINs
// #define SCK_PIN  14
// #define MISO_PIN  12
// #define MOSI_PIN  13

Sensor::Sensor(SensorType type, uint8_t address, const String& name)
    : address(address), name(name), type(type),
      currentTemp(0), minTemp(32767), maxTemp(-32768),
      lowAlarmThreshold(-40), highAlarmThreshold(85),
      alarmStatus(0), errorStatus(0),
      oneWire(nullptr), dallasTemperature(nullptr), max31865(nullptr)
{
    if (type == SensorType::DS18B20) {
        connection.ds18b20.oneWirePin = 0;
        memset(connection.ds18b20.oneWireAddress, 0, 8);
    } else {
        connection.pt1000.csPin = 0;
        connection.pt1000.maxAddress = 0;
    }
}

Sensor::~Sensor() {
    if (oneWire != nullptr) {
        delete oneWire;
        oneWire = nullptr;
    }
    if (dallasTemperature != nullptr) {
        delete dallasTemperature;
        dallasTemperature = nullptr;
    }
    if (max31865 != nullptr) {
        delete max31865;
        max31865 = nullptr;
    }
}

void Sensor::setupDS18B20(uint8_t pin, const uint8_t* deviceAddress) {
    connection.ds18b20.oneWirePin = pin;
    memcpy(connection.ds18b20.oneWireAddress, deviceAddress, 8);
}

void Sensor::setupPT1000(uint8_t csPin, uint8_t maxAddress) {
    connection.pt1000.csPin = csPin;
    connection.pt1000.maxAddress = maxAddress;
}

bool Sensor::initialize() {
    if (type == SensorType::DS18B20) {
        oneWire = new OneWire(connection.ds18b20.oneWirePin);
        dallasTemperature = new DallasTemperature(oneWire);
        dallasTemperature->begin();
        DeviceAddress deviceAddress;
        memcpy(deviceAddress, connection.ds18b20.oneWireAddress, 8);
        dallasTemperature->setResolution(deviceAddress, 12);
        return dallasTemperature->isConnected(deviceAddress);
    } else if (type == SensorType::PT1000) {
        max31865 = new Adafruit_MAX31865(connection.pt1000.csPin);
        
        // Try to begin the MAX31865
        bool beginSuccess = max31865->begin(MAX31865_3WIRE); // Adjust for your wiring
        
        // if (!beginSuccess) {
        //     errorStatus |= ERROR_COMMUNICATION;
        //     return false;
        // }
        
        // // Check for faults immediately after initialization
        // uint8_t fault = max31865->readFault();
        // if (fault) {
        //     max31865->clearFault();
        //     errorStatus |= ERROR_COMMUNICATION;
        //     return false;
        // }
        
        // // Read RTD value to verify communication
        // uint16_t rtd = max31865->readRTD();
        // if (rtd == 0 || rtd == 0xFFFF) {  // Common values when module is not connected
        //     errorStatus |= ERROR_COMMUNICATION;
        //     // return false;
        // }
        
        // // Calculate resistance to check if it's within reasonable range for PT1000
        // float ratio = rtd / 32768.0;
        // float resistance = 4300.0 * ratio;  // Using RREF of 4300 for PT1000
        
        // // PT1000 should be roughly 1000 ohms at 0°C, with reasonable range between 800-1400 ohms
        // // for normal temperature measurements (-50°C to +100°C)
        // if (resistance < 800.0 || resistance > 2200.0) {
        //     errorStatus |= ERROR_DISCONNECTED;
        //     // return false;
        // }
        
        return true;
    }
    return false;
}

bool Sensor::readTemperature() {
    float tempC = 0.0;
    bool success = false;
    errorStatus &= ~(ERROR_COMMUNICATION | ERROR_OUT_OF_RANGE | ERROR_DISCONNECTED);

    if (type == SensorType::DS18B20) {
        if (dallasTemperature != nullptr) {
            DeviceAddress deviceAddress;
            memcpy(deviceAddress, connection.ds18b20.oneWireAddress, 8);
            if (dallasTemperature->isConnected(deviceAddress)) {
                dallasTemperature->requestTemperaturesByAddress(deviceAddress);
                tempC = dallasTemperature->getTempC(deviceAddress);
                if (tempC != DEVICE_DISCONNECTED_C) {
                    success = true;
                } else {
                    errorStatus |= ERROR_DISCONNECTED;
                }
            } else {
                errorStatus |= ERROR_COMMUNICATION;
            }
        }
    } else if (type == SensorType::PT1000) {
        if (max31865 != nullptr) {
            uint8_t fault = max31865->readFault();
            // if (fault) {
            //     // if (fault & MAX31865_FAULT_HIGHTHRESH || fault & MAX31865_FAULT_LOWTHRESH) {
            //     //     errorStatus |= ERROR_OUT_OF_RANGE;
            //     // }
                if (fault & (MAX31865_FAULT_REFINLOW | MAX31865_FAULT_REFINHIGH |
                             MAX31865_FAULT_RTDINLOW | MAX31865_FAULT_OVUV)) {
                    errorStatus |= ERROR_COMMUNICATION;
                    max31865->clearFault();
                
                } else {
                    tempC = max31865->temperature(1000.0, 4300.0); // PT1000: 1000 ohm at 0°C, adjust reference as needed
                    success = true;
                }
        }
    }

    if (success) {
        if (tempC < -40.0 || tempC > 200.0) {
            errorStatus |= ERROR_OUT_OF_RANGE;
        } else {
            currentTemp = static_cast<int16_t>(round(tempC));
            if (currentTemp < minTemp) minTemp = currentTemp;
            if (currentTemp > maxTemp) maxTemp = currentTemp;
        }
    }
    updateAlarmStatus();
    return success;
}

SensorType Sensor::getType() const { return type; }
uint8_t Sensor::getAddress() const { return address; }
String Sensor::getName() const { return name; }
void Sensor::setName(const String& newName) { name = newName; }

int16_t Sensor::getCurrentTemp() const {return currentTemp; }
int16_t Sensor::getMinTemp() const { return minTemp; }
int16_t Sensor::getMaxTemp() const { return maxTemp; }
int16_t Sensor::getLowAlarmThreshold() const { return lowAlarmThreshold; }
int16_t Sensor::getHighAlarmThreshold() const { return highAlarmThreshold; }
uint8_t Sensor::getAlarmStatus() const { return alarmStatus; }
uint8_t Sensor::getErrorStatus() const { return errorStatus; }

void Sensor::setAddress(uint8_t newAddress) { address = newAddress; }
void Sensor::setLowAlarmThreshold(int16_t threshold) { lowAlarmThreshold = threshold; updateAlarmStatus(); }
void Sensor::setHighAlarmThreshold(int16_t threshold) { highAlarmThreshold = threshold; updateAlarmStatus(); }

const uint8_t* Sensor::getDS18B20Address() const {
    if (type == SensorType::DS18B20) {
        return connection.ds18b20.oneWireAddress;
    }
    return nullptr;
}

void Sensor::resetMinMaxTemp() {
    minTemp = currentTemp;
    maxTemp = currentTemp;
}

void Sensor::updateAlarmStatus() {
    alarmStatus = 0;
    if (errorStatus != 0) return;
    if (currentTemp < lowAlarmThreshold) alarmStatus |= ALARM_LOW_TEMP;
    if (currentTemp > highAlarmThreshold) alarmStatus |= ALARM_HIGH_TEMP;
}


uint8_t Sensor::getPT1000ChipSelectPin() const {
    if (type == SensorType::PT1000) return connection.pt1000.csPin;
    return 0;
}

String Sensor::getDS18B20RomString() const {
    if (type != SensorType::DS18B20) return "";
    char buf[17]; // 16 hex chars + null
    const uint8_t* rom = connection.ds18b20.oneWireAddress;
    for (int i = 0; i < 8; ++i) {
        sprintf(buf + i*2, "%02X", rom[i]);
    }
    return String(buf);
}

void Sensor::getDS18B20RomArray(uint8_t out[8]) const {
    if (type == SensorType::DS18B20) {
        memcpy(out, connection.ds18b20.oneWireAddress, 8);
    }
}
-------- [ Separator ] ------

File Name: src/SettingsCSVManager.cpp
Size: 6.01 KB
Code:
#include "SettingsCSVManager.h"

SettingsCSVManager::SettingsCSVManager(ConfigAssist& config) 
    : _config(config), _lastError("") {
}

String SettingsCSVManager::exportSettingsToCSV() {
    String csv = "Setting,Value\n";
    
    // WiFi Settings
    csv += "st_ssid," + _escapeCSVField(_config("st_ssid")) + "\n";
    csv += "st_pass," + _escapeCSVField(_config("st_pass")) + "\n";
    csv += "host_name," + _escapeCSVField(_config("host_name")) + "\n";
    
    // Device Settings
    csv += "device_id," + _config("device_id") + "\n";
    csv += "firmware_version," + _escapeCSVField(_config("firmware_version")) + "\n";
    csv += "measurement_period," + _config("measurement_period") + "\n";
    
    // Acknowledged Delay Settings
    csv += "ack_delay_critical," + _config("ack_delay_critical") + "\n";
    csv += "ack_delay_high," + _config("ack_delay_high") + "\n";
    csv += "ack_delay_medium," + _config("ack_delay_medium") + "\n";
    csv += "ack_delay_low," + _config("ack_delay_low") + "\n";
    
    // Modbus Settings
    csv += "modbus_enabled," + _config("modbus_enabled") + "\n";
    csv += "modbus_address," + _config("modbus_address") + "\n";
    csv += "modbus_baud_rate," + _config("modbus_baud_rate") + "\n";
    
    return csv;
}

bool SettingsCSVManager::importSettingsFromCSV(const String& csvData) {
    if (!validateSettingsCSV(csvData)) {
        return false;
    }
    
    int lineStart = 0;
    int lineEnd = csvData.indexOf('\n');
    
    // Skip header line
    if (lineEnd == -1) {
        _lastError = "Invalid CSV format";
        return false;
    }
    lineStart = lineEnd + 1;
    
    // Parse each data line
    while (lineStart < csvData.length()) {
        lineEnd = csvData.indexOf('\n', lineStart);
        if (lineEnd == -1) lineEnd = csvData.length();
        
        String line = csvData.substring(lineStart, lineEnd);
        line.trim();
        
        if (line.length() > 0) {
            if (!_parseCSVLine(line)) {
                return false;
            }
        }
        
        lineStart = lineEnd + 1;
    }
    
    return true;
}

bool SettingsCSVManager::validateSettingsCSV(const String& csvData) {
    if (csvData.length() == 0) {
        _lastError = "Empty CSV data";
        return false;
    }
    
    // Check for header line
    int headerEnd = csvData.indexOf('\n');
    if (headerEnd == -1) {
        _lastError = "No header line found";
        return false;
    }
    
    String header = csvData.substring(0, headerEnd);
    if (header.indexOf("Setting") == -1 || header.indexOf("Value") == -1) {
        _lastError = "Invalid header format. Expected 'Setting,Value'";
        return false;
    }
    
    return true;
}

bool SettingsCSVManager::_parseCSVLine(const String& line) {
    int commaIndex = line.indexOf(',');
    if (commaIndex == -1) {
        _lastError = "Invalid CSV line format: " + line;
        return false;
    }
    
    String key = line.substring(0, commaIndex);
    String value = line.substring(commaIndex + 1);
    
    key.trim();
    value = _unescapeCSVField(value);
    
    // Validate and set configuration values
    if (key == "st_ssid" || key == "st_pass" || key == "host_name" || 
        key == "firmware_version" || key == "modbus_baud_rate") {
        // String values
        _config[key] = value;
    } else if (key == "device_id") {
        int deviceId = value.toInt();
        if (deviceId < 1 || deviceId > 9999) {
            _lastError = "Invalid device_id: " + value + " (must be 1-9999)";
            return false;
        }
        _config[key] = value;
    } else if (key == "measurement_period") {
        int period = value.toInt();
        if (period < 1 || period > 3600) {
            _lastError = "Invalid measurement_period: " + value + " (must be 1-3600)";
            return false;
        }
        _config[key] = value;
    } else if (key == "ack_delay_critical" || key == "ack_delay_high" || 
               key == "ack_delay_medium" || key == "ack_delay_low") {
        // Acknowledged delay validation
        int delay = value.toInt();
        if (delay < 1 || delay > 1440) {
            _lastError = "Invalid " + key + ": " + value + " (must be 1-1440 minutes)";
            return false;
        }
        _config[key] = value;
    } else if (key == "modbus_enabled") {
        if (value != "0" && value != "1") {
            String lowerValue = value;
            lowerValue.toLowerCase();
            if (lowerValue != "true" && lowerValue != "false") {
                _lastError = "Invalid modbus_enabled: " + value + " (must be 0/1 or true/false)";
                return false;
            }
            if (lowerValue == "true") value = "1";
            if (lowerValue == "false") value = "0";
        }
        _config[key] = value;
    } else if (key == "modbus_address") {
        int address = value.toInt();
        if (address < 1 || address > 247) {
            _lastError = "Invalid modbus_address: " + value + " (must be 1-247)";
            return false;
        }
        _config[key] = value;
    } else {
        // Unknown setting - log warning but don't fail
        Serial.println("Warning: Unknown setting in CSV: " + key);
        _config[key] = value;  // Still import it in case it's a future setting
    }
    
    return true;
}


String SettingsCSVManager::_escapeCSVField(const String& field) {
    if (field.indexOf(',') >= 0 || field.indexOf('"') >= 0 || field.indexOf('\n') >= 0) {
        String escaped = "\"";
        for (int i = 0; i < field.length(); i++) {
            if (field.charAt(i) == '"') {
                escaped += "\"\"";
            } else {
                escaped += field.charAt(i);
            }
        }
        escaped += "\"";
        return escaped;
    }
    return field;
}

String SettingsCSVManager::_unescapeCSVField(const String& field) {
    String trimmed = field;
    trimmed.trim();
    
    if (trimmed.startsWith("\"") && trimmed.endsWith("\"")) {
        String unescaped = trimmed.substring(1, trimmed.length() - 1);
        unescaped.replace("\"\"", "\"");
        return unescaped;
    }
    return trimmed;
}

-------- [ Separator ] ------

File Name: src/TempModbusServer.cpp
Size: 14.62 KB
Code:
#include "TempModbusServer.h"

TempModbusServer::TempModbusServer(RegisterMap& regMap, 
    uint8_t id, 
    HardwareSerial& serialPort, 
    int rx, 
    int tx, 
    int de,
    int baud) 
: registerMap(regMap), serverID(id), serial(serialPort), 
rxPin(rx), txPin(tx), baudRate(baud), dePin(de) {

// Create ModbusRTU server with 2000ms timeout
mbServer = new ModbusServerRTU(1000, dePin);

// Set static pointer to register map for worker functions
registerMapPtr = &regMap;

// LOG: Modbus server creation
LoggerManager::info("MODBUS", 
"Modbus server created - ID: " + String(id) + 
", Baud: " + String(baud) + 
", RX: " + String(rx) + 
", TX: " + String(tx) + 
", DE: " + String(de));
}


RegisterMap* TempModbusServer::registerMapPtr = nullptr;

TempModbusServer::~TempModbusServer() {
    if (mbServer) {
        // No need to call stop() as it doesn't exist
        delete mbServer;
        mbServer = nullptr;
    }
}


// bool TempModbusServer::begin() {
//     // Prepare serial port for Modbus RTU
//     RTUutils::prepareHardwareSerial(serial);
//     Serial.println("Modbus begin1");
//     if (baudRate == 0) {
//         baudRate = 9600;
//     }
//     serial.begin(baudRate, SERIAL_8N1, rxPin, txPin);
//     Serial.println("Modbus begin2");
    
//     // Register worker functions for different Modbus function codes
//     mbServer->registerWorker(serverID, READ_HOLD_REGISTER, &TempModbusServer::readHoldingRegistersWorker);
//     Serial.println("Modbus begin3");
//     mbServer->registerWorker(serverID, WRITE_HOLD_REGISTER, &TempModbusServer::writeHoldingRegisterWorker);
//     Serial.println("Modbus begin4");
//     mbServer->registerWorker(serverID, WRITE_MULT_REGISTERS, &TempModbusServer::writeMultipleRegistersWorker);
//     Serial.println("Modbus begin5");
    
//     // Start ModbusRTU server - note that begin() returns void
//     mbServer->begin(serial);
//     return true; // Assume success since we can't check
// }

bool TempModbusServer::begin() {
    LoggerManager::info("MODBUS", "Starting Modbus RTU server initialization");
    
    // Prepare serial port for Modbus RTU
    RTUutils::prepareHardwareSerial(serial);
    Serial.println("Modbus begin1");
    
    if (baudRate == 0) {
        baudRate = 9600;
        LoggerManager::warning("MODBUS", "Baud rate was 0, defaulting to 9600");
    }
    
    serial.begin(baudRate, SERIAL_8N1, rxPin, txPin);
    LoggerManager::info("MODBUS", 
        "Serial port initialized - Baud: " + String(baudRate) + 
        ", RX: " + String(rxPin) + 
        ", TX: " + String(txPin));
    Serial.println("Modbus begin2");
    
    // Register worker functions for different Modbus function codes
    mbServer->registerWorker(serverID, READ_HOLD_REGISTER, &TempModbusServer::readHoldingRegistersWorker);
    LoggerManager::info("MODBUS", "Registered READ_HOLD_REGISTER worker (FC=03)");
    Serial.println("Modbus begin3");
    
    mbServer->registerWorker(serverID, WRITE_HOLD_REGISTER, &TempModbusServer::writeHoldingRegisterWorker);
    LoggerManager::info("MODBUS", "Registered WRITE_HOLD_REGISTER worker (FC=06)");
    Serial.println("Modbus begin4");
    
    mbServer->registerWorker(serverID, WRITE_MULT_REGISTERS, &TempModbusServer::writeMultipleRegistersWorker);
    LoggerManager::info("MODBUS", "Registered WRITE_MULT_REGISTERS worker (FC=16)");
    Serial.println("Modbus begin5");
    
    // Start ModbusRTU server - note that begin() returns void
    mbServer->begin(serial);
    
    LoggerManager::info("MODBUS", 
        "Modbus RTU server started successfully - Server ID: " + String(serverID));
    
    return true; // Assume success since we can't check
}



void TempModbusServer::stop() {
    // There is no stop() method in ModbusServerRTU
    // You might want to implement any cleanup needed here
}


// Worker function for READ_HOLD_REGISTER (FC=03)
// ModbusMessage TempModbusServer::readHoldingRegistersWorker(ModbusMessage request) {
//     uint16_t address;           // Requested register address
//     uint16_t words;             // Requested number of registers
//     ModbusMessage response;     // Response message to be sent back
    
//     // Get request values
//     request.get(2, address);
//     request.get(4, words);
    
//     // Check if address and word count are valid
//     if (words > 0 && words <= 125) {  // Max 125 registers per request as per Modbus spec
//         // Set up response header
//         response.add(request.getServerID(), request.getFunctionCode(), (uint8_t)(words * 2));
        
//         // Add requested register values to response
//         bool allValid = true;
//         for (uint16_t i = 0; i < words; i++) {
//             uint16_t regValue = registerMapPtr->readHoldingRegister(address + i);
            
//             // Check if register read was successful - 0xFFFF is often used as an error indicator
//             if (regValue != 0xFFFF) {
//                 response.add(regValue);
//             } else {
//                 allValid = false;
//                 break;
//             }
//         }
        
//         // If any register was invalid, return error response
//         if (!allValid) {
//             response.clear();
//             response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
//         }
//     } else {
//         // Invalid word count, return error response
//         response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
//     }
    
//     return response;
// }

ModbusMessage TempModbusServer::readHoldingRegistersWorker(ModbusMessage request) {
    uint16_t address;           // Requested register address
    uint16_t words;             // Requested number of registers
    ModbusMessage response;     // Response message to be sent back
    
    // Get request values
    request.get(2, address);
    request.get(4, words);
    
    // LOG: Read request received
    LoggerManager::info("MODBUS_READ", 
        "Read request - Address: " + String(address) + 
        ", Count: " + String(words) + 
        ", Client ID: " + String(request.getServerID()));
    
    // Check if address and word count are valid
    if (words > 0 && words <= 125) {  // Max 125 registers per request as per Modbus spec
        // Set up response header
        response.add(request.getServerID(), request.getFunctionCode(), (uint8_t)(words * 2));
        
        // Add requested register values to response
        bool allValid = true;
        String readValues = "";
        
        for (uint16_t i = 0; i < words; i++) {
            uint16_t regValue = registerMapPtr->readHoldingRegister(address + i);
            
            // Check if register read was successful - 0xFFFF is often used as an error indicator
            if (regValue != 0xFFFF) {
                response.add(regValue);
                if (i < 5) { // Log first 5 values to avoid spam
                    readValues += String(address + i) + ":" + String(regValue) + " ";
                } else if (i == 5) {
                    readValues += "...";
                }
            } else {
                allValid = false;
                LoggerManager::error("MODBUS_READ", 
                    "Failed to read register " + String(address + i));
                break;
            }
        }
        
        // If any register was invalid, return error response
        if (!allValid) {
            response.clear();
            response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
            LoggerManager::error("MODBUS_READ", 
                "Read failed - Invalid register address range: " + 
                String(address) + "-" + String(address + words - 1));
        } else {
            LoggerManager::info("MODBUS_READ", 
                "Read successful - " + String(words) + " registers: " + readValues);
        }
    } else {
        // Invalid word count, return error response
        response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
        LoggerManager::error("MODBUS_READ", 
            "Read failed - Invalid word count: " + String(words) + " (max 125)");
    }
    
    return response;
}



// Worker function for WRITE_HOLD_REGISTER (FC=06)
// ModbusMessage TempModbusServer::writeHoldingRegisterWorker(ModbusMessage request) {
//     uint16_t address;           // Register address to write
//     uint16_t value;             // Value to write
//     ModbusMessage response;     // Response message to be sent back
    
//     // Get request values
//     request.get(2, address);
//     request.get(4, value);
    
//     // Try to write the value to the register
//     if (registerMapPtr->writeHoldingRegister(address, value)) {
//         // Success - echo the request as response
//         return request;
//     } else {
//         // Failed - return error response
//         response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
//         return response;
//     }
// }

ModbusMessage TempModbusServer::writeHoldingRegisterWorker(ModbusMessage request) {
    uint16_t address;           // Register address to write
    uint16_t value;             // Value to write
    ModbusMessage response;     // Response message to be sent back
    
    // Get request values
    request.get(2, address);
    request.get(4, value);
    
    // LOG: Write request received
    LoggerManager::info("MODBUS_WRITE", 
        "Write single register - Address: " + String(address) + 
        ", Value: " + String(value) + 
        ", Client ID: " + String(request.getServerID()));
    
    // Try to write the value to the register
    if (registerMapPtr->writeHoldingRegister(address, value)) {
        // Success - echo the request as response
        LoggerManager::info("MODBUS_WRITE", 
            "Write successful - Register " + String(address) + " = " + String(value));
        return request;
    } else {
        // Failed - return error response
        response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
        LoggerManager::error("MODBUS_WRITE", 
            "Write failed - Invalid register address: " + String(address));
        return response;
    }
}


// Worker function for WRITE_MULT_REGISTERS (FC=16)
// ModbusMessage TempModbusServer::writeMultipleRegistersWorker(ModbusMessage request) {
//     uint16_t address;           // Starting register address
//     uint16_t words;             // Number of registers to write
//     uint8_t bytesCount;         // Number of data bytes in request
//     ModbusMessage response;     // Response message to be sent back
    
//     // Get request values
//     request.get(2, address);
//     request.get(4, words);
//     request.get(6, bytesCount);
    
//     // Check if word count is valid
//     if (words > 0 && words <= 123 && bytesCount == words * 2) {  // Max 123 registers per request
//         bool allWritten = true;
        
//         // Write each register value
//         for (uint16_t i = 0; i < words; i++) {
//             uint16_t value;
//             request.get(7 + i * 2, value);
            
//             if (!registerMapPtr->writeHoldingRegister(address + i, value)) {
//                 allWritten = false;
//                 break;
//             }
//         }
        
//         if (allWritten) {
//             // Success - create response with address and word count
//             response.add(request.getServerID(), request.getFunctionCode());
//             response.add(address);
//             response.add(words);
//         } else {
//             // Failed to write at least one register
//             response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
//         }
//     } else {
//         // Invalid word count or byte count
//         response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
//     }
    
//     return response;
// }
ModbusMessage TempModbusServer::writeMultipleRegistersWorker(ModbusMessage request) {
    uint16_t address;           // Starting register address
    uint16_t words;             // Number of registers to write
    uint8_t bytesCount;         // Number of data bytes in request
    ModbusMessage response;     // Response message to be sent back
    
    // Get request values
    request.get(2, address);
    request.get(4, words);
    request.get(6, bytesCount);
    
    // LOG: Multiple write request received
    LoggerManager::info("MODBUS_WRITE", 
        "Write multiple registers - Start: " + String(address) + 
        ", Count: " + String(words) + 
        ", Bytes: " + String(bytesCount) + 
        ", Client ID: " + String(request.getServerID()));
    
    // Check if word count is valid
    if (words > 0 && words <= 123 && bytesCount == words * 2) {  // Max 123 registers per request
        bool allWritten = true;
        String writeValues = "";
        
        // Write each register value
        for (uint16_t i = 0; i < words; i++) {
            uint16_t value;
            request.get(7 + i * 2, value);
            
            if (registerMapPtr->writeHoldingRegister(address + i, value)) {
                if (i < 5) { // Log first 5 values to avoid spam
                    writeValues += String(address + i) + ":" + String(value) + " ";
                } else if (i == 5) {
                    writeValues += "...";
                }
            } else {
                allWritten = false;
                LoggerManager::error("MODBUS_WRITE", 
                    "Failed to write register " + String(address + i) + " = " + String(value));
                break;
            }
        }
        
        if (allWritten) {
            // Success - create response with address and word count
            response.add(request.getServerID(), request.getFunctionCode());
            response.add(address);
            response.add(words);
            LoggerManager::info("MODBUS_WRITE", 
                "Multiple write successful - " + String(words) + " registers: " + writeValues);
        } else {
            // Failed to write at least one register
            response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
            LoggerManager::error("MODBUS_WRITE", 
                "Multiple write failed - Error writing to register range: " + 
                String(address) + "-" + String(address + words - 1));
        }
    } else {
        // Invalid word count or byte count
        response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
        LoggerManager::error("MODBUS_WRITE", 
            "Multiple write failed - Invalid parameters: Words=" + String(words) + 
            ", Bytes=" + String(bytesCount) + " (expected " + String(words * 2) + ")");
    }
    
    return response;
}

-------- [ Separator ] ------

File Name: src/TemperatureController.cpp
Size: 64.40 KB
Code:
#include "TemperatureController.h"

TemperatureController::TemperatureController(uint8_t oneWirePin[4], uint8_t csPin[4], IndicatorInterface& indicator)
: indicator(indicator), 
measurementPeriodSeconds(10), 
deviceId(1), 
firmwareVersion(0x0100),
lastMeasurementTime(0), 
systemInitialized(false), 
_lastAlarmCheck(0),
_lastButtonState(false), 
_lastButtonPressTime(0), 
_currentDisplayedAlarm(nullptr),
_okDisplayStartTime(0), 
_showingOK(false),

_currentActiveAlarmIndex(0), _currentAcknowledgedAlarmIndex(0),
_lastAlarmDisplayTime(0), _acknowledgedAlarmDisplayDelay(5000), // 5 seconds
_displayingActiveAlarm(false)
{
    // Initialize measurement points
    for (uint8_t i = 0; i < 50; ++i)
        dsPoints[i] = MeasurementPoint(i, "DS18B20_Point_" + String(i));
    for (uint8_t i = 0; i < 10; ++i)
        ptPoints[i] = MeasurementPoint(50 + i, "PT1000_Point_" + String(i));
    
    // Initialize bus pins
    for (uint8_t i = 0; i < 4; i++) {
        oneWireBusPin[i] = oneWirePin[i];
        chipSelectPin[i] = csPin[i];
    }
    
    // Initialize OneWire buses
    for (int i = 0; i < 4; ++i) {
        oneWireBuses[i] = new OneWire(oneWireBusPin[i]);
        dallasSensors[i] = new DallasTemperature(oneWireBuses[i]);
    }
}

TemperatureController::~TemperatureController() {
    // Clean up sensors
    for (auto sensor : sensors)
        delete sensor;
    sensors.clear();
    
 
    
    // Clean up OneWire buses
    for (int i = 0; i < 4; ++i) {
        delete dallasSensors[i];
        delete oneWireBuses[i];
    }

    // Clean up configured alarms
    for (auto alarm : _configuredAlarms)
        delete alarm;
    _configuredAlarms.clear();
}

bool TemperatureController::begin() {
    // Initialize register map
    registerMap.writeHoldingRegister(0, deviceId);
    registerMap.writeHoldingRegister(1, firmwareVersion);
    registerMap.writeHoldingRegister(2, 0);
    registerMap.writeHoldingRegister(3, 0);
    for (int i = 4; i <= 10; i++)
        registerMap.writeHoldingRegister(i, 0);
    
    Serial.println("Discovering sensors...");
    discoverPTSensors();
    Serial.println("Setting HMI...");
    
    // Initialize indicator interface
    if (!indicator.begin()) {
        Serial.println("Failed to initialize indicator interface!");
        return false;
    }
    
    // Configure ports
    indicator.setDirection(0b0000000011111111); // P0-P7 as outputs
    
    // Set port names
    indicator.setPortName("BUTTON", 15);
    indicator.setPortName("Relay1", 0);
    indicator.setPortName("Relay2", 1);
    indicator.setPortName("Relay3", 2);
    indicator.setPortName("GreenLED", 4);
    indicator.setPortName("BlueLED", 5);
    indicator.setPortName("YellowLED", 6);
    indicator.setPortName("RedLED", 7);
    
    // Set individual port inversion for ULN2803
    indicator.setPortInverted("Relay1", false);
    indicator.setPortInverted("Relay2", false);
    indicator.setPortInverted("Relay3", false);
    indicator.setPortInverted("GreenLED", false);
    indicator.setPortInverted("BlueLED", false);
    indicator.setPortInverted("YellowLED", false);
    indicator.setPortInverted("RedLED", false);
    indicator.setPortInverted("BUTTON", false);
    
    // Turn off all LEDs initially
    indicator.setAllOutputsLow();
    
    // Set interrupt callback
    indicator.setInterruptCallback([](uint16_t currentState, uint16_t changedPins) {
        Serial.print("PCF8575 Interrupt - State: 0x");
        Serial.print(currentState, HEX);
        Serial.print(", Changed: 0x");
        Serial.println(changedPins, HEX);
    });
    
    // Set normal operation display
    indicator.setOledMode(3);
    indicator.writePort("GreenLED", true); // Normal operation LED
    
    systemInitialized = true;
    Serial.println("Setup complete!");
    indicator.printConfiguration();
    LoggerManager::info("SYSTEM", 
        "TemperatureController started");
    return true;
}

void TemperatureController::update() {
    updateAllSensors();
    readAllPoints();
    
    // Handle PCF8575 interrupts
    indicator.handleInterrupt();
    
    // Update alarm system
    updateAlarms();
    
    // Handle button presses
    _checkButtonPress();
    
    // Handle alarm display and outputs
    handleAlarmDisplay();
    handleAlarmOutputs();
    
    // Update OLED
    indicator.update();
    
    if (!systemInitialized) return;


    unsigned long currentTime = millis();
    if (currentTime - lastMeasurementTime >= measurementPeriodSeconds * 1000) {
        
        updateRegisterMap();
        lastMeasurementTime = currentTime;
        //applyConfigFromRegisterMap();
    }
}

// Alarm Management Methods
void TemperatureController::updateAlarms() {
    unsigned long currentTime = millis();
    if (currentTime - _lastAlarmCheck < _alarmCheckInterval) {
        return;
    }
    _lastAlarmCheck = currentTime;
    
    Serial.println("=== Checking alarms with fresh sensor data ===");
    
    // Check all measurement points for NEW alarm conditions
    for (uint8_t i = 0; i < 50; ++i) {
        if (dsPoints[i].getBoundSensor() != nullptr) {
            Serial.printf("DS Point %d: Temp=%d, High=%d, Low=%d\n",
                         i, dsPoints[i].getCurrentTemp(),
                         dsPoints[i].getHighAlarmThreshold(),
                         dsPoints[i].getLowAlarmThreshold());
            //_checkPointForAlarms(&dsPoints[i]);
        }
    }
    
    for (uint8_t i = 0; i < 10; ++i) {
        if (ptPoints[i].getBoundSensor() != nullptr) {
            Serial.printf("PT Point %d: Temp=%d, High=%d, Low=%d\n",
                         i, ptPoints[i].getCurrentTemp(),
                         ptPoints[i].getHighAlarmThreshold(),
                         ptPoints[i].getLowAlarmThreshold());
            //_checkPointForAlarms(&ptPoints[i]);
        }
    }
    
    // Update existing configured alarms (do NOT remove resolved alarms)
    Serial.println("=== Updating existing alarms ===");
    for (auto alarm : _configuredAlarms) {
        if (alarm->isEnabled()) {
            alarm->updateCondition();
            // Do NOT check for resolved state or remove alarms here
        }
    }
    
    // Sort alarms by priority
    std::sort(_configuredAlarms.begin(), _configuredAlarms.end(), AlarmComparator());
    
    Serial.printf("Active alarms count: %d\n", getActiveAlarms().size());
    
    // Debug: Print all current alarms
    for (auto alarm : _configuredAlarms) {
        if (alarm->isEnabled()) {
            Serial.printf("  Alarm: %s, Stage: %s, Point: %d\n",
                         alarm->getTypeString().c_str(),
                         alarm->getStageString().c_str(),
                         alarm->getSource() ? alarm->getSource()->getAddress() : -1);
        }
    }
}




void TemperatureController::_checkPointForAlarms(MeasurementPoint* point) {
    if (!point || !point->getBoundSensor()) return;
    
    // Check for high temperature alarm
    if (point->getCurrentTemp() >= point->getHighAlarmThreshold()) {
        if (!_hasAlarmForPoint(point, AlarmType::HIGH_TEMPERATURE)) {
            createAlarm(AlarmType::HIGH_TEMPERATURE, point, AlarmPriority::PRIORITY_HIGH);
        }
    }
    
    // Check for low temperature alarm
    if (point->getCurrentTemp() <= point->getLowAlarmThreshold()) {
        if (!_hasAlarmForPoint(point, AlarmType::LOW_TEMPERATURE)) {
            createAlarm(AlarmType::LOW_TEMPERATURE, point, AlarmPriority::PRIORITY_MEDIUM);
        }
    }
    
    // Check for sensor error
    if (point->getErrorStatus() != 0) {
        if (!_hasAlarmForPoint(point, AlarmType::SENSOR_ERROR)) {
            createAlarm(AlarmType::SENSOR_ERROR, point, AlarmPriority::PRIORITY_HIGH);
        }
    }
}

bool TemperatureController::_hasAlarmForPoint(MeasurementPoint* point, AlarmType type) {
    for (auto alarm : _configuredAlarms) {
        if (alarm->getSource() == point && 
            alarm->getType() == type && 
            alarm->isEnabled() &&
            alarm->isActive()) {
            return true;
        }
    }
    return false;
}


void TemperatureController::createAlarm(AlarmType type, MeasurementPoint* source, AlarmPriority priority) {
    // Check if this alarm already exists in configured alarms
    String configKey = "alarm_" + String(source->getAddress()) + "_" + String(static_cast<int>(type));
    
    for (auto alarm : _configuredAlarms) {
        if (alarm->getConfigKey() == configKey) {
            // Alarm already exists, just enable it if it's disabled
            if (!alarm->isEnabled()) {
                alarm->setEnabled(true);
                alarm->setStage(AlarmStage::NEW); // Reset stage
            }
            return;
        }
    }
    
    // Create new alarm and add to configured alarms
    Alarm* newAlarm = new Alarm(type, source, priority);
    newAlarm->setConfigKey(configKey);
    _configuredAlarms.push_back(newAlarm);
    
    // Sort alarms by priority
    std::sort(_configuredAlarms.begin(), _configuredAlarms.end(), AlarmComparator());
}


Alarm* TemperatureController::getHighestPriorityAlarm() const {
    for (auto alarm : _configuredAlarms) {
        if (alarm->isEnabled() && alarm->isActive()) {
            return alarm;
        }
    }
    return nullptr;
}


void TemperatureController::acknowledgeHighestPriorityAlarm() {
    Alarm* alarm = getHighestPriorityAlarm();
    if (alarm) {
        alarm->acknowledge();
        Serial.printf("Alarm acknowledged: %s\n", alarm->getStatusText().c_str());
    }
}

void TemperatureController::acknowledgeAllAlarms() {
    for (auto alarm : _configuredAlarms) {
        if (alarm->isEnabled() && alarm->isActive() && !alarm->isAcknowledged()) {
            alarm->acknowledge();
        }
    }
}


std::vector<Alarm*> TemperatureController::getActiveAlarms() const {
    std::vector<Alarm*> activeAlarms;
    for (auto alarm : _configuredAlarms) {
        if (alarm->isEnabled() && alarm->isActive()) {
            activeAlarms.push_back(alarm);
        }
    }
    return activeAlarms;
}

void TemperatureController::clearResolvedAlarms() {
    for (auto it = _configuredAlarms.begin(); it != _configuredAlarms.end();) {
        if ((*it)->isResolved()) {
            if (_currentDisplayedAlarm == *it) {
                _currentDisplayedAlarm = nullptr;
            }
            Serial.printf("Manually clearing resolved alarm: %s\n", (*it)->getConfigKey().c_str());
            delete *it;
            it = _configuredAlarms.erase(it);
        } else {
            ++it;
        }
    }
}

void TemperatureController::clearConfiguredAlarms() {
    for (auto it = _configuredAlarms.begin(); it != _configuredAlarms.end();) {
            if (_currentDisplayedAlarm == *it) {
                _currentDisplayedAlarm = nullptr;
            }
            Serial.printf("Manually clearing resolved alarm: %s\n", (*it)->getConfigKey().c_str());
            delete *it;
            it = _configuredAlarms.erase(it);
    }
}



// void TemperatureController::handleAlarmDisplay() {
//     Alarm* highestPriorityAlarm = getHighestPriorityAlarm();
    
//     if (highestPriorityAlarm) {
//         // Display alarm
//         _currentDisplayedAlarm = highestPriorityAlarm;
//         _showingOK = false;
        
//         indicator.setOledMode(2);
//         String displayText = highestPriorityAlarm->getDisplayText();
        
//         // Split display text into lines
//         int newlineIndex = displayText.indexOf('\n');
//         String line1 = displayText.substring(0, newlineIndex);
//         String line2 = displayText.substring(newlineIndex + 1);
        
//         String displayLines[2] = {line1, line2};
//         indicator.printText(displayLines, 2);
        
//     } else if (_currentDisplayedAlarm && !_showingOK) {
//         // No more alarms, show OK for 1 minute
//         _showOKAndTurnOffOLED();
        
//     } else if (_showingOK) {
//         // Check if OK display time has elapsed
//         if (millis() - _okDisplayStartTime >= 60000) { // 1 minute
//             indicator.setOLEDOff();
//             _showingOK = false;
//             _currentDisplayedAlarm = nullptr;
//         }
        
//     } else {
//         // Normal operation - show normal display
//         _updateNormalDisplay();
//     }
// }

// void TemperatureController::handleAlarmOutputs() {
//     Alarm* highestPriorityAlarm = getHighestPriorityAlarm();
    
//     if (highestPriorityAlarm) {
//         // Handle alarm outputs based on type and stage
//         if (highestPriorityAlarm->getType() == AlarmType::HIGH_TEMPERATURE) {
//             // High temperature alarm
//             indicator.writePort("RedLED", true);
//             indicator.writePort("GreenLED", false);
            
//             if (!highestPriorityAlarm->isAcknowledged()) {
//                 indicator.writePort("Relay1", true);
//             } else {
//                 indicator.writePort("Relay1", false);
//             }
//             indicator.writePort("Relay2", true);
//         }
//         // Add other alarm type handling here
        
//     } else {
//         // No active alarms - normal operation
//         indicator.writePort("GreenLED", true);
//         indicator.writePort("RedLED", false);
//         indicator.writePort("Relay1", false);
//         indicator.writePort("Relay2", false);
//     }
// }
void TemperatureController::handleAlarmOutputs() {
    // Get alarm counts by priority and stage for precise control
    int criticalActive = getAlarmCount(AlarmPriority::PRIORITY_CRITICAL, AlarmStage::ACTIVE);
    int criticalAcknowledged = getAlarmCount(AlarmPriority::PRIORITY_CRITICAL, AlarmStage::ACKNOWLEDGED);
    int highActive = getAlarmCount(AlarmPriority::PRIORITY_HIGH, AlarmStage::ACTIVE);
    int highAcknowledged = getAlarmCount(AlarmPriority::PRIORITY_HIGH, AlarmStage::ACKNOWLEDGED);
    int mediumActive = getAlarmCount(AlarmPriority::PRIORITY_MEDIUM, AlarmStage::ACTIVE);
    int mediumAcknowledged = getAlarmCount(AlarmPriority::PRIORITY_MEDIUM, AlarmStage::ACKNOWLEDGED);
    int lowActive = getAlarmCount(AlarmPriority::PRIORITY_LOW, AlarmStage::ACTIVE);
    int lowAcknowledged = getAlarmCount(AlarmPriority::PRIORITY_LOW, AlarmStage::ACKNOWLEDGED);
    
    // Determine highest priority alarm state for output control
    bool hasCritical = (criticalActive + criticalAcknowledged) > 0;
    bool hasHigh = (highActive + highAcknowledged) > 0;
    bool hasMedium = (mediumActive + mediumAcknowledged) > 0;
    bool hasLow = (lowActive + lowAcknowledged) > 0;
    
    // Determine if alarms are acknowledged
    bool criticalAcknowledgedOnly = (criticalActive == 0 && criticalAcknowledged > 0);
    bool highAcknowledgedOnly = (highActive == 0 && highAcknowledged > 0);
    bool mediumAcknowledgedOnly = (mediumActive == 0 && mediumAcknowledged > 0);
    
    // Apply alarm notification logic based on priority and acknowledgment state
    // Following the specification table from PLANNING_RESULTS.md
    
    bool relay1State = false; // Siren
    bool relay2State = false; // Flash beacon
    bool redLedState = false;
    bool yellowLedState = false;
    bool blueLedState = false;
    
    // Stop all blinking first - we'll restart as needed
    indicator.stopBlinking("Relay2");
    indicator.stopBlinking("YellowLED");
    
    if (hasCritical) {
        if (criticalAcknowledgedOnly) {
            // CRITICAL acknowledged: Beacon ON (constant)
            relay2State = true;
        } else {
            // CRITICAL active: Siren ON + Beacon ON (constant)
            relay1State = true;
            relay2State = true;
        }
        // Red LED always on for critical alarms
        redLedState = true;
        yellowLedState = true; // Both LEDs for critical
    } else if (hasHigh) {
        if (highAcknowledgedOnly) {
            // HIGH acknowledged: Beacon ON (blink 2s on/30s off)
            indicator.startBlinking("Relay2", 2000, 30000);
        } else {
            // HIGH active: Beacon ON (constant)
            relay2State = true;
        }
        // Red LED for high priority (when not acknowledged)
        redLedState = !highAcknowledgedOnly;
        yellowLedState = true;
    } else if (hasMedium) {
        if (!mediumAcknowledgedOnly) {
            // MEDIUM active: Beacon ON (blink 2s on/30s off)
            indicator.startBlinking("Relay2", 2000, 30000);
        }
        // MEDIUM acknowledged: Beacon OFF (no relay action)
        // Yellow LED blinking for medium priority
        if (!mediumAcknowledgedOnly) {
            indicator.startBlinking("YellowLED", 2000, 30000);
        }
    } else if (hasLow) {
        // LOW priority: No relay action (as per specification)
        // No LED indication for low priority
    }
    
    // Log alarm summary periodically
    static unsigned long lastSummaryLog = 0;
    unsigned long now = millis();
    if (now - lastSummaryLog > 30000 || // Log every 30 seconds
        (hasCritical || hasHigh || hasMedium) && now - lastSummaryLog > 5000) { // Or every 5 seconds if significant alarms
        
        String summary = "Alarm summary - Critical: " + String(criticalActive) + "/" + String(criticalAcknowledged) + 
                        ", High: " + String(highActive) + "/" + String(highAcknowledged) + 
                        ", Medium: " + String(mediumActive) + "/" + String(mediumAcknowledged) + 
                        ", Low: " + String(lowActive) + "/" + String(lowAcknowledged);
        LoggerManager::info("ALARM_OUTPUT", summary);
        lastSummaryLog = now;
    }
    
    // Update relay states (only if not blinking)
    if (!indicator.isBlinking("Relay1") && relay1State != _relay1State) {
        LoggerManager::info("INDICATION", 
            "Relay1 (Siren) state change: " + String(_relay1State ? "ON" : "OFF") + 
            " -> " + String(relay1State ? "ON" : "OFF"));
        indicator.writePort("Relay1", relay1State);
        _relay1State = relay1State;
    }
    
    if (!indicator.isBlinking("Relay2") && relay2State != _relay2State) {
        LoggerManager::info("INDICATION", 
            "Relay2 (Beacon) state change: " + String(_relay2State ? "ON" : "OFF") + 
            " -> " + String(relay2State ? "ON" : "OFF"));
        indicator.writePort("Relay2", relay2State);
        _relay2State = relay2State;
    }
    
    // Update LED states (only if not blinking)
    if (redLedState != _redLedState) {
        LoggerManager::info("INDICATION", 
            "Red LED state change: " + String(_redLedState ? "ON" : "OFF") + 
            " -> " + String(redLedState ? "ON" : "OFF"));
        indicator.writePort("RedLED", redLedState);
        _redLedState = redLedState;
    }
    
    if (!indicator.isBlinking("YellowLED") && yellowLedState != _yellowLedState) {
        LoggerManager::info("INDICATION", 
            "Yellow LED state change: " + String(_yellowLedState ? "ON" : "OFF") + 
            " -> " + String(yellowLedState ? "ON" : "OFF"));
        indicator.writePort("YellowLED", yellowLedState);
        _yellowLedState = yellowLedState;
    }
    
    if (blueLedState != _blueLedState) {
        LoggerManager::info("INDICATION", 
            "Blue LED state change: " + String(_blueLedState ? "ON" : "OFF") + 
            " -> " + String(blueLedState ? "ON" : "OFF"));
        indicator.writePort("BlueLED", blueLedState);
        _blueLedState = blueLedState;
    }
}


// void TemperatureController::handleAlarmOutputs() {
//     // Calculate new output states using enhanced getAlarmCount methods
//     bool newRelay1 = getAlarmCount(AlarmStage::ACTIVE) > 0;
    
//     // HIGH or CRITICAL priority alarms in ACKNOWLEDGED or ACTIVE states
//     bool highPriorityRelay2 = getAlarmCount(AlarmPriority::PRIORITY_HIGH, AlarmStage::ACKNOWLEDGED, ">=", ">=") > 0;
    
//     // LOW priority alarms in ACKNOWLEDGED or ACTIVE states (for blinking)
//     bool lowPriorityExists = getAlarmCount(AlarmPriority::PRIORITY_LOW, AlarmStage::ACKNOWLEDGED, "==", ">=") > 0;
    
//     // CRITICAL priority alarms in ACKNOWLEDGED or ACTIVE states  
//     bool newRedLed = getAlarmCount(AlarmPriority::PRIORITY_CRITICAL, AlarmStage::ACKNOWLEDGED, "==", ">=") > 0;
    
//     // HIGH priority alarms in ACKNOWLEDGED or ACTIVE states
//     bool newYellowLed = getAlarmCount(AlarmPriority::PRIORITY_HIGH, AlarmStage::ACKNOWLEDGED, "==", ">=") > 0;
    
//     // MEDIUM priority alarms in ACKNOWLEDGED or ACTIVE states
//     bool mediumPriorityBlueLed = getAlarmCount(AlarmPriority::PRIORITY_MEDIUM, AlarmStage::ACKNOWLEDGED, "==", ">=") > 0;
    
//     // Handle blinking for low priority alarms
//     if (lowPriorityExists) {
//         // Start blinking if not already blinking
//         if (!highPriorityRelay2 && !indicator.isBlinking("Relay2")) {
//             indicator.startBlinking("Relay2", 1000, 5000);  // 2s on, 30s off
            

//         }
        
//         if (!indicator.isBlinking("BlueLED")) {
//             indicator.startBlinking("BlueLED", 500, 500);    // 500ms on, 500ms off
//         }
//     } else {
//         // Stop blinking if no low priority alarms
//         indicator.stopBlinking("Relay2");
//         indicator.stopBlinking("BlueLED");
//     }
    
//     // Calculate final states (excluding blinking ports)
//     bool newRelay2 = highPriorityRelay2;  // Don't set if blinking
//     bool newBlueLed = mediumPriorityBlueLed;  // Don't set if blinking
    
//     // Only update non-blinking outputs if state has changed
//     if (newRelay1 != _relay1State) {
//         indicator.writePort("Relay1", newRelay1);
//         _relay1State = newRelay1;
//     }
    
//     // Only control Relay2 directly if not blinking for low priority
//     if (!indicator.isBlinking("Relay2") && newRelay2 != _relay2State) {
//         indicator.writePort("Relay2", newRelay2);
//         _relay2State = newRelay2;
//     }
    
//     if (newRedLed != _redLedState) {
//         indicator.writePort("RedLED", newRedLed);
//         _redLedState = newRedLed;
//     }
    
//     if (newYellowLed != _yellowLedState) {
//         indicator.writePort("YellowLED", newYellowLed);
//         _yellowLedState = newYellowLed;
//     }
    
//     // Only control BlueLED directly if not blinking for low priority
//     if (!indicator.isBlinking("BlueLED") && newBlueLed != _blueLedState) {
//         indicator.writePort("BlueLED", newBlueLed);
//         _blueLedState = newBlueLed;
//     }
// }




// void TemperatureController::_checkButtonPress() {
//     bool currentButtonState = indicator.readPort("BUTTON");
    
//     // Detect button press (HIGH to LOW transition)
//     if (_lastButtonState == true && currentButtonState == false) {
//         if ((millis() - _lastButtonPressTime) > _buttonDebounceDelay) {
//             Serial.println("BUTTON PRESS DETECTED!");
//             acknowledgeHighestPriorityAlarm();
//             _lastButtonPressTime = millis();
//         }
//     }
    
//     _lastButtonState = currentButtonState;
// }

void TemperatureController::_updateNormalDisplay() {
    // Show normal system status
    indicator.setOledMode(3);
    String lines[3] = {
        "System Normal",
        "Temp Monitor",
        "Ready"
    };
    indicator.printText(lines, 3);
}

void TemperatureController::_showOKAndTurnOffOLED() {
    indicator.displayOK();
    _okDisplayStartTime = millis();
    _showingOK = true;
}

String TemperatureController::getAlarmsJson() {
    DynamicJsonDocument doc(4096);
    JsonArray alarmArray = doc.createNestedArray("alarms");
    
    for (auto alarm : _configuredAlarms) {
        JsonObject obj = alarmArray.createNestedObject();
        obj["configKey"] = alarm->getConfigKey();
        obj["type"] = static_cast<int>(alarm->getType());
        obj["priority"] = static_cast<int>(alarm->getPriority());
        obj["enabled"] = alarm->isEnabled();
        obj["pointAddress"] = alarm->getPointAddress();
        obj["stage"] = static_cast<int>(alarm->getStage());
        obj["isActive"] = alarm->isActive();
        obj["isAcknowledged"] = alarm->isAcknowledged();
        obj["timestamp"] = alarm->getTimestamp();
        obj["acknowledgedTime"] = alarm->getAcknowledgedTime();
        obj["acknowledgedTimeLeft"] = alarm->getAcknowledgedTimeLeft();
        
        if (alarm->getSource()) {
            obj["pointName"] = alarm->getSource()->getName();
            obj["currentTemp"] = alarm->getSource()->getCurrentTemp();
            obj["threshold"] = (alarm->getType() == AlarmType::HIGH_TEMPERATURE)
                ? alarm->getSource()->getHighAlarmThreshold()
                : alarm->getSource()->getLowAlarmThreshold();
        }
    }
    
    String output;
    serializeJson(doc, output);
    return output;
}


// void TemperatureController::update() {
//     updateAllSensors();
    
//     // Add this line - handle PCF8575 interrupts
//     indicator.handleInterrupt();
    
//     // Handle alarm logic
    
    
//     // Update OLED
//     indicator.updateOLED();
    
//     if (!systemInitialized) return;
    
//     unsigned long currentTime = millis();
//     if (currentTime - lastMeasurementTime >= measurementPeriodSeconds) {
//         readAllPoints();
//         updateRegisterMap();
//         lastMeasurementTime = currentTime;
//         applyConfigFromRegisterMap();
//     }
// }



MeasurementPoint* TemperatureController::getMeasurementPoint(uint8_t address) {
    if (isDS18B20Address(address))
        return &dsPoints[address];
    if (isPT1000Address(address))
        return &ptPoints[address - 50];
    return nullptr;
}

MeasurementPoint* TemperatureController::getDS18B20Point(uint8_t idx) {
    return (idx < 50) ? &dsPoints[idx] : nullptr;
}

MeasurementPoint* TemperatureController::getPT1000Point(uint8_t idx) {
    return (idx < 10) ? &ptPoints[idx] : nullptr;
}

bool TemperatureController::addSensor(Sensor* sensor) {
    if (!sensor) return false;
    // For DS18B20, check by ROM string
    if (sensor->getType() == SensorType::DS18B20) {
        String romStr = sensor->getDS18B20RomString();
        if (findSensorByRom(romStr)) return false;
    } else if (sensor->getType() == SensorType::PT1000) {
        if (findSensorByChipSelect(sensor->getPT1000ChipSelectPin())) return false;
    }
    sensors.push_back(sensor);
    if (sensor->getType() == SensorType::DS18B20)
        registerMap.incrementActiveDS18B20();
    else
        registerMap.incrementActivePT1000();
    return true;
}

bool TemperatureController::removeSensorByRom(const String& romString) {
    for (auto it = sensors.begin(); it != sensors.end(); ++it) {
        if ((*it)->getType() == SensorType::DS18B20 &&
            (*it)->getDS18B20RomString() == romString) {
            // Unbind from any point
            for (uint8_t i = 0; i < 50; ++i) {
                if (dsPoints[i].getBoundSensor() == *it)
                    dsPoints[i].unbindSensor();
            }
            registerMap.decrementActiveDS18B20();
            delete *it;
            sensors.erase(it);
            return true;
        }
    }
    return false;
}

Sensor* TemperatureController::findSensorByRom(const String& romString) {
    for (auto s : sensors) {
            Serial.println("Sensor ROM" + s->getDS18B20RomString());
        if (s->getType() == SensorType::DS18B20 &&
            s->getDS18B20RomString() == romString)
            return s;
    }
    return nullptr;
}

Sensor* TemperatureController::findSensorByChipSelect(uint8_t csPin) {
    for (auto s : sensors)
        if (s->getType() == SensorType::PT1000 &&
            s->getPT1000ChipSelectPin() == csPin)
            return s;
    return nullptr;
}

Sensor* TemperatureController::getSensorByIndex(int idx) {
    return (idx >= 0 && idx < sensors.size()) ? sensors[idx] : nullptr;
}

bool TemperatureController::bindSensorToPointByRom(const String& romString, uint8_t pointAddress) {
    if(pointAddress > 49) return false;
    Sensor* sensor = findSensorByRom(romString);
    unbindSensorFromPointBySensor(sensor);
    MeasurementPoint* point = getMeasurementPoint(pointAddress);
    if (!sensor || !point){
        LoggerManager::warning("BINDING", 
            "Failed to bind sensor " + romString + " to point " + String(pointAddress));
        
        return false;} 

        point->bindSensor(sensor);
    


        String pointName = point->getName().isEmpty() ? 
            "Point_" + String(pointAddress) : point->getName();
        LoggerManager::info("BINDING", 
            "Sensor " + romString + " bound to point " + String(pointAddress) + 
            " (" + pointName + ")");




    return true;
}

bool TemperatureController::bindSensorToPointByChipSelect(uint8_t csPin, uint8_t pointAddress) {
    Serial.printf("Point address: %d\n", pointAddress);
    if((pointAddress < 50) || (pointAddress > 59)) 
        return false;
    Serial.printf("Point address: %d PASSED!\n", pointAddress);
    Sensor* sensor = findSensorByChipSelect(csPin);
    unbindSensorFromPointBySensor(sensor);
    MeasurementPoint* point = getMeasurementPoint(pointAddress);
    if (!sensor || !point) {
        
        LoggerManager::warning("BINDING", 
            "Failed to bind PT1000 sensor CS" + String(csPin) + 
            " to point " + String(pointAddress));
        return false;}
    point->bindSensor(sensor);
    String pointName = point->getName().isEmpty() ? 
            "Point_" + String(pointAddress) : point->getName();
        LoggerManager::info("BINDING", 
            "PT1000 sensor CS" + String(csPin) + " bound to point " + 
            String(pointAddress) + " (" + pointName + ")");
    return true;
}

bool TemperatureController::unbindSensorFromPoint(uint8_t pointAddress) {
    MeasurementPoint* point = getMeasurementPoint(pointAddress);
    if (!point) {
        LoggerManager::error("BINDING", 
            "Faild to unbound sensor from point " + String(pointAddress) + 
            " (" + point->getName() + ")");
        return false;
    }

    if (point->getBoundSensor()) {
        String sensorInfo = point->getBoundSensor()->getType() == SensorType::DS18B20 ? 
        point->getBoundSensor()->getDS18B20RomString() : 
            "CS" + String(point->getBoundSensor()->getPT1000ChipSelectPin());
        
        LoggerManager::info("BINDING", 
            "Sensor " + sensorInfo + " unbound from point " + String(pointAddress) + 
            " (" + point->getName() + ")");
    }

    point->unbindSensor();
    return true;
}

Sensor* TemperatureController::getBoundSensor(uint8_t pointAddress) {
    MeasurementPoint* point = getMeasurementPoint(pointAddress);
    return point ? point->getBoundSensor() : nullptr;
}

void TemperatureController::readAllPoints() {
    for (uint8_t i = 0; i < 50; ++i)
        dsPoints[i].update();
    for (uint8_t i = 0; i < 10; ++i)
        ptPoints[i].update();
}

void TemperatureController::updateRegisterMap() {
    for (uint8_t i = 0; i < 50; ++i)
        registerMap.updateFromMeasurementPoint(dsPoints[i]);
    for (uint8_t i = 0; i < 10; ++i)
        registerMap.updateFromMeasurementPoint(ptPoints[i]);
}

void TemperatureController::applyConfigFromRegisterMap() {
    for (uint8_t i = 0; i < 50; ++i)
        registerMap.applyConfigToMeasurementPoint(dsPoints[i]);
    for (uint8_t i = 0; i < 10; ++i)
        registerMap.applyConfigToMeasurementPoint(ptPoints[i]);
}

void TemperatureController::applyConfigToRegisterMap() {
    for (uint8_t i = 0; i < 50; ++i)
        registerMap.applyConfigFromMeasurementPoint(dsPoints[i]);
    for (uint8_t i = 0; i < 10; ++i)
        registerMap.applyConfigFromMeasurementPoint(ptPoints[i]);
}

bool TemperatureController::discoverDS18B20Sensors() {
    bool anyAdded = false;
    Serial.println("Discover method started...");
    LoggerManager::info("DISCOVERY", "Starting DS18B20 sensor discovery");
    uint totalFound = 0;
    // OneWire oneWire[] = { OneWire(oneWireBusPin[0]), OneWire(oneWireBusPin[1]), OneWire(oneWireBusPin[2]), OneWire(oneWireBusPin[3]) };
    // DallasTemperature dallasSensors[] = {DallasTemperature(&oneWire[0]), DallasTemperature(&oneWire[1]), DallasTemperature(&oneWire[2]), DallasTemperature(&oneWire[3])};
    for (uint j = 0; j < 4; j++){
        Serial.printf("Discover bus %d pin %d started...\n", j, oneWireBusPin[j]);
        
    //OneWire oneWire(oneWireBusPin[j]);
    
    dallasSensors[j]->begin();

    int deviceCount = dallasSensors[j]->getDeviceCount();
    Serial.printf("Devices on bus %d: %d\n", j, deviceCount);
    if (deviceCount == 0) continue;
    totalFound += deviceCount;

    DeviceAddress sensorAddress;
    if (deviceCount > 0) {
        LoggerManager::info("DISCOVERY", 
            "Found " + String(deviceCount) + " DS18B20 sensors on bus " + String(j));
        }
    

    for (int i = 0; i < deviceCount; i++) {
        if (dallasSensors[j]->getAddress(sensorAddress, i)) {
            Serial.printf("Bus %d. Device %d of %d\n", j, i, deviceCount);
            // Convert ROM to string for uniqueness
            char buf[17];
            for (int u = 0; u < 8; ++u) sprintf(buf + u*2, "%02X", sensorAddress[u]);
            String romString(buf);
            Serial.printf("ROM: %s\n", romString);

            // Check if already exists
            if (findSensorByRom(romString)){
                if(getSensorBus(findSensorByRom(romString)) != j) {
                    removeSensorByRom(romString);
                    Serial.println("Device existed on enother bus. Deleting");
                    //continue;

                } else continue;

            }
             

            String sensorName = "DS18B20_" + romString;
            Sensor* newSensor = new Sensor(SensorType::DS18B20, 0, sensorName); // address field not used for DS
            Serial.printf("Sensor created with name %s on bus %d\n", newSensor->getName(), getSensorBus(newSensor));

            newSensor->setupDS18B20(oneWireBusPin[j], sensorAddress);
            Serial.printf("Sensor %s set on bus %d/ pin %d\n", newSensor->getName(), getSensorBus(newSensor), newSensor->getOneWirePin());

            if (newSensor->initialize()) {
                sensors.push_back(newSensor);
                registerMap.incrementActiveDS18B20();
                anyAdded = true;
                Serial.printf("Sensor %s set on bus %d/ pin %d status: Connected\n", newSensor->getName(), getSensorBus(newSensor), newSensor->getOneWirePin());
                

            } else {
                delete newSensor;
            }
        }
    }
    }

    LoggerManager::info("DISCOVERY", 
        "DS18B20 discovery completed. Total sensors: " + String(totalFound));

    return anyAdded;
}


bool TemperatureController::discoverPTSensors() {
    bool anyAdded = false;
    Serial.println("Discover PT method started...");
    LoggerManager::info("DISCOVERY", "Starting PT1000 sensor discovery");
    for (uint j = 0; j < 4; j++){
        Serial.printf("Bus: %d: PIN: %d", j, chipSelectPin[j]);
    }
    // OneWire oneWire[] = { OneWire(oneWireBusPin[0]), OneWire(oneWireBusPin[1]), OneWire(oneWireBusPin[2]), OneWire(oneWireBusPin[3]) };
    // DallasTemperature dallasSensors[] = {DallasTemperature(&oneWire[0]), DallasTemperature(&oneWire[1]), DallasTemperature(&oneWire[2]), DallasTemperature(&oneWire[3])};
    for (uint j = 0; j < 4; j++){
        Serial.printf("Discover PT: bus %d pin %d started...\n", j, chipSelectPin[j]);
        

        if(findSensorByChipSelect(chipSelectPin[j]) != nullptr){
            Serial.printf("Sensor already discovered on bus %d\n", j);
            continue;

        }
  
        
             

            String sensorName = "PT1000_" + String(j);
            Sensor* newSensor = new Sensor(SensorType::PT1000, j, sensorName); // address field not used for DS
            Serial.printf("Sensor created with name %s on bus %d\n", newSensor->getName(), getSensorBus(newSensor));

            newSensor->setupPT1000(chipSelectPin[j], j);
            Serial.printf("Sensor %s set on bus %d/ pin %d\n", newSensor->getName(), getSensorBus(newSensor), newSensor->getPT1000ChipSelectPin());
            

            if (newSensor->initialize()) {

                


                sensors.push_back(newSensor);
                registerMap.incrementActivePT1000();
                anyAdded = true;
                Serial.printf("Sensor %s set on bus %d/ pin %d status: Connected\n", newSensor->getName(), getSensorBus(newSensor), newSensor->getPT1000ChipSelectPin());
                LoggerManager::info("DISCOVERY", 
                    "Added PT1000 sensor on bus: " + String(getSensorBus(newSensor)) + ", CS pin: " + String(newSensor->getPT1000ChipSelectPin()));

            } else {
                delete newSensor;
            }
        
    
        }
    return anyAdded;
}


String TemperatureController::getSensorsJson() {
    DynamicJsonDocument doc(8192);
    JsonArray sensorArray = doc.createNestedArray("sensors");

    for (auto sensor : sensors) {
        JsonObject obj = sensorArray.createNestedObject();
        obj["type"] = (sensor->getType() == SensorType::DS18B20) ? "DS18B20" : "PT1000";
        obj["name"] = sensor->getName();
        obj["currentTemp"] = sensor->getCurrentTemp();
        obj["minTemp"] = sensor->getMinTemp();
        obj["maxTemp"] = sensor->getMaxTemp();
        obj["lowAlarmThreshold"] = sensor->getLowAlarmThreshold();
        obj["highAlarmThreshold"] = sensor->getHighAlarmThreshold();
        obj["alarmStatus"] = sensor->getAlarmStatus();
        obj["errorStatus"] = sensor->getErrorStatus();
        obj["bus"] = getSensorBus(sensor);

        if (sensor->getType() == SensorType::DS18B20) {
            obj["romString"] = sensor->getDS18B20RomString();
            JsonArray romArr = obj.createNestedArray("romArray");
            uint8_t rom[8];
            sensor->getDS18B20RomArray(rom);
            for (int j = 0; j < 8; ++j) romArr.add(rom[j]);
            
        } else if (sensor->getType() == SensorType::PT1000) {
            obj["chipSelectPin"] = sensor->getPT1000ChipSelectPin();
        }

        // Binding info
        int boundPoint = -1;
        if (sensor->getType() == SensorType::DS18B20) {
            String romString = sensor->getDS18B20RomString();
            for (uint8_t i = 0; i < 50; ++i) {
                Sensor* bound = dsPoints[i].getBoundSensor();
                if (bound && bound->getType() == SensorType::DS18B20 &&
                    bound->getDS18B20RomString() == romString) {
                    boundPoint = dsPoints[i].getAddress();
                    break;
                }
            }
        } else if (sensor->getType() == SensorType::PT1000) {
            for (uint8_t i = 0; i < 10; ++i) {
                Sensor* bound = ptPoints[i].getBoundSensor();
                if (bound && bound == sensor) {
                    boundPoint = ptPoints[i].getAddress();
                    break;
                }
            }
        }
        if (boundPoint >= 0) obj["boundPoint"] = boundPoint;
        else obj["boundPoint"] = nullptr;
    }

    String out;
    serializeJson(doc, out);
    return out;
}

String TemperatureController::getPointsJson() {
    DynamicJsonDocument doc(8192);
    JsonArray pointsArray = doc.createNestedArray("points");

    // DS18B20 points
    for (uint8_t i = 0; i < 50; ++i) { //Should be 50 instad of 2 here
        MeasurementPoint& point = dsPoints[i];
        JsonObject obj = pointsArray.createNestedObject();
        obj["address"] = point.getAddress();
        obj["name"] = point.getName();
        obj["type"] = "DS18B20";
        obj["currentTemp"] = point.getCurrentTemp();
        obj["minTemp"] = point.getMinTemp();
        obj["maxTemp"] = point.getMaxTemp();
        obj["lowAlarmThreshold"] = point.getLowAlarmThreshold();
        obj["highAlarmThreshold"] = point.getHighAlarmThreshold();
        obj["alarmStatus"] = point.getAlarmStatus();
        obj["errorStatus"] = point.getErrorStatus();
        

        Sensor* bound = point.getBoundSensor();
        if (bound && bound->getType() == SensorType::DS18B20) {
            obj["sensorType"] = "DS18B20";
            obj["sensorRomString"] = bound->getDS18B20RomString();
            JsonArray romArr = obj.createNestedArray("sensorRomArray");
            uint8_t rom[8];
            bound->getDS18B20RomArray(rom);
            for (int j = 0; j < 8; ++j) romArr.add(rom[j]);
            obj["bus"] = getSensorBus(bound);
            
        }
    }

    // PT1000 points
    for (uint8_t i = 0; i < 10; ++i) { //should be 10 instaed of 1
        MeasurementPoint& point = ptPoints[i];
        JsonObject obj = pointsArray.createNestedObject();
        obj["address"] = point.getAddress();
        obj["name"] = point.getName();
        obj["type"] = "PT1000";
        obj["currentTemp"] = point.getCurrentTemp();
        obj["minTemp"] = point.getMinTemp();
        obj["maxTemp"] = point.getMaxTemp();
        obj["lowAlarmThreshold"] = point.getLowAlarmThreshold();
        obj["highAlarmThreshold"] = point.getHighAlarmThreshold();
        obj["alarmStatus"] = point.getAlarmStatus();
        obj["errorStatus"] = point.getErrorStatus();

        Sensor* bound = point.getBoundSensor();
        if (bound && bound->getType() == SensorType::PT1000) {
            obj["sensorType"] = "PT1000";
            obj["chipSelectPin"] = bound->getPT1000ChipSelectPin();
            obj["bus"] = getSensorBus(bound);
        }
    }

    String out;
    serializeJson(doc, out);
    return out;
}

String TemperatureController::getSystemStatusJson() {
    DynamicJsonDocument doc(1024);
    doc["deviceId"] = deviceId;
    doc["firmwareVersion"] = firmwareVersion;
    doc["ds18b20Count"] = getDS18B20Count();
    doc["pt1000Count"] = getPT1000Count();
    doc["measurementPeriod"] = measurementPeriodSeconds;
    doc["uptime"] = millis() / 1000;

    JsonArray statusArray = doc.createNestedArray("deviceStatus");
    for (int i = 4; i <= 10; i++) {
        statusArray.add(registerMap.readHoldingRegister(i));
    }

    String jsonString;
    serializeJson(doc, jsonString);
    return jsonString;
}

void TemperatureController::resetMinMaxValues() {
    LoggerManager::info("SYSTEM", "Min/Max temperature values reset");
    for (uint8_t i = 0; i < 50; ++i)
        dsPoints[i].resetMinMaxTemp();
    for (uint8_t i = 0; i < 10; ++i)
        ptPoints[i].resetMinMaxTemp();
}

void TemperatureController::setDeviceId(uint16_t id) {
    uint16_t oldId = deviceId;
    deviceId = id;
    registerMap.writeHoldingRegister(0, deviceId);
    LoggerManager::info("CONFIG", 
        "Device ID changed from " + String(oldId) + " to " + String(deviceId));
}

uint16_t TemperatureController::getDeviceId() const { return deviceId; }

void TemperatureController::setFirmwareVersion(uint16_t version) {
    firmwareVersion = version;
    registerMap.writeHoldingRegister(1, firmwareVersion);
}

uint16_t TemperatureController::getFirmwareVersion() const { return firmwareVersion; }

void TemperatureController::setMeasurementPeriod(uint16_t seconds) {
    measurementPeriodSeconds = seconds;
    if (measurementPeriodSeconds != seconds) {
        uint16_t oldPeriod = measurementPeriodSeconds;
        measurementPeriodSeconds = seconds;
        LoggerManager::info("CONFIG", 
            "Measurement period changed from " + String(oldPeriod) + 
            "s to " + String(measurementPeriodSeconds) + "s");
    }
}

uint16_t TemperatureController::getMeasurementPeriod() const {
    return measurementPeriodSeconds;
}

void TemperatureController::setOneWireBusPin(uint8_t pin, size_t bus) {
    oneWireBusPin[bus] = pin;
}

int TemperatureController::getDS18B20Count() const {
    int count = 0;
    for (auto sensor : sensors) {
        if (sensor->getType() == SensorType::DS18B20) {
            count++;
        }
    }
    return count;
}

int TemperatureController::getPT1000Count() const {
    int count = 0;
    for (auto sensor : sensors) {
        if (sensor->getType() == SensorType::PT1000) {
            count++;
        }
    }
    return count;
}

void TemperatureController::updateAllSensors() {
    for (auto sensor : sensors) {
        sensor->readTemperature();
    }

    for (auto& sensor : sensors) {
        if (sensor->getErrorStatus() != 0) {
            static std::map<Sensor*, unsigned long> lastErrorLog;
            unsigned long now = millis();
            
            // Only log errors every 5 minutes to avoid spam
            if (lastErrorLog[sensor] == 0 || (now - lastErrorLog[sensor]) > 300000) {
                String sensorId = sensor->getType() == SensorType::DS18B20 ? 
                    sensor->getDS18B20RomString() : 
                    "BUS " + String(getSensorBus(sensor));
                
                LoggerManager::error("SENSOR", 
                    "Sensor error detected: " + sensorId + 
                    " (Error code: " + String(sensor->getErrorStatus()) + ")");
                
                lastErrorLog[sensor] = now;
            }
        }
    }
}

uint8_t TemperatureController::getOneWirePin(size_t bus) {
    return oneWireBusPin[bus];
}

int TemperatureController::getSensorBus(Sensor* sensor) {
    if (sensor->getType() == SensorType::DS18B20){
        uint8_t pin = sensor->getOneWirePin();
        for (int i = 0; i < 4; i++) {
            if (oneWireBusPin[i] == pin) return i;
        } 
    } else if(sensor->getType() == SensorType::PT1000) {
        uint8_t pin = sensor->getPT1000ChipSelectPin();
        for (int i = 0; i < 4; i++) {
            if (chipSelectPin[i] == pin) return i;
        } 
    }

        return -1;

    
}



bool TemperatureController::unbindSensorFromPointBySensor(Sensor* sensor) {
    if (!sensor) return false;
    
    bool anyUnbound = false;
    
    // Search through all DS18B20 points
    for (auto& point : dsPoints) {
        if (point.getBoundSensor() == sensor) {
            point.unbindSensor();
            Serial.printf("Unbound sensor %s from DS18B20 point %d\n", 
                         sensor->getName().c_str(), point.getAddress());
            anyUnbound = true;
        }
    }
    
    // Search through all PT1000 points
    for (auto& point : ptPoints) {
        if (point.getBoundSensor() == sensor) {
            point.unbindSensor();
            Serial.printf("Unbound sensor %s from PT1000 point %d\n", 
                         sensor->getName().c_str(), point.getAddress());
            anyUnbound = true;
        }
    }
    
    return anyUnbound;
}



bool TemperatureController::addAlarm(AlarmType type, uint8_t pointAddress, AlarmPriority priority) {
    MeasurementPoint* point = getMeasurementPoint(pointAddress);
    if (!point) return false;
    
    // Check if alarm already exists
    String configKey = "alarm_" + String(pointAddress) + "_" + String(static_cast<int>(type));
    
    for (auto alarm : _configuredAlarms) {
        if (alarm->getConfigKey() == configKey) {
            // Update existing
            alarm->setPriority(priority);
            alarm->setEnabled(true);
            return true;
        }
    }
    
    // Create new alarm
    Alarm* newAlarm = new Alarm(type, point, priority);
    if (newAlarm) {
        unsigned long delay;
        switch (priority) {
            case AlarmPriority::PRIORITY_CRITICAL:
                delay = _acknowledgedDelayCritical;
                break;
            case AlarmPriority::PRIORITY_HIGH:
                delay = _acknowledgedDelayHigh;
                break;
            case AlarmPriority::PRIORITY_MEDIUM:
                delay = _acknowledgedDelayMedium;
                break;
            case AlarmPriority::PRIORITY_LOW:
                delay = _acknowledgedDelayLow;
                break;
            default:
                delay = _acknowledgedDelayMedium;
                break;
        }
        newAlarm->setAcknowledgedDelay(delay);
    }
    newAlarm->setConfigKey(configKey);
    _configuredAlarms.push_back(newAlarm);
    
    Serial.printf("Added alarm configuration: %s\n", configKey.c_str());
    if (newAlarm) {
        MeasurementPoint* point = getMeasurementPoint(pointAddress);
        String pointName = point ? point->getName() : "Unknown";
        LoggerManager::info("ALARM_CONFIG", 
            "Added " + newAlarm->getTypeString() + " alarm for point " + 
            String(pointAddress) + " (" + pointName + ") with priority " + 
            _getPriorityString(priority));
    } else {
        LoggerManager::warning("ALARM_CONFIG", 
            "Failed to add " + newAlarm->getTypeString() + " alarm for point " + 
            String(pointAddress));
    }
    return true;
}

bool TemperatureController::removeAlarm(const String& configKey) {
    for (auto it = _configuredAlarms.begin(); it != _configuredAlarms.end(); ++it) {
        if ((*it)->getConfigKey() == configKey) {
            
            delete *it;
            _configuredAlarms.erase(it);
            Serial.printf("Removed alarm configuration: %s\n", configKey.c_str());
            LoggerManager::info("ALARM_CONFIG", 
                "Removed alarm configuration: " + String(configKey.c_str()));
            return true;
        }
    }
    return false;
}

bool TemperatureController::updateAlarm(const String& configKey, AlarmPriority priority, bool enabled) {
    Alarm* alarm = findAlarm(configKey);
    if (!alarm) return false;
    
    alarm->setPriority(priority);
    alarm->setEnabled(enabled);
    Serial.printf("Updated alarm configuration: %s\n", configKey.c_str());
    return true;
}

Alarm* TemperatureController::findAlarm(const String& configKey) {
    for (auto alarm : _configuredAlarms) {
        if (alarm->getConfigKey() == configKey) {
            return alarm;
        }
    }
    return nullptr;
}

Alarm* TemperatureController::getAlarmByIndex(int idx) {
    return (idx >= 0 && idx < _configuredAlarms.size()) ? _configuredAlarms[idx] : nullptr;
}



// Placeholder methods for alarm handling scenarios
void TemperatureController::handleCriticalAlarms() {
    // TODO: Implement critical alarm handling scenario
    // - Turn on both relays immediately
    // - Red LED on
    // - Display alarm
    // - Wait for acknowledgment
    // - 5-minute delay logic
}

void TemperatureController::handleHighPriorityAlarms() {
    // TODO: Implement high priority alarm handling scenario
    // - Different behavior than critical
    // - Maybe only one relay, yellow LED
}

void TemperatureController::handleMediumPriorityAlarms() {
    // TODO: Implement medium priority alarm handling scenario
}

void TemperatureController::handleLowPriorityAlarms() {
    // TODO: Implement low priority alarm handling scenario
}


bool TemperatureController::bindSensorToPointByBusNumber(uint8_t busNumber, uint8_t pointAddress) {
    // Find PT1000 sensor on the specified bus
    for (auto sensor : sensors) {
        if (sensor->getType() == SensorType::PT1000) {
            uint8_t sensorBus = getSensorBus(sensor);
            if (sensorBus == busNumber) {
                MeasurementPoint* point = getMeasurementPoint(pointAddress);
                if (point) {
                    point->bindSensor(sensor);
                    return true;
                }
            }
        }
    }
    return false;
}




// Implement the setter methods
void TemperatureController::setAcknowledgedDelayCritical(unsigned long delay) {
    _acknowledgedDelayCritical = delay;
    applyAcknowledgedDelaysToAlarms();
}

void TemperatureController::setAcknowledgedDelayHigh(unsigned long delay) {
    _acknowledgedDelayHigh = delay;
    applyAcknowledgedDelaysToAlarms();
}

void TemperatureController::setAcknowledgedDelayMedium(unsigned long delay) {
    _acknowledgedDelayMedium = delay;
    applyAcknowledgedDelaysToAlarms();
}

void TemperatureController::setAcknowledgedDelayLow(unsigned long delay) {
    _acknowledgedDelayLow = delay;
    applyAcknowledgedDelaysToAlarms();
}

// Implement the getter methods
unsigned long TemperatureController::getAcknowledgedDelayCritical() const {
    return _acknowledgedDelayCritical;
}

unsigned long TemperatureController::getAcknowledgedDelayHigh() const {
    return _acknowledgedDelayHigh;
}

unsigned long TemperatureController::getAcknowledgedDelayMedium() const {
    return _acknowledgedDelayMedium;
}

unsigned long TemperatureController::getAcknowledgedDelayLow() const {
    return _acknowledgedDelayLow;
}

// Method to apply delays to all existing alarms
void TemperatureController::applyAcknowledgedDelaysToAlarms() {
    for (auto alarm : _configuredAlarms) {
        unsigned long delay;
        switch (alarm->getPriority()) {
            case AlarmPriority::PRIORITY_CRITICAL:
                delay = _acknowledgedDelayCritical;
                break;
            case AlarmPriority::PRIORITY_HIGH:
                delay = _acknowledgedDelayHigh;
                break;
            case AlarmPriority::PRIORITY_MEDIUM:
                delay = _acknowledgedDelayMedium;
                break;
            case AlarmPriority::PRIORITY_LOW:
                delay = _acknowledgedDelayLow;
                break;
            default:
                delay = _acknowledgedDelayMedium; // Default fallback
                break;
        }
        alarm->setAcknowledgedDelay(delay);
    }
    
    // Also apply to active alarms
    // for (auto alarm : _activeAlarms) {
    //     unsigned long delay;
    //     switch (alarm->getPriority()) {
    //         case AlarmPriority::PRIORITY_CRITICAL:
    //             delay = _acknowledgedDelayCritical;
    //             break;
    //         case AlarmPriority::PRIORITY_HIGH:
    //             delay = _acknowledgedDelayHigh;
    //             break;
    //         case AlarmPriority::PRIORITY_MEDIUM:
    //             delay = _acknowledgedDelayMedium;
    //             break;
    //         case AlarmPriority::PRIORITY_LOW:
    //             delay = _acknowledgedDelayLow;
    //             break;
    //         default:
    //             delay = _acknowledgedDelayMedium;
    //             break;
    //     }
    //     alarm->setAcknowledgedDelay(delay);
    // }
}

// int TemperatureController::getAlarmCount(AlarmPriority priority) const {
//     int count = 0;
//     for (auto alarm : _configuredAlarms) {
//         if (alarm->isEnabled() && alarm->getPriority() == priority) {
//             count++;
//         }
//     }
//     return count;
// }

// int TemperatureController::getAlarmCount(AlarmStage stage) const {
//     int count = 0;
//     for (auto alarm : _configuredAlarms) {
//         if (alarm->isEnabled() && alarm->getStage() == stage) {
//             count++;
//         }
//     }
//     return count;
// }


// Add these method implementations to TemperatureController.cpp
int TemperatureController::getAlarmCount(AlarmPriority priority, const String& comparison) const {
    int count = 0;
    for (auto alarm : _configuredAlarms) {
        if (alarm->isEnabled() && _comparePriority(alarm->getPriority(), priority, comparison)) {
            count++;
        }
    }
    return count;
}

int TemperatureController::getAlarmCount(AlarmStage stage, const String& comparison) const {
    int count = 0;
    for (auto alarm : _configuredAlarms) {
        if (alarm->isEnabled() && _compareStage(alarm->getStage(), stage, comparison)) {
            count++;
        }
    }
    return count;
}

int TemperatureController::getAlarmCount(AlarmPriority priority, AlarmStage stage, 
                                       const String& priorityComparison, 
                                       const String& stageComparison) const {
    int count = 0;
    for (auto alarm : _configuredAlarms) {
        if (alarm->isEnabled() && 
            _comparePriority(alarm->getPriority(), priority, priorityComparison) &&
            _compareStage(alarm->getStage(), stage, stageComparison)) {
            count++;
        }
    }
    return count;
}

// Add these helper method implementations to TemperatureController.cpp
bool TemperatureController::_comparePriority(AlarmPriority alarmPriority, AlarmPriority targetPriority, const String& comparison) const {
    int alarmValue = static_cast<int>(alarmPriority);
    int targetValue = static_cast<int>(targetPriority);
    
    if (comparison == ">" || comparison == "gt") {
        return alarmValue > targetValue;
    } else if (comparison == ">=" || comparison == "gte") {
        return alarmValue >= targetValue;
    } else if (comparison == "<" || comparison == "lt") {
        return alarmValue < targetValue;
    } else if (comparison == "<=" || comparison == "lte") {
        return alarmValue <= targetValue;
    } else if (comparison == "!=" || comparison == "ne") {
        return alarmValue != targetValue;
    } else { // Default to "==" or "eq"
        return alarmValue == targetValue;
    }
}

bool TemperatureController::_compareStage(AlarmStage alarmStage, AlarmStage targetStage, const String& comparison) const {
    int alarmValue = static_cast<int>(alarmStage);
    int targetValue = static_cast<int>(targetStage);
    
    if (comparison == ">" || comparison == "gt") {
        return alarmValue > targetValue;
    } else if (comparison == ">=" || comparison == "gte") {
        return alarmValue >= targetValue;
    } else if (comparison == "<" || comparison == "lt") {
        return alarmValue < targetValue;
    } else if (comparison == "<=" || comparison == "lte") {
        return alarmValue <= targetValue;
    } else if (comparison == "!=" || comparison == "ne") {
        return alarmValue != targetValue;
    } else { // Default to "==" or "eq"
        return alarmValue == targetValue;
    }
}


void TemperatureController::_handleLowPriorityBlinking() {
    unsigned long currentTime = millis();
    unsigned long elapsed = currentTime - _lastLowPriorityBlinkTime;
    
    if (_lowPriorityBlinkState) {
        // Currently ON - check if we should turn OFF
        if (elapsed >= _blinkOnTime) {
            _lowPriorityBlinkState = false;
            _lastLowPriorityBlinkTime = currentTime;
        }
    } else {
        // Currently OFF - check if we should turn ON
        if (elapsed >= _blinkOffTime) {
            _lowPriorityBlinkState = true;
            _lastLowPriorityBlinkTime = currentTime;
        }
    }
}


void TemperatureController::handleAlarmDisplay() {
    // Update alarm queues
    _updateAlarmQueues();
    
    // Handle button press for acknowledgment
    _checkButtonPress();
    
    // Handle alarm display rotation
    _handleAlarmDisplayRotation();
    
    // Update indicator blinking
    indicator.updateBlinking();
}

void TemperatureController::_updateAlarmQueues() {
    _activeAlarmsQueue.clear();
    _acknowledgedAlarmsQueue.clear();
    
    // Get all active alarms from the system
    std::vector<Alarm*> allActiveAlarms = getActiveAlarms();
    
    // Separate alarms into active and acknowledged queues
    for (auto alarm : allActiveAlarms) {
        if (!alarm) continue;
        
        if (alarm->getStage() == AlarmStage::ACTIVE) {
            _activeAlarmsQueue.push_back(alarm);
        } else if (alarm->getStage() == AlarmStage::ACKNOWLEDGED) {
            _acknowledgedAlarmsQueue.push_back(alarm);
        }
    }
    
    // Sort active alarms by priority (highest first), then by timestamp (oldest first)
    std::sort(_activeAlarmsQueue.begin(), _activeAlarmsQueue.end(), 
              [](const Alarm* a, const Alarm* b) {
                  if (a->getPriority() != b->getPriority()) {
                      return static_cast<int>(a->getPriority()) > static_cast<int>(b->getPriority());
                  }
                  return a->getTimestamp() < b->getTimestamp();
              });
    
    // Sort acknowledged alarms by priority (highest first), then by timestamp (oldest first)
    std::sort(_acknowledgedAlarmsQueue.begin(), _acknowledgedAlarmsQueue.end(),
              [](const Alarm* a, const Alarm* b) {
                  if (a->getPriority() != b->getPriority()) {
                      return static_cast<int>(a->getPriority()) > static_cast<int>(b->getPriority());
                  }
                  return a->getTimestamp() < b->getTimestamp();
              });
}
void TemperatureController::_displayNextActiveAlarm() {
    if (_activeAlarmsQueue.empty()) return;
    
    if (_currentActiveAlarmIndex >= _activeAlarmsQueue.size()) {
        _currentActiveAlarmIndex = 0;
    }
    
    _currentDisplayedAlarm = _activeAlarmsQueue[_currentActiveAlarmIndex];
    _showingOK = false;
    
    // Ensure OLED is turned on whenever an alarm is displayed
    indicator.setOLEDOn();
    indicator.setOledMode(2);
    String displayText = _currentDisplayedAlarm->getDisplayText();
    
    int newlineIndex = displayText.indexOf('\n');
    String line1 = displayText.substring(0, newlineIndex);
    String line2 = displayText.substring(newlineIndex + 1);
    
    String displayLines[2] = {line1, line2};
    indicator.printText(displayLines, 2);
    
    Serial.printf("Displaying active alarm: %s\n", displayText.c_str());
}

void TemperatureController::_displayNextAcknowledgedAlarm() {
    if (_acknowledgedAlarmsQueue.empty()) return;
    
    _currentAcknowledgedAlarmIndex = (_currentAcknowledgedAlarmIndex + 1) % _acknowledgedAlarmsQueue.size();
    
    _currentDisplayedAlarm = _acknowledgedAlarmsQueue[_currentAcknowledgedAlarmIndex];
    _lastAlarmDisplayTime = millis();
    _showingOK = false;
    
    // Ensure OLED is turned on whenever an alarm is displayed
    indicator.setOLEDOn();
    indicator.setOledMode(2);
    String displayText = _currentDisplayedAlarm->getDisplayText();
    
    int newlineIndex = displayText.indexOf('\n');
    String line1 = displayText.substring(0, newlineIndex);
    String line2 = displayText.substring(newlineIndex + 1);
    
    String displayLines[2] = {line1, line2};
    indicator.printText(displayLines, 2);
    
    Serial.printf("Displaying acknowledged alarm: %s (%d/%d)\n",
                  displayText.c_str(),
                  _currentAcknowledgedAlarmIndex + 1,
                  _acknowledgedAlarmsQueue.size());
}

void TemperatureController::_handleAlarmDisplayRotation() {
    unsigned long currentTime = millis();
    
    // Priority 1: Display active alarms first
    if (!_activeAlarmsQueue.empty()) {
        _displayingActiveAlarm = true;
        _currentAcknowledgedAlarmIndex = 0;
        
        // Always turn on OLED when there are active alarms
        indicator.setOLEDOn();
        _displayNextActiveAlarm();
        
        if (_currentDisplayedAlarm && _currentDisplayedAlarm->getStage() == AlarmStage::ACKNOWLEDGED) {
            _currentActiveAlarmIndex++;
            if (_currentActiveAlarmIndex >= _activeAlarmsQueue.size()) {
                _currentActiveAlarmIndex = 0;
            }
        }
        return;
    }
    
    // Priority 2: Display acknowledged alarms in round-robin
    if (!_acknowledgedAlarmsQueue.empty()) {
        _displayingActiveAlarm = false;
        
        // Always turn on OLED when there are acknowledged alarms
        indicator.setOLEDOn();
        
        if (_currentDisplayedAlarm == nullptr || 
            _currentDisplayedAlarm->getStage() != AlarmStage::ACKNOWLEDGED ||
            currentTime - _lastAlarmDisplayTime >= _acknowledgedAlarmDisplayDelay) {
            _displayNextAcknowledgedAlarm();
        }
        return;
    }
    
    // No alarms to display - show OK and turn off OLED
    if (_currentDisplayedAlarm && !_showingOK) {
        _showOKAndTurnOffOLED();
    } else if (_showingOK) {
        if (currentTime - _okDisplayStartTime >= 60000) {
            indicator.setOLEDOff();
            _showingOK = false;
            _currentDisplayedAlarm = nullptr;
        }
    } else {
        _updateNormalDisplay();
    }
}

void TemperatureController::_checkButtonPress() {
    // Use the existing indicator interface button reading with built-in debouncing
    bool currentButtonState = indicator.readPort("BUTTON");
    
    // Detect button press (button pressed = true based on your configuration)
    if (currentButtonState && !_lastButtonState) {
        // Button was just pressed
        if (_displayingActiveAlarm && _currentDisplayedAlarm && 
            _currentDisplayedAlarm->getStage() == AlarmStage::ACTIVE) {
            
            _currentDisplayedAlarm->acknowledge();
            
            Serial.printf("Button pressed - Acknowledged alarm: %s\n",
                          _currentDisplayedAlarm->getDisplayText().c_str());
            
            // Move to next active alarm or switch to acknowledged display
            _currentActiveAlarmIndex++;
            if (_currentActiveAlarmIndex >= _activeAlarmsQueue.size()) {
                _currentActiveAlarmIndex = 0;
            }
            
            // Force immediate update of display
            _lastAlarmDisplayTime = 0;
        }
    }
    
    _lastButtonState = currentButtonState;
}

// Helper method to get priority string





    String TemperatureController::_getAlarmTypeString(AlarmType type) const {
        switch (type) {
            case AlarmType::HIGH_TEMPERATURE: return "HIGH_TEMP";
            case AlarmType::LOW_TEMPERATURE: return "LOW_TEMP";
            case AlarmType::SENSOR_ERROR: return "SENSOR_ERROR";
            case AlarmType::SENSOR_DISCONNECTED: return "DISCONNECTED";
            default: return "UNKNOWN";
        }
    }
    
    String TemperatureController::_getPriorityString(AlarmPriority priority) const {
        switch (priority) {
            case AlarmPriority::PRIORITY_LOW: return "LOW";
            case AlarmPriority::PRIORITY_MEDIUM: return "MEDIUM";
            case AlarmPriority::PRIORITY_HIGH: return "HIGH";
            case AlarmPriority::PRIORITY_CRITICAL: return "CRITICAL";
            default: return "UNKNOWN";
        }
    }

-------- [ Separator ] ------

File Name: src/TimeManager.cpp
Size: 11.16 KB
Code:
#include "TimeManager.h"
#include <LittleFS.h>

TimeManager::TimeManager(int sdaPin, int sclPin) 
    : _sdaPin(sdaPin), _sclPin(sclPin), _timezoneOffset(0), 
      _ntpServer("pool.ntp.org"), _ntpUpdateInterval(3600000), // 1 hour
      _ntpSyncEnabled(true), _rtcConnected(false), _timeSet(false),
      _lastNTPSync(0), _lastNTPAttempt(0), _timeClient(nullptr) {
}

TimeManager::~TimeManager() {
    if (_timeClient) {
        delete _timeClient;
    }
}

bool TimeManager::init() {
    // Initialize I2C
    //Wire.begin(_sdaPin, _sclPin);
    
    // Initialize RTC
    if (!_rtc.begin()) {
        Serial.println("TimeManager: Couldn't find RTC");
        _rtcConnected = false;
        return false;
    }
    
    _rtcConnected = true;
    
    // Check if RTC lost power and set compile time if needed
    if (_rtc.lostPower()) {
        Serial.println("TimeManager: RTC lost power, setting compile time");
        setTimeFromCompileTime();
    } else {
        _timeSet = true;
    }
    
    // // Initialize NTP
    // _initializeNTP();
    
    // // Load saved configuration
    // loadConfig();
    
    // Serial.println("TimeManager: Initialized successfully");
    return true;
}

bool TimeManager::begin() {
    // Initialize I2C
    // Wire.begin(_sdaPin, _sclPin);
    
    // // Initialize RTC
    // if (!_rtc.begin()) {
    //     Serial.println("TimeManager: Couldn't find RTC");
    //     _rtcConnected = false;
    //     return false;
    // }
    
    // _rtcConnected = true;
    
    // // Check if RTC lost power and set compile time if needed
    // if (_rtc.lostPower()) {
    //     Serial.println("TimeManager: RTC lost power, setting compile time");
    //     setTimeFromCompileTime();
    // } else {
    //     _timeSet = true;
    // }
    
    // Initialize NTP
    _initializeNTP();
    
    // Load saved configuration
    loadConfig();
    
    Serial.println("TimeManager: Initialized successfully");
    return true;
}

void TimeManager::_initializeNTP() {
    if (_timeClient) {
        delete _timeClient;
    }
    
    _timeClient = new NTPClient(_ntpUDP, _ntpServer.c_str(), _timezoneOffset, _ntpUpdateInterval);
    _timeClient->begin();
}

bool TimeManager::setTimeFromNTP(const char* ntpServer) {
    if (ntpServer) {
        _ntpServer = String(ntpServer);
        _initializeNTP();
    }
    
    if (!_isWiFiConnected()) {
        Serial.println("TimeManager: WiFi not connected for NTP sync");
        return false;
    }
    
    if (_timeClient->update()) {
        unsigned long epochTime = _timeClient->getEpochTime();
        DateTime ntpTime = DateTime(epochTime);
        
        if (_rtcConnected) {
            _rtc.adjust(ntpTime);
        }
        
        _timeSet = true;
        _lastNTPSync = millis();
        
        Serial.printf("TimeManager: Time synchronized with NTP: %s\n", 
                     getFormattedTime().c_str());
        return true;
    }
    
    Serial.println("TimeManager: Failed to get time from NTP");
    return false;
}

bool TimeManager::setTime(int year, int month, int day, int hour, int minute, int second) {
    DateTime newTime(year, month, day, hour, minute, second);
    return setTime(newTime);
}

bool TimeManager::setTime(DateTime dateTime) {
    if (_rtcConnected) {
        _rtc.adjust(dateTime);
        _timeSet = true;
        Serial.printf("TimeManager: Time set to: %s\n", 
                     _formatDateTime(dateTime, "YYYY-MM-DD hh:mm:ss").c_str());
        return true;
    }
    return false;
}

bool TimeManager::setTimeFromUnix(uint32_t unixTime) {
    DateTime newTime(unixTime);
    return setTime(newTime);
}

bool TimeManager::setTimeFromCompileTime() {
    if (_rtcConnected) {
        _rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
        _timeSet = true;
        Serial.println("TimeManager: Time set to compile time");
        return true;
    }
    return false;
}

DateTime TimeManager::getCurrentTime() {
    if (_rtcConnected) {
        DateTime utcTime = _rtc.now();
        return utcTime; //_applyTimezone(utcTime);
    }
    return DateTime((uint32_t)0); // Explicitly cast to uint32_t
}


String TimeManager::getFormattedTime(const String& format) {
    DateTime current = getCurrentTime();
    return _formatDateTime(current, format);
}

String TimeManager::getTimeString() {
    DateTime current = getCurrentTime();
    return _formatDateTime(current, "hh:mm:ss");
}

String TimeManager::getDateString() {
    DateTime current = getCurrentTime();
    return _formatDateTime(current, "YYYY-MM-DD");
}

uint32_t TimeManager::getUnixTime() {
    if (_rtcConnected) {
        return _rtc.now().unixtime();
    }
    return 0;
}

void TimeManager::setTimezone(int offsetHours, int offsetMinutes) {
    _timezoneOffset = (offsetHours * 3600) + (offsetMinutes * 60);
    if (_timeClient) {
        _timeClient->setTimeOffset(_timezoneOffset);
    }
    Serial.printf("TimeManager: Timezone set to GMT%+d:%02d\n", offsetHours, abs(offsetMinutes));
}

void TimeManager::setTimezoneOffset(long offsetSeconds) {
    _timezoneOffset = offsetSeconds;
    if (_timeClient) {
        _timeClient->setTimeOffset(_timezoneOffset);
    }
}

int TimeManager::getTimezoneHours() {
    return _timezoneOffset / 3600;
}

int TimeManager::getTimezoneMinutes() {
    return (_timezoneOffset % 3600) / 60;
}

long TimeManager::getTimezoneOffset() {
    return _timezoneOffset;
}

void TimeManager::setNTPServer(const String& server) {
    _ntpServer = server;
    _initializeNTP();
}

void TimeManager::setNTPUpdateInterval(unsigned long intervalMs) {
    _ntpUpdateInterval = intervalMs;
    if (_timeClient) {
        _timeClient->setUpdateInterval(intervalMs);
    }
}

String TimeManager::getNTPServer() {
    return _ntpServer;
}

void TimeManager::update() {
    // Auto-sync with NTP if enabled and interval elapsed
    if (_ntpSyncEnabled && _isWiFiConnected() && 
        (millis() - _lastNTPSync) > _ntpUpdateInterval &&
        (millis() - _lastNTPAttempt) > 60000) { // Don't attempt more than once per minute
        
        _lastNTPAttempt = millis();
        if (setTimeFromNTP()) {
            Serial.println("TimeManager: Automatic NTP sync successful");
        }
    }
}

bool TimeManager::syncWithNTP() {
    return setTimeFromNTP();
}

bool TimeManager::isNTPSyncEnabled() {
    return _ntpSyncEnabled;
}

void TimeManager::enableNTPSync(bool enable) {
    _ntpSyncEnabled = enable;
}

bool TimeManager::isRTCConnected() {
    return _rtcConnected;
}

bool TimeManager::isTimeSet() {
    return _timeSet;
}

bool TimeManager::hasLostPower() {
    return _rtcConnected ? _rtc.lostPower() : true;
}

unsigned long TimeManager::getLastNTPSync() {
    return _lastNTPSync;
}

float TimeManager::getTemperature() {
    if (_rtcConnected) {
        return _rtc.getTemperature();
    }
    return NAN;
}

bool TimeManager::setAlarm1(DateTime alarmTime, Ds3231Alarm1Mode mode) {
    if (_rtcConnected) {
        return _rtc.setAlarm1(alarmTime, mode);
    }
    return false;
}

bool TimeManager::setAlarm2(DateTime alarmTime, Ds3231Alarm2Mode mode) {
    if (_rtcConnected) {
        return _rtc.setAlarm2(alarmTime, mode);
    }
    return false;
}

bool TimeManager::clearAlarm1() {
    if (_rtcConnected) {
        _rtc.clearAlarm(1);
        return true; // Just return true after calling
    }
    return false;
}

bool TimeManager::clearAlarm2() {
    if (_rtcConnected) {
        _rtc.clearAlarm(2);
        return true; // Just return true after calling
    }
    return false;
}


bool TimeManager::isAlarm1Triggered() {
    if (_rtcConnected) {
        return _rtc.alarmFired(1);
    }
    return false;
}

bool TimeManager::isAlarm2Triggered() {
    if (_rtcConnected) {
        return _rtc.alarmFired(2);
    }
    return false;
}

void TimeManager::enableSquareWave(Ds3231SqwPinMode mode) {
    if (_rtcConnected) {
        _rtc.writeSqwPinMode(mode);
    }
}

void TimeManager::disableSquareWave() {
    if (_rtcConnected) {
        _rtc.writeSqwPinMode(DS3231_OFF);
    }
}

String TimeManager::getTimeJSON() {
    DynamicJsonDocument doc(512);
    
    DateTime current = getCurrentTime();
    doc["timestamp"] = current.unixtime();
    doc["formatted"] = getFormattedTime();
    doc["date"] = getDateString();
    doc["time"] = getTimeString();
    doc["timezone_offset"] = _timezoneOffset;
    doc["timezone_hours"] = getTimezoneHours();
    doc["timezone_minutes"] = getTimezoneMinutes();
    
    String output;
    serializeJson(doc, output);
    return output;
}

String TimeManager::getStatusJSON() {
    DynamicJsonDocument doc(512);
    
    doc["rtc_connected"] = _rtcConnected;
    doc["time_set"] = _timeSet;
    doc["has_lost_power"] = hasLostPower();
    doc["ntp_enabled"] = _ntpSyncEnabled;
    doc["ntp_server"] = _ntpServer;
    doc["last_ntp_sync"] = _lastNTPSync;
    doc["wifi_connected"] = _isWiFiConnected();
    
    if (_rtcConnected) {
        doc["temperature"] = _rtc.getTemperature();
        doc["alarm1_triggered"] = isAlarm1Triggered();
        doc["alarm2_triggered"] = isAlarm2Triggered();
    }
    
    String output;
    serializeJson(doc, output);
    return output;
}

void TimeManager::saveConfig() {
    DynamicJsonDocument doc(256);
    doc["timezone_offset"] = _timezoneOffset;
    doc["ntp_server"] = _ntpServer;
    doc["ntp_update_interval"] = _ntpUpdateInterval;
    doc["ntp_sync_enabled"] = _ntpSyncEnabled;
    
    File file = LittleFS.open("/time_config.json", "w");
    if (file) {
        serializeJson(doc, file);
        file.close();
        Serial.println("TimeManager: Configuration saved");
    }
}

void TimeManager::loadConfig() {
    File file = LittleFS.open("/time_config.json", "r");
    if (file) {
        DynamicJsonDocument doc(256);
        DeserializationError error = deserializeJson(doc, file);
        file.close();
        
        if (!error) {
            _timezoneOffset = doc["timezone_offset"] | 0;
            _ntpServer = doc["ntp_server"] | "pool.ntp.org";
            _ntpUpdateInterval = doc["ntp_update_interval"] | 3600000;
            _ntpSyncEnabled = doc["ntp_sync_enabled"] | true;
            
            // Reinitialize NTP with loaded settings
            _initializeNTP();
            
            Serial.println("TimeManager: Configuration loaded");
        }
    }
}

// Private helper methods
bool TimeManager::_isWiFiConnected() {
    return WiFi.status() == WL_CONNECTED;
}

DateTime TimeManager::_applyTimezone(DateTime utcTime) {
    return DateTime(utcTime.unixtime() + _timezoneOffset);
}

DateTime TimeManager::_removeTimezone(DateTime localTime) {
    return DateTime(localTime.unixtime() - _timezoneOffset);
}

String TimeManager::_formatDateTime(DateTime dt, const String& format) {
    String result = format;
    
    // Replace format tokens
    result.replace("YYYY", String(dt.year()));
    result.replace("MM", String(dt.month()).length() == 1 ? "0" + String(dt.month()) : String(dt.month()));
    result.replace("DD", String(dt.day()).length() == 1 ? "0" + String(dt.day()) : String(dt.day()));
    result.replace("hh", String(dt.hour()).length() == 1 ? "0" + String(dt.hour()) : String(dt.hour()));
    result.replace("mm", String(dt.minute()).length() == 1 ? "0" + String(dt.minute()) : String(dt.minute()));
    result.replace("ss", String(dt.second()).length() == 1 ? "0" + String(dt.second()) : String(dt.second()));
    
    return result;
}

-------- [ Separator ] ------

File Name: src/main.cpp
Size: 5.88 KB
Code:
#include <Arduino.h>
#include "TemperatureController.h"
#include "TempModbusServer.h"
#include "ConfigManager.h"
#include "IndicatorInterface.h"
#include <SPI.h>
#include "TimeManager.h"
#include "LoggerManager.h"



// Create temperature controller

//DS18B20 PINs
#define BUS1_PIN  4
#define BUS2_PIN  5
#define BUS3_PIN  18
#define BUS4_PIN  19

//PT1000 PINs
//SPI PINs
#define SCK_PIN  14
#define MISO_PIN  12
#define MOSI_PIN  13

#define CS1_PIN  32
#define CS2_PIN  33
#define CS3_PIN  26
#define CS4_PIN  27

#define CS5_PIN_TF_CARD  0


//RS485 PINs
#define RX_PIN  22 //to rxd
#define TX_PIN  23 //to txd
#define DE_PIN  -1



// I2C pins for WROVER (avoiding conflicts)
#define I2C_SDA 21  // Default SDA, available
#define I2C_SCL 25  // Alternative SCL (GPIO 22 used by RS485)
#define PCF_INT 34 // PCF expander interupt pin

IndicatorInterface indicator(Wire, 0x20, PCF_INT);  // I2C address 0x20, INT pin 34




uint8_t onwWirePins[4] = {BUS1_PIN,  BUS2_PIN, BUS3_PIN, BUS4_PIN};
uint8_t csPins[4] = {CS1_PIN,  CS2_PIN, CS3_PIN, CS4_PIN};
TemperatureController controller(onwWirePins, csPins, indicator);

// Create configuration manager
ConfigManager* configManager;

// Create Modbus server
TempModbusServer* modbusServer;

TimeManager timeManager(I2C_SDA, I2C_SCL);

LoggerManager logger(controller, timeManager, SD);

void setup() {
    // Initialize serial for debugging
    Serial.begin(115200);
    while (!Serial) {}
        // Initialize I2C
    Wire.begin(I2C_SDA, I2C_SCL);
    Wire.setClock(100000);

    SPI.begin(SCK_PIN, MISO_PIN, MOSI_PIN);  // SCK, MISO, MOSI, SS



    // Initialize time manager
    if (timeManager.init()) {
        Serial.println("TimeManager initialized successfully");
        
        // Set timezone (GMT+3 for Moscow)
        timeManager.setTimezone(3, 0);
        
  
    }

    // Configure logging
    logger.setLogDirectory("/data"); 
    logger.setAlarmStateLogDirectory("/alarms");
    logger.setEventLogDirectory("/events");
    logger.setLogFrequency(2000);  // Log every 30 seconds
    logger.setDailyFiles(true);     // Create new file each day
    logger.setEnabled(true);        // Enable logging

    // Initialize SD card
    if (!SD.begin(CS5_PIN_TF_CARD)) {
        Serial.println("SD Card initialization failed");
        logger.setEnabled(false);
        //return;
    }
    
    // Initialize logger
    if (!logger.init()) {
        Serial.println("Logger initialization failed");
    } else {
        Serial.println("Logger initialized successfully");
    }
    
    logger.info("SYSTEM", "Temperature controller started");




    

    // Configure all CS pins as OUTPUT
    pinMode(CS1_PIN, OUTPUT);
    pinMode(CS2_PIN, OUTPUT); 
    pinMode(CS3_PIN, OUTPUT);
    pinMode(CS4_PIN, OUTPUT);
    //pinMode(CS5_PIN, OUTPUT);
    
    // Set all CS pins HIGH initially (inactive)
    digitalWrite(CS1_PIN, HIGH);
    digitalWrite(CS2_PIN, HIGH);
    digitalWrite(CS3_PIN, HIGH);
    digitalWrite(CS4_PIN, HIGH);
    //digitalWrite(CS5_PIN, HIGH);



    Serial.println("\nIndustrial Temperature Monitoring System");
    Serial.println("--------------------------------------");
    //controller = new TemperatureController(onwWirePins);
    Serial.println("\nController created");
    
    // Initialize controller
    controller.begin();
    Serial.println("\nController begin");
    
    // Initialize configuration manager
    configManager = new ConfigManager(controller);
    if (!configManager->begin()) {
        Serial.println("Failed to initialize configuration manager");
    }
    
    // Apply configuration to controller
    controller.setDeviceId(configManager->getDeviceId());
    Serial.println("controller.setDeviceId(configManager->getDeviceId());");
    controller.setMeasurementPeriod(configManager->getMeasurementPeriod()*1000);
    Serial.println("controller.setMeasurementPeriod(configManager->getMeasurementPeriod());");
    //controller.setOneWireBusPin(configManager->getOneWirePin());
    Serial.println("controller.setOneWireBusPin(configManager->getOneWirePin());");
    
    //Discover DS18B20 sensors
    controller.discoverDS18B20Sensors();
    controller.discoverPTSensors();
    // Initialize Modbus server if enabled in config
    if (configManager->isModbusEnabled()) {
        Serial.println("Init Modbus RTU server...");
        modbusServer = new TempModbusServer(
            controller.getRegisterMap(),
            configManager->getModbusAddress(),
            Serial2,
            RX_PIN,
            TX_PIN,
            DE_PIN,
            configManager->getModbusBaudRate()
        );
        Serial.println("Init Modbus RTU server!");

        
        if (modbusServer->begin()) {
            Serial.println("Modbus RTU server started successfully");
        } else {
            Serial.println("Failed to start Modbus RTU server");
        }
    }


    if(timeManager.begin()){
          // Sync with NTP when WiFi connects
          if (WiFi.status() == WL_CONNECTED) {
            timeManager.setTimeFromNTP();
        }
    }
    
    logger.begin();


    

    
    Serial.println("\nSystem is now running...");
}

void loop() {
    // Update configuration manager
    timeManager.update();
    configManager->update();
    
    // Update controller (reads sensors and updates register map)
    controller.update();
    
    // Print status every 30 seconds if not in portal mode
    static unsigned long lastPrintTime = 0;
    if (!configManager->isPortalActive() && millis() - lastPrintTime > controller.getMeasurementPeriod()) {
        //Serial.println("\nSensors Status:");
        //Serial.println(controller.getSystemStatusJson());
        //Serial.println(controller.getSensorsJson());
        //Serial.println("\nPoints Status:");
        //Serial.println(controller.getSystemStatusJson());
        //Serial.println(controller.getPointsJson());
        
        lastPrintTime = millis();
    }
    logger.update();
    
    // Small delay to prevent CPU hogging
    delay(100);
}

-------- [ Separator ] ------

File Name: test/alarm-history.html_
Size: 22.15 KB
Code:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temperature Controller - Alarm History</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        nav {
            margin-bottom: 20px;
            padding: 10px;
            background: #007bff;
            border-radius: 5px;
        }
        nav a {
            color: white;
            text-decoration: none;
            margin-right: 15px;
            padding: 5px 10px;
            border-radius: 3px;
        }
        nav a:hover {
            background: rgba(255,255,255,0.2);
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .controls button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-primary {
            background-color: #007bff;
            color: white;
        }
        .btn-success {
            background-color: #28a745;
            color: white;
        }
        .btn-warning {
            background-color: #ffc107;
            color: black;
        }
        .btn-danger {
            background-color: #dc3545;
            color: white;
        }
        .btn:hover {
            opacity: 0.8;
        }
        .filter-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .filter-group label {
            font-weight: bold;
            margin-right: 5px;
        }
        .filter-group select, .filter-group input {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        .date-range {
            display: flex;
            gap: 10px;
            align-items: center;
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        th:hover {
            background-color: #e9ecef;
        }
        th.sortable::after {
            content: " ↕";
            color: #999;
            font-size: 12px;
        }
        th.sort-asc::after {
            content: " ↑";
            color: #007bff;
            font-weight: bold;
        }
        th.sort-desc::after {
            content: " ↓";
            color: #007bff;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .priority-critical {
            background-color: #f8d7da;
            color: #721c24;
            font-weight: bold;
        }
        .priority-high {
            background-color: #ffeaa7;
            color: #856404;
            font-weight: bold;
        }
        .priority-medium {
            background-color: #d1ecf1;
            color: #0c5460;
        }
        .priority-low {
            background-color: #d4edda;
            color: #155724;
        }
        .alarm-type {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .type-high-temp {
            background-color: #ff6b6b;
            color: white;
        }
        .type-low-temp {
            background-color: #4ecdc4;
            color: white;
        }
        .type-sensor-error {
            background-color: #ffe66d;
            color: black;
        }
        .type-sensor-disconnected {
            background-color: #a8e6cf;
            color: black;
        }
        .no-history {
            text-align: center;
            padding: 40px;
            color: #6c757d;
            font-style: italic;
        }
        .timestamp {
            font-size: 12px;
            color: #6c757d;
        }
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
        }
        .pagination button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            background: white;
            cursor: pointer;
            border-radius: 4px;
        }
        .pagination button:hover {
            background: #f8f9fa;
        }
        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .pagination .current-page {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
    </style>
</head>
<body>
    <div class="container">
        <nav>
            <a href="/dashboard.html">Home</a>
            <a href="/sensors.html">Sensors</a>
            <a href="/points.html">Points</a>
            <a href="/alarms.html">Alarms</a>
            <a href="/alarm-history.html">Alarm History</a>
            <a href="/config">Configuration</a>
        </nav>

        <h1>Alarm History</h1>

        <!-- Controls -->
        <div class="controls">
            <div class="date-range">
                <label>Date Range:</label>
                <input type="date" id="startDate">
                <span>to</span>
                <input type="date" id="endDate">
                <button class="btn btn-primary" onclick="loadHistory()">🔍 Load History</button>
            </div>
            
            <button class="btn btn-success" onclick="exportHistory()">📥 Export CSV</button>
            
            <div class="filter-group">
                <label>Filter by Point:</label>
                <select id="pointFilter" onchange="filterTable()">
                    <option value="">All Points</option>
                </select>
            </div>

            <div class="filter-group">
                <label>Filter by Type:</label>
                <select id="typeFilter" onchange="filterTable()">
                    <option value="">All Types</option>
                    <option value="0">High Temperature</option>
                    <option value="1">Low Temperature</option>
                    <option value="2">Sensor Error</option>
                    <option value="3">Sensor Disconnected</option>
                </select>
            </div>

            <div class="filter-group">
                <label>Filter by Priority:</label>
                <select id="priorityFilter" onchange="filterTable()">
                    <option value="">All Priorities</option>
                    <option value="3">Critical</option>
                    <option value="2">High</option>
                    <option value="1">Medium</option>
                    <option value="0">Low</option>
                </select>
            </div>
        </div>

        <!-- History Table -->
        <table id="historyTable">
            <thead>
                <tr>
                    <th class="sortable" onclick="sortTable(0)">Point</th>
                    <th class="sortable" onclick="sortTable(1)">Point Name</th>
                    <th class="sortable" onclick="sortTable(2)">Type</th>
                    <th class="sortable" onclick="sortTable(3)">Priority</th>
                    <th class="sortable" onclick="sortTable(4)">Event</th>
                    <th class="sortable" onclick="sortTable(5)">Temperature</th>
                    <th class="sortable" onclick="sortTable(6)">Threshold</th>
                    <th class="sortable" onclick="sortTable(7)">Timestamp</th>
                    <th class="sortable" onclick="sortTable(8)">Duration</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td colspan="9" class="no-history">Select a date range and click "Load History" to view alarm events</td>
                </tr>
            </tbody>
        </table>

        <!-- Pagination -->
        <div class="pagination" id="pagination" style="display: none;">
            <button id="prevPage" onclick="changePage(-1)">← Previous</button>
            <span id="pageInfo">Page 1 of 1</span>
            <button id="nextPage" onclick="changePage(1)">Next →</button>
        </div>
    </div>

    <script>
        let historyData = [];
        let filteredData = [];
        let sortColumn = -1;
        let sortDirection = 'asc';
        let currentPage = 1;
        const itemsPerPage = 100;

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            // Set default date range (last 7 days)
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 7);
            
            document.getElementById('endDate').value = endDate.toISOString().split('T')[0];
            document.getElementById('startDate').value = startDate.toISOString().split('T')[0];
            
            loadPointsForFilter();
        });

        // Load points for filter dropdown
        async function loadPointsForFilter() {
            try {
                const response = await fetch('/api/points');
                const data = await response.json();
                const pointFilter = document.getElementById('pointFilter');
                
                // Clear existing options except "All Points"
                pointFilter.innerHTML = '<option value="">All Points</option>';
                
                if (data.points) {
                    data.points.forEach(point => {
                        const option = document.createElement('option');
                        option.value = point.address;
                        option.textContent = `${point.address} - ${point.name || 'Unnamed'}`;
                        pointFilter.appendChild(option);
                    });
                }
            } catch (error) {
                console.error('Error loading points:', error);
            }
        }

        // Load alarm history from API
        async function loadHistory() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            if (!startDate || !endDate) {
                alert('Please select both start and end dates');
                return;
            }
            
            if (new Date(startDate) > new Date(endDate)) {
                alert('Start date must be before end date');
                return;
            }

            try {
                const response = await fetch(`/api/alarm-history?start=${startDate}&end=${endDate}`);
                const data = await response.json();
                
                if (data.success) {
                    historyData = data.history || [];
                    currentPage = 1;
                    displayHistory();
                } else {
                    throw new Error(data.error || 'Failed to load history');
                }
            } catch (error) {
                console.error('Error loading alarm history:', error);
                document.querySelector('#historyTable tbody').innerHTML = 
                    '<tr><td colspan="9" class="no-history">Error loading alarm history: ' + error.message + '</td></tr>';
            }
        }

        // Display history in table
        function displayHistory() {
            const tbody = document.querySelector('#historyTable tbody');
            
            if (historyData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" class="no-history">No alarm history found for the selected date range</td></tr>';
                document.getElementById('pagination').style.display = 'none';
                return;
            }

            // Apply filters
            filterTable();
        }

        // Create table row for history entry
        function createHistoryRow(entry) {
            const row = document.createElement('tr');
            
            const timestamp = new Date(entry.timestamp).toLocaleString();
            const duration = formatDuration(entry.duration);
            
            row.innerHTML = `
                <td>${entry.pointAddress}</td>
                <td>${entry.pointName || 'Unknown'}</td>
                <td><span class="alarm-type ${getTypeClass(entry.alarmType)}">${getTypeText(entry.alarmType)}</span></td>
                <td><span class="priority-${getPriorityClass(entry.priority)}">${getPriorityText(entry.priority)}</span></td>
                <td>${entry.event}</td>
                <td>${entry.temperature !== undefined ? entry.temperature + '°C' : 'N/A'}</td>
                <td>${entry.threshold !== undefined ? entry.threshold + '°C' : 'N/A'}</td>
                <td><span class="timestamp">${timestamp}</span></td>
                <td>${duration}</td>
            `;
            
            // Set data attributes for filtering
            row.dataset.point = entry.pointAddress;
            row.dataset.type = entry.alarmType;
            row.dataset.priority = entry.priority;
            
            return row;
        }

        // Helper functions
        function getTypeText(type) {
            const types = ['High Temp', 'Low Temp', 'Sensor Error', 'Disconnected'];
            return types[type] || 'Unknown';
        }

        function getTypeClass(type) {
            const classes = ['type-high-temp', 'type-low-temp', 'type-sensor-error', 'type-sensor-disconnected'];
            return classes[type] || '';
        }

        function getPriorityText(priority) {
            const priorities = ['Low', 'Medium', 'High', 'Critical'];
            return priorities[priority] || 'Unknown';
        }

        function getPriorityClass(priority) {
            const classes = ['low', 'medium', 'high', 'critical'];
            return classes[priority] || 'low';
        }

        function formatDuration(durationMs) {
            if (!durationMs || durationMs <= 0) return '-';
            
            const seconds = Math.floor(durationMs / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            
            if (days > 0) {
                return `${days}d ${hours % 24}h ${minutes % 60}m`;
            } else if (hours > 0) {
                return `${hours}h ${minutes % 60}m`;
            } else if (minutes > 0) {
                return `${minutes}m ${seconds % 60}s`;
            } else {
                return `${seconds}s`;
            }
        }

        // Filter table function
        function filterTable() {
            const pointFilter = document.getElementById('pointFilter').value;
            const typeFilter = document.getElementById('typeFilter').value;
            const priorityFilter = document.getElementById('priorityFilter').value;
            
            filteredData = historyData.filter(entry => {
                const pointMatch = !pointFilter || entry.pointAddress == pointFilter;
                const typeMatch = !typeFilter || entry.alarmType == typeFilter;
                const priorityMatch = !priorityFilter || entry.priority == priorityFilter;
                
                return pointMatch && typeMatch && priorityMatch;
            });
            
            currentPage = 1;
            displayFilteredData();
        }

        // Display filtered and paginated data
        function displayFilteredData() {
            const tbody = document.querySelector('#historyTable tbody');
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageData = filteredData.slice(startIndex, endIndex);
            
            if (pageData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" class="no-history">No alarm history matches the current filters</td></tr>';
                document.getElementById('pagination').style.display = 'none';
                return;
            }
            
            tbody.innerHTML = pageData.map(entry => createHistoryRow(entry).outerHTML).join('');
            
            // Update pagination
            const totalPages = Math.ceil(filteredData.length / itemsPerPage);
            if (totalPages > 1) {
                document.getElementById('pagination').style.display = 'flex';
                document.getElementById('pageInfo').textContent = `Page ${currentPage} of ${totalPages} (${filteredData.length} entries)`;
                document.getElementById('prevPage').disabled = currentPage === 1;
                document.getElementById('nextPage').disabled = currentPage === totalPages;
            } else {
                document.getElementById('pagination').style.display = 'none';
            }
        }

        // Pagination functions
        function changePage(direction) {
            const totalPages = Math.ceil(filteredData.length / itemsPerPage);
            const newPage = currentPage + direction;
            
            if (newPage >= 1 && newPage <= totalPages) {
                currentPage = newPage;
                displayFilteredData();
            }
        }

        // Table sorting function
        function sortTable(columnIndex) {
            const table = document.getElementById('historyTable');
            
            // Update sort direction
            if (sortColumn === columnIndex) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortDirection = 'asc';
                sortColumn = columnIndex;
            }

            // Clear previous sort indicators
            table.querySelectorAll('th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });

            // Add current sort indicator
            const currentHeader = table.querySelector(`th:nth-child(${columnIndex + 1})`);
            currentHeader.classList.add(sortDirection === 'asc' ? 'sort-asc' : 'sort-desc');

            // Sort the filtered data
            filteredData.sort((a, b) => {
                let aValue, bValue;
                
                switch (columnIndex) {
                    case 0: // Point
                        aValue = a.pointAddress;
                        bValue = b.pointAddress;
                        break;
                    case 1: // Point Name
                        aValue = a.pointName || '';
                        bValue = b.pointName || '';
                        break;
                    case 2: // Type
                        aValue = getTypeText(a.alarmType);
                        bValue = getTypeText(b.alarmType);
                        break;
                    case 3: // Priority
                        aValue = a.priority;
                        bValue = b.priority;
                        break;
                    case 4: // Event
                        aValue = a.event;
                        bValue = b.event;
                        break;
                    case 5: // Temperature
                        aValue = a.temperature || 0;
                        bValue = b.temperature || 0;
                        break;
                    case 6: // Threshold
                        aValue = a.threshold || 0;
                        bValue = b.threshold || 0;
                        break;
                    case 7: // Timestamp
                        aValue = new Date(a.timestamp);
                        bValue = new Date(b.timestamp);
                        break;
                    case 8: // Duration
                        aValue = a.duration || 0;
                        bValue = b.duration || 0;
                        break;
                    default:
                        return 0;
                }
                
                let comparison = 0;
                if (typeof aValue === 'number' && typeof bValue === 'number') {
                    comparison = aValue - bValue;
                } else if (aValue instanceof Date && bValue instanceof Date) {
                    comparison = aValue - bValue;
                } else {
                    comparison = String(aValue).localeCompare(String(bValue));
                }
                
                return sortDirection === 'asc' ? comparison : -comparison;
            });
            
            displayFilteredData();
        }

        // Export history to CSV
        async function exportHistory() {
            if (filteredData.length === 0) {
                alert('No data to export. Please load history first.');
                return;
            }
            
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            try {
                const response = await fetch(`/api/alarm-history/export?start=${startDate}&end=${endDate}`, {
                    method: 'GET'
                });
                
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `alarm_history_${startDate}_to_${endDate}.csv`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                } else {
                    throw new Error('Export failed');
                }
            } catch (error) {
                console.error('Error exporting history:', error);
                alert('Failed to export history: ' + error.message);
            }
        }
    </script>
</body>
</html>

-------- [ Separator ] ------

File Name: test/alarm_states_2025-07-09.csv
Size: 338 B
Code:
Timestamp,PointNumber,PointName,AlarmType,AlarmPriority,PreviousState,NewState,CurrentTemperature,Threshold
2025-07-09 00:29:48,0,,HIGH_TEMP,LOW,NEW,ACTIVE,27,0
2025-07-09 00:29:51,0,,HIGH_TEMP,LOW,ACTIVE,ACKNOWLEDGED,27,0
2025-07-09 00:30:14,1,,HIGH_TEMP,LOW,NEW,ACTIVE,27,0
2025-07-09 00:30:17,1,,HIGH_TEMP,LOW,ACTIVE,ACKNOWLEDGED,27,0

-------- [ Separator ] ------

File Name: test/d18b10_test.cpp_
Size: 2.07 KB
Code:
#include <OneWire.h>
#include <DallasTemperature.h>

// GPIO where the DS18B20 sensors are connected
const int oneWireBus = 4;

// Setup a oneWire instance to communicate with any OneWire devices
OneWire oneWire(oneWireBus);

// Pass our oneWire reference to Dallas Temperature sensor
DallasTemperature sensors(&oneWire);

// Arrays to store device addresses
DeviceAddress sensor1, sensor2;

// Function to print a device address
void printAddress(DeviceAddress deviceAddress) {
    for (uint8_t i = 0; i < 8; i++) {
      if (deviceAddress[i] < 16) Serial.print("0");
      Serial.print(deviceAddress[i], HEX);
    }
  }
  

void setup() {
  // Start serial communication
  Serial.begin(115200);
  
  // Start the DS18B20 sensor
  sensors.begin();
  
  // Locate devices on the bus
  Serial.println("Locating DS18B20 temperature sensors...");
  Serial.print("Found ");
  Serial.print(sensors.getDeviceCount(), DEC);
  Serial.println(" devices.");

  // Get the addresses of the first two sensors
  if (!sensors.getAddress(sensor1, 0)) {
    Serial.println("Unable to find address for Sensor 1");
  }
  
  if (!sensors.getAddress(sensor2, 1)) {
    Serial.println("Unable to find address for Sensor 2");
  }

  // Print the addresses
  Serial.print("Sensor 1 Address: ");
  printAddress(sensor1);
  Serial.println();
  
  Serial.print("Sensor 2 Address: ");
  printAddress(sensor2);
  Serial.println();
  
  // Set the resolution to 9 bit (can be 9, 10, 11, or 12)
  sensors.setResolution(sensor1, 12);
  sensors.setResolution(sensor2, 12);
}

void loop() {
  // Request temperatures from all sensors
  Serial.println("Requesting temperatures...");
  sensors.requestTemperatures();
  
  // Get and print the temperature for each sensor
  float temp1 = sensors.getTempC(sensor1);
  float temp2 = sensors.getTempC(sensor2);
  
  Serial.print("Sensor 1 Temperature: ");
  Serial.print(temp1);
  Serial.println(" °C");
  
  Serial.print("Sensor 2 Temperature: ");
  Serial.print(temp2);
  Serial.println(" °C");
  
  Serial.println("----------------------------");
  
  // Wait 2 seconds before next reading
  delay(2000);
}


-------- [ Separator ] ------

File Name: test/discover_i2c.cpp_
Size: 3.49 KB
Code:
#include <Arduino.h>
#include <Wire.h>

// Your custom I2C pins
#define I2C_SDA 21  // Default SDA, available
#define I2C_SCL 25  // Alternative SCL (GPIO 22 used by RS485)

void identifyDevice(byte address) {
    switch (address) {
        case 0x20:
        case 0x21:
        case 0x22:
        case 0x23:
        case 0x24:
        case 0x25:
        case 0x26:
        case 0x27:
            Serial.println("PCF8574/PCF8575 I/O Expander");
            break;
        case 0x48:
        case 0x49:
        case 0x4A:
        case 0x4B:
            Serial.println("ADS1115/ADS1015 ADC or PCF8591");
            break;
        case 0x50:
        case 0x51:
        case 0x52:
        case 0x53:
        case 0x54:
        case 0x55:
        case 0x56:
        case 0x57:
            Serial.println("EEPROM (24C series)");
            break;
        case 0x68:
            Serial.println("DS1307/DS3231 RTC or MPU6050 Gyro");
            break;
        case 0x76:
        case 0x77:
            Serial.println("BMP280/BME280 Pressure Sensor");
            break;
        case 0x3C:
        case 0x3D:
            Serial.println("SSD1306 OLED Display");
            break;
        case 0x40:
            Serial.println("PCA9685 PWM Driver");
            break;
        default:
            Serial.println("Unknown device");
            break;
    }
}


void setup() {
    Serial.begin(115200);
    while (!Serial);  // Wait for serial monitor to open
    
    Serial.println("\nI2C Scanner Starting...");
    
    // Initialize I2C with custom pins
    Wire.begin(I2C_SDA, I2C_SCL);
    
    // Set I2C clock speed (optional)
    Wire.setClock(100000);  // 100kHz standard mode
    
    Serial.println("Scanning I2C bus...");
    Serial.println("SDA Pin: " + String(I2C_SDA));
    Serial.println("SCL Pin: " + String(I2C_SCL));
    Serial.println("--------------------");
}

void loop() {
    byte error, address;
    int deviceCount = 0;
    
    Serial.println("Scanning for I2C devices...");
    
    // Scan all possible I2C addresses (0x08 to 0x77)
    for (address = 8; address < 120; address++) {
        // Begin transmission to the address
        Wire.beginTransmission(address);
        error = Wire.endTransmission();
        
        if (error == 0) {
            // Device found
            Serial.print("I2C device found at address 0x");
            if (address < 16) Serial.print("0");
            Serial.print(address, HEX);
            Serial.print(" (");
            Serial.print(address);
            Serial.print(") - ");
            
            // Identify common devices
            identifyDevice(address);
            
            deviceCount++;
        }
        else if (error == 4) {
            // Unknown error
            Serial.print("Unknown error at address 0x");
            if (address < 16) Serial.print("0");
            Serial.println(address, HEX);
        }
    }
    
    Serial.println("--------------------");
    if (deviceCount == 0) {
        Serial.println("No I2C devices found!");
        Serial.println("Check connections:");
        Serial.println("- SDA connected to GPIO " + String(I2C_SDA));
        Serial.println("- SCL connected to GPIO " + String(I2C_SCL));
        Serial.println("- Pull-up resistors (4.7kΩ) on SDA and SCL");
        Serial.println("- Device power supply");
    } else {
        Serial.print("Found ");
        Serial.print(deviceCount);
        Serial.println(" device(s)");
    }
    
    Serial.println("\nNext scan in 5 seconds...\n");
    delay(5000);  // Wait 5 seconds before next scan
}


-------- [ Separator ] ------

File Name: test/format.cpp_
Size: 637 B
Code:
#include <LittleFS.h>

void setup() {
  Serial.begin(115200);
  delay(3000);  // Give time to open serial monitor
  
  // Force format sequence
  Serial.println("Attempting LittleFS format...");
  if(LittleFS.format()) {
    Serial.println("Format successful");
  } else {
    Serial.println("Format failed");
    ESP.restart();
  }
  
  // Verify mount after format
  if(LittleFS.begin(true)) {
    Serial.println("Mount successful");
    Serial.printf("Total space: %u\nUsed space: %u\n", 
                 LittleFS.totalBytes(), LittleFS.usedBytes());
  } else {
    Serial.println("Mount failed after format");
  }
}

void loop() {};
-------- [ Separator ] ------

File Name: test/indicator_test.cpp_
Size: 2.27 KB
Code:
#include "IndicatorInterface.h"

IndicatorInterface indicator(Wire, 0x20, 34);  // I2C address 0x20, INT pin 34

void onPortChange(uint16_t currentState, uint16_t changedPins) {
    Serial.print("Ports changed: 0x");
    Serial.println(changedPins, HEX);
}

void setup() {
    Serial.begin(115200);
    
    // Initialize I2C
    Wire.begin(21, 25);
    Wire.setClock(100000);
    
    // Initialize indicator interface
    if (!indicator.begin()) {
        Serial.println("Failed to initialize indicator interface!");
        return;
    }
    
    // Configure ports
    indicator.setDirection(0b0000000011111111);  // P9, P10, P11 as outputs
    
    // Set port names
    indicator.setPortName("BUTTON", 15);
    indicator.setPortName("LED1", 4);
    indicator.setPortName("LED2", 5);
    indicator.setPortName("LED3", 7);
    
    // Set individual port inversion for ULN2803
    indicator.setPortInverted("LED1", false);   // Invert LED1 for ULN2803
    indicator.setPortInverted("LED2", false);   // Invert LED2 for ULN2803
    indicator.setPortInverted("LED3", false);   // Invert LED3 for ULN2803
    indicator.setPortInverted("BUTTON", false); // Button is normal (not inverted)
    
    // Or you can still use the mask method if you prefer:
    // indicator.setMode(0x0E00);  // This should now work correctly
    
    // Set interrupt callback
    indicator.setInterruptCallback(onPortChange);
    
    // Turn off all LEDs
    indicator.setAllOutputsLow();
    
    Serial.println("Setup complete!");
    indicator.printConfiguration();
}


void loop() {
    // Handle interrupts
    indicator.handleInterrupt();
    
    // Check button state
    static bool lastButtonState = true;
    bool currentButtonState = indicator.readPort("BUTTON");
    
    if (lastButtonState && !currentButtonState) {  // Button pressed
        Serial.println("Button pressed!");
        
        // Cycle LEDs
        static int ledState = 0;
        indicator.setAllOutputsLow();
        
        switch (ledState) {
            case 0: indicator.writePort("LED1", true); break;
            case 1: indicator.writePort("LED2", true); break;
            case 2: indicator.writePort("LED3", true); break;
        }
        
        ledState = (ledState + 1) % 4;
    }
    
    lastButtonState = currentButtonState;
    delay(10);
}

-------- [ Separator ] ------

File Name: test/modbus_test.cpp_
Size: 2.18 KB
Code:
// =================================================================================================
// eModbus: Copyright 2020 by Michael Harwerth, Bert Melis and the contributors to ModbusClient
//               MIT license - see license.md for details
// =================================================================================================
// Includes: <Arduino.h> for Serial etc., WiFi.h for WiFi support
#include <Arduino.h>
#include "HardwareSerial.h"

// Modbus server include
#include "ModbusServerRTU.h"
#define LOG_LEVEL_VERBOSE

// Create a ModbusRTU server instance listening with 2000ms timeout
ModbusServerRTU MBserver(2000, 18);

// FC03: worker do serve Modbus function code 0x03 (READ_HOLD_REGISTER)
ModbusMessage FC03(ModbusMessage request) {
  uint16_t address;           // requested register address
  uint16_t words;             // requested number of registers
  ModbusMessage response;     // response message to be sent back

  // get request values
  request.get(2, address);
  request.get(4, words);

  // Address and words valid? We assume 10 registers here for demo
  if (words > 0 && (address + words) <= 10) 
    {
    // Looks okay. Set up message with serverID, FC and length of data
    response.add(request.getServerID(), request.getFunctionCode(), (uint8_t)(words * 2));
    // Fill response with requested data
    for (uint16_t i = address; i < address + words; ++i) {
      response.add(i);
    }
  } else {
    // No, either address or words are outside the limits. Set up error response.
    response.setError(request.getServerID(), request.getFunctionCode(), ILLEGAL_DATA_ADDRESS);
  }
  return response;
}

// Setup() - initialization happens here
void setup() {
// Init Serial monitor
  Serial.begin(115200);
  while (!Serial) {}
  Serial.println("__ OK __");

// Init Serial2 connected to the RTU Modbus
// (Fill in your data here!)
  RTUutils::prepareHardwareSerial(Serial2);
  Serial2.begin(9600, SERIAL_8N1, 22, 23);

// Register served function code worker for server 1, FC 0x03
  MBserver.registerWorker(0x01, READ_HOLD_REGISTER, &FC03);

// Start ModbusRTU background task
  MBserver.begin(Serial2);
}

// loop() - nothing done here today!
void loop() {
  delay(10000);
}
-------- [ Separator ] ------

File Name: test/oled_test.cpp_
Size: 1.17 KB
Code:
#include "IndicatorInterface.h"

IndicatorInterface indicator(Wire, 0x20, -1);

void setup() {
    Serial.begin(115200);
    Wire.begin(21, 25);
    Wire.setClock(100000);
    
    if (!indicator.begin()) {
        Serial.println("Failed to initialize!");
        return;
    }
    
    indicator.setOledMode(3);
    indicator.setOledSleepDelay(-1);
    
    // Show some text first
    String lines[] = {"Line 1", "Line 2", "Line 3"};
    indicator.printText(lines, 3);
    delay(2000);
    
    // Test blinking OK
    Serial.println("Starting OK blink...");
    indicator.blinkOK(1000);  // Blink every 1 second
}

void loop() {
    indicator.updateOLED();
    
    static unsigned long lastAction = 0;
    if (millis() - lastAction > 10000) {  // Every 10 seconds
        static bool showCross = false;
        
        if (showCross) {
            Serial.println("Starting Cross blink...");
            indicator.blinkCross(500);  // Blink every 500ms
        } else {
            Serial.println("Starting OK blink...");
            indicator.blinkCross(800);     // Blink every 800ms
        }
        
        showCross = !showCross;
        lastAction = millis();
    }
    
    delay(10);
}

-------- [ Separator ] ------

File Name: test/pcf_test.cpp_
Size: 4.69 KB
Code:
#include <Arduino.h>
#include <Wire.h>
#include "PCF8575.h"

#define I2C_SDA 21
#define I2C_SCL 25
#define PCF_INT 34      // With external 4.7kΩ pull-up resistor
#define BUTTON_PIN 8
#define LED1_PIN 9
#define LED2_PIN 10
#define LED3_PIN 11

PCF8575 pcf8575(0x20);

// Interrupt variables
volatile bool interruptFlag = false;
bool lastButtonState = HIGH;
unsigned long lastButtonPressTime = 0;
const unsigned long buttonDebounceDelay = 200;
int currentLED = 0;

// Interrupt Service Routine
void IRAM_ATTR pcfInterrupt() {
    interruptFlag = true;
}

void clearPCFInterrupt() {
    pcf8575.read16();
    delay(1);
    pcf8575.read16();
}

void setLED(uint8_t pin, bool state) {
    uint16_t currentState = pcf8575.read16();
    
    // Always keep button pin HIGH (input mode) regardless of current reading
    currentState |= (1 << BUTTON_PIN);  // Force button pin HIGH
    
    // INVERTED LED logic for ULN2803
    if (state) {
        // LED ON - set pin HIGH (ULN2803 inverts to LOW output)
        currentState |= (1 << pin);
    } else {
        // LED OFF - set pin LOW (ULN2803 inverts to HIGH output)
        currentState &= ~(1 << pin);
    }
    
    pcf8575.write16(currentState);
    delay(5);
    clearPCFInterrupt();
}

void turnOffAllLEDs() {
    setLED(LED1_PIN, false);
    setLED(LED2_PIN, false);
    setLED(LED3_PIN, false);
}

void cycleLEDs() {
    Serial.println("=== CYCLING LEDS ===");
    
    // Turn off all LEDs first
    turnOffAllLEDs();
    
    currentLED++;
    if (currentLED > 3) {
        currentLED = 0;
    }
    
    switch (currentLED) {
        case 0:
            Serial.println("→ All LEDs OFF");
            break;
        case 1:
            setLED(LED1_PIN, true);   // Turn LED1 ON
            Serial.println("→ LED1 ON (P9)");
            break;
        case 2:
            setLED(LED2_PIN, true);   // Turn LED2 ON
            Serial.println("→ LED2 ON (P10)");
            break;
        case 3:
            setLED(LED3_PIN, true);   // Turn LED3 ON
            Serial.println("→ LED3 ON (P11)");
            break;
    }
    
    Serial.print("Current LED state: ");
    Serial.println(currentLED);
}

void handleButtonChange() {
    // Read current pin states to clear interrupt condition
    uint16_t pinStates = pcf8575.read16();
    bool currentButtonState = (pinStates >> BUTTON_PIN) & 0x01;
    
    Serial.print("Interrupt! Button: ");
    Serial.print(lastButtonState ? "HIGH" : "LOW");
    Serial.print(" → ");
    Serial.println(currentButtonState ? "HIGH" : "LOW");
    
    // Check for button press (HIGH to LOW transition)
    if (lastButtonState == HIGH && currentButtonState == LOW) {
        if ((millis() - lastButtonPressTime) > buttonDebounceDelay) {
            Serial.println("=== BUTTON PRESSED! ===");
            cycleLEDs();
            lastButtonPressTime = millis();
        } else {
            Serial.println("Button press ignored (debounce)");
        }
    }
    
    // Check for button release
    if (lastButtonState == LOW && currentButtonState == HIGH) {
        Serial.println("=== BUTTON RELEASED! ===");
    }
    
    // Always update button state
    lastButtonState = currentButtonState;
}

void setup() {
    Serial.begin(115200);
    Serial.println("PCF8575 LED Cycling - ULN2803 Logic");
    
    // Initialize I2C
    Wire.begin(I2C_SDA, I2C_SCL);
    Wire.setClock(100000);
    delay(100);
    
    // Initialize PCF8575
    if (!pcf8575.begin()) {
        Serial.println("PCF8575 initialization failed!");
        while(1) delay(1000);
    }
    
    Serial.println("PCF8575 initialized successfully!");
    
    // Configure interrupt pin (GPIO 34 with external pull-up)
    pinMode(PCF_INT, INPUT);
    
    // Initialize all pins HIGH
    pcf8575.write16(0xFFFF);
    delay(100);
    clearPCFInterrupt();
    
    // Read initial button state
    uint16_t initialState = pcf8575.read16();
    lastButtonState = (initialState >> BUTTON_PIN) & 0x01;
    
    // Turn off all LEDs initially
    turnOffAllLEDs();
    
    // Attach interrupt AFTER everything is initialized
    attachInterrupt(digitalPinToInterrupt(PCF_INT), pcfInterrupt, FALLING);
    
    Serial.println("Setup complete! Press button to cycle LEDs.");
    Serial.println("Hardware interrupt enabled on GPIO 34");
    Serial.print("Initial button state: ");
    Serial.println(lastButtonState ? "HIGH" : "LOW");
    Serial.println("Current state: All LEDs OFF");
    Serial.println("LED Logic: HIGH = ON, LOW = OFF (inverted for ULN2803)");
}

void loop() {
    // Check if interrupt occurred
    if (interruptFlag) {
        interruptFlag = false;  // Clear flag immediately
        
        // Handle the button change
        handleButtonChange();
    }
    
    // Main loop can do other tasks
    delay(10);
}

-------- [ Separator ] ------

File Name: test/points.html_
Size: 15.46 KB
Code:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Measurement Points</title>
    <style>
        .status-ok {
            color: #388e3c;
            font-weight: bold;
        }
        .status-error, .status-alarm, .status-unbound {
            color: #d32f2f;
            font-weight: bold;
        }
        .status-bound {
            color: #388e3c;
            font-weight: bold;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 10;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 8% auto;
            padding: 24px;
            border: 1px solid #888;
            width: 100%;
            max-width: 400px;
            border-radius: 6px;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover,
        .close:focus {
            color: #d32f2f;
            text-decoration: none;
            cursor: pointer;
        }
        .form-group {
            margin-bottom: 18px;
        }
        .form-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .form-group input[type="text"],
        .form-group input[type="number"] {
            width: 95%;
            padding: 6px;
            font-size: 1em;
        }
        .form-actions {
            text-align: right;
        }
        .form-actions button {
            margin-left: 10px;
            padding: 5px 15px;
        }
        
        /* Use styles from index.html */
        body {
            font-family: Arial, sans-serif;
            background: #f7f7f7;
            margin: 0;
            padding: 0;
        }
        header {
            background: #3f51b5;
            color: #fff;
            padding: 1em 2em;
            text-align: center;
            font-size: 1.5em;
            letter-spacing: 2px;
        }
        nav {
            background: #263238;
            padding: 0.5em 2em;
        }
        nav a {
            color: #fff;
            text-decoration: none;
            margin-right: 2em;
            font-weight: bold;
            transition: color 0.2s;
        }
        nav a:hover {
            color: #ffeb3b;
        }
        main {
            max-width: 1200px;
            margin: 2em auto;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            padding: 2em;
        }
        h2 {
            margin-top: 1em;
            color: #3f51b5;
            font-size: 1.2em;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.25em;
        }
        .actions {
            margin-bottom: 1.5em;
        }
        button {
            background: #3f51b5;
            color: #fff;
            border: none;
            padding: 0.5em 1.2em;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            margin-right: 0.5em;
            transition: background 0.2s;
        }
        button:hover {
            background: #283593;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 2em;
        }
        th, td {
            padding: 0.6em 0.8em;
            border-bottom: 1px solid #eee;
            text-align: left;
        }
        th {
            background: #f0f4ff;
            color: #3f51b5;
        }
        tr:last-child td {
            border-bottom: none;
        }
        .status-bound {
            color: #388e3c;
            font-weight: bold;
        }
        .status-unbound {
            color: #b71c1c;
            font-weight: bold;
        }
        .rom, .chip-select {
            font-family: monospace;
            font-size: 0.98em;
            color: #333;
        }
        @media (max-width: 800px) {
            main { padding: 1em; }
            th, td { font-size: 0.95em; }
        }
    
    </style>
</head>
<body>
    <header>Measurement Points</header>
    <nav>
        <a href="dashboard.html">Home</a>
        <a href="settings.html">Settings</a>
        <a href="sensors.html">Sensors</a>
        <a href="points.html">Points</a>

    </nav>
    <main>
    <h2>DS18B20 Points</h2>
    
        <table>
            <thead>
                <tr>
                    <th>Address</th>
                    <th>Bus</th>
                    <th>Name</th>
                    <th>Current Temp</th>
                    <th>Min Temp</th>
                    <th>Max Temp</th>
                    <th>Low Alarm</th>
                    <th>High Alarm</th>
                    <th>Alarm Status</th>
                    <th>Error Status</th>
                    <th>Sensor Status</th>
                    <th>Edit Point</th>
                    <th>Edit Alarm</th>

                </tr>
            </thead>
            <tbody id="dsPointsTbody">
                <tr><td colspan="11">Loading DS18B20 points...</td></tr>
            </tbody>
        </table>

        <h2>PT1000 Points</h2>
        <table>
            <thead>
                <tr>
                    <th>Address</th>
                    <th>Bus</th>
                    <th>Name</th>
                    <th>Current Temp</th>
                    <th>Min Temp</th>
                    <th>Max Temp</th>
                    <th>Low Alarm</th>
                    <th>High Alarm</th>
                    <th>Alarm Status</th>
                    <th>Error Status</th>
                    <th>Sensor Status</th>
                    <th>Edit Point</th>
                    <th>Edit Alarm</th>
                </tr>
            </thead>
            <tbody id="ptPointsTbody">
                <tr><td colspan="11">Loading PT1000 points...</td></tr>
            </tbody>
        </table>
    </main>

    <!-- Modal -->
    <div id="pointConfigModal" class="modal">
        <div class="modal-content">
            <span class="close" id="modalCloseBtn">&times;</span>
            <h2>Edit Point</h2>
            <form id="pointConfigForm">
                <input type="hidden" id="modalPointAddress">
                <div class="form-group">
                    <label for="modalPointName">Name</label>
                    <input type="text" id="modalPointName" required>
                </div>
                <div class="form-group">
                    <label for="modalLowAlarm">Low Alarm Threshold (°C)</label>
                    <input type="number" id="modalLowAlarm" step="0.1" required>
                </div>
                <div class="form-group">
                    <label for="modalHighAlarm">High Alarm Threshold (°C)</label>
                    <input type="number" id="modalHighAlarm" step="0.1" required>
                </div>
                <div class="form-actions">
                    <button type="submit" class="button">Save</button>
                    <button type="button" class="button" id="modalCancelBtn" style="background:#888;">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Modal -->
    <div id="alarmConfigModal" class="modal">
       <!--  Here should be modal for handle alarm config: 
       Header: Point number, Point name
       3 sections (lines) : 
        - high alarm Threshold (<current sreshold value>): dropdown with alarm priority options + NO ALARM(to delete the alarm)
        - low alarm Threshold (<current sreshold value>): dropdown with alarm priority options + NO ALARM(to delete the alarm)
        - sensor error : dropdown with alarm priority options + NO ALARM(to delete the alarm) 
        
        Save and cancel buttons-->

    </div>

    <script>
        // Auto-update interval (ms)
        const UPDATE_INTERVAL = 5000;
        // Helper functions for status rendering
        function getAlarmText(alarmStatus) {
            if (alarmStatus === 0) return '<span class="status-ok">OK</span>';
            const alarms = [];
            if (alarmStatus & 0x01) alarms.push('Low Temp');
            if (alarmStatus & 0x02) alarms.push('High Temp');
            return `<span class="status-alarm">${alarms.join(', ')}</span>`;
        }
        function getErrorText(errorStatus) {
            if (errorStatus === 0) return '<span class="status-ok">OK</span>';
            const errors = [];
            if (errorStatus & 0x01) errors.push('Comm');
            if (errorStatus & 0x02) errors.push('OutOfRange');
            if (errorStatus & 0x04) errors.push('Disconnected');
            return `<span class="status-error">${errors.join(', ')}</span>`;
        }
        function getSensorStatus(bound) {
            return bound
                ? '<span class="status-bound">Bound</span>'
                : '<span class="status-unbound">Unbound</span>';
        }

        // Modal logic
        const modal = document.getElementById('pointConfigModal');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        const modalCancelBtn = document.getElementById('modalCancelBtn');
        const pointConfigForm = document.getElementById('pointConfigForm');
        let currentEditPoint = null;

        function openModal(point) {
            currentEditPoint = point;
            document.getElementById('modalPointAddress').value = point.address;
            document.getElementById('modalPointName').value = point.name || '';
            document.getElementById('modalLowAlarm').value = point.lowAlarmThreshold;
            document.getElementById('modalHighAlarm').value = point.highAlarmThreshold;
            modal.style.display = "block";
        }
        function closeModal() {
            modal.style.display = "none";
            currentEditPoint = null;
        }
        modalCloseBtn.onclick = closeModal;
        modalCancelBtn.onclick = closeModal;
        window.onclick = function(event) {
            if (event.target === modal) closeModal();
        };

        // Fetch and render points
        function fetchAndRenderPoints() {
            fetch('/api/points')
                .then(res => res.json())
                .then(data => renderPointsTables(data.points))
                .catch(() => {
                    document.getElementById('dsPointsTbody').innerHTML = '<tr><td colspan="11">Failed to load points.</td></tr>';
                    document.getElementById('ptPointsTbody').innerHTML = '<tr><td colspan="11">Failed to load points.</td></tr>';
                });
        }

        function renderPointsTables(points) {
            const dsTbody = document.getElementById('dsPointsTbody');
            const ptTbody = document.getElementById('ptPointsTbody');
            dsTbody.innerHTML = '';
            ptTbody.innerHTML = '';

            const dsPoints = points.filter(p => p.type === "DS18B20");
            const ptPoints = points.filter(p => p.type === "PT1000");

            if (dsPoints.length === 0) {
                dsTbody.innerHTML = '<tr><td colspan="11">No DS18B20 points found.</td></tr>';
            } else {
                dsPoints.forEach(point => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${point.address}</td>
                        <td>${point.bus !== undefined && point.bus !== null ? point.bus : ''}</td>
                        <td>${point.name || ''}</td>
                        <td>${point.currentTemp !== undefined ? point.currentTemp : ''}</td>
                        <td>${point.minTemp !== undefined ? point.minTemp : ''}</td>
                        <td>${point.maxTemp !== undefined ? point.maxTemp : ''}</td>
                        <td>${point.lowAlarmThreshold !== undefined ? point.lowAlarmThreshold : ''}</td>
                        <td>${point.highAlarmThreshold !== undefined ? point.highAlarmThreshold : ''}</td>
                        <td>${getAlarmText(point.alarmStatus)}</td>
                        <td>${getErrorText(point.errorStatus)}</td>
                        <td>${getSensorStatus(!!point.sensorRomString)}</td>
                        <td><button class="button" onclick='onEditPoint(${point.address})'>Edit</button></td>
                        <td><button class="button" onclick='onEditAlarm(${point.address})'>Alarm</button></td>
                    `;
                    dsTbody.appendChild(row);
                });
            }

            if (ptPoints.length === 0) {
                ptTbody.innerHTML = '<tr><td colspan="11">No PT1000 points found.</td></tr>';
            } else {
                ptPoints.forEach(point => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${point.address}</td>
                        <td>${point.bus !== undefined && point.bus !== null ? point.bus : ''}</td>
                        <td>${point.name || ''}</td>
                        <td>${point.currentTemp !== undefined ? point.currentTemp : ''}</td>
                        <td>${point.minTemp !== undefined ? point.minTemp : ''}</td>
                        <td>${point.maxTemp !== undefined ? point.maxTemp : ''}</td>
                        <td>${point.lowAlarmThreshold !== undefined ? point.lowAlarmThreshold : ''}</td>
                        <td>${point.highAlarmThreshold !== undefined ? point.highAlarmThreshold : ''}</td>
                        <td>${getAlarmText(point.alarmStatus)}</td>
                        <td>${getErrorText(point.errorStatus)}</td>
                        <td>${getSensorStatus(!!point.chipSelectPin)}</td>
                        <td><button class="button" onclick='onEditPoint(${point.address})'>Edit</button></td>
                        <td><button class="button" onclick='onEditAlarm(${point.address})'>Alarm</button></td>
                    `;
                    ptTbody.appendChild(row);
                });
            }
        }

        // Edit handler
        function onEditPoint(address) {
            fetch('/api/points')
                .then(res => res.json())
                .then(data => {
                    const point = data.points.find(p => p.address === address);
                    if (point) openModal(point);
                });
        }
        window.onEditPoint = onEditPoint;

        // Handle form submit
        pointConfigForm.onsubmit = function(e) {
            e.preventDefault();
            const address = parseInt(document.getElementById('modalPointAddress').value, 10);
            const name = document.getElementById('modalPointName').value;
            const lowAlarm = parseFloat(document.getElementById('modalLowAlarm').value);
            const highAlarm = parseFloat(document.getElementById('modalHighAlarm').value);

            fetch('/api/points', {
                method: 'PUT',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ address, name, lowAlarmThreshold: lowAlarm, highAlarmThreshold: highAlarm })
            })
            .then(res => {
                if (!res.ok) throw new Error('Failed to update point');
                closeModal();
                fetchAndRenderPoints();
            })
            .catch(() => alert('Failed to update point!'));
        };

        // Initial load
        setInterval(fetchAndRenderPoints, UPDATE_INTERVAL);
        window.onload = fetchAndRenderPoints();
        // Optionally, set up periodic refresh if needed
        // setInterval(fetchAndRenderPoints, 10000);
    </script>
</body>
</html>

-------- [ Separator ] ------

File Name: test/pttest.cpp_
Size: 2.34 KB
Code:
#include <SPI.h>
#include <Adafruit_MAX31865.h>
#include <Arduino.h>

//SPI PINs
#define SCK_PIN  14
#define MISO_PIN  12
#define MOSI_PIN  13

//PT1000 PINs
#define CS1_PIN  32
#define CS2_PIN  33

// The value of the Rref resistor. Use 4300.0 for PT1000
#define RREF      4300.0
// The 'nominal' 0-degrees-C resistance of the sensor (1000.0 for PT1000)
#define RNOMINAL  1000.0

// Initialize the MAX31865 with software SPI
Adafruit_MAX31865 thermo1 = Adafruit_MAX31865(CS1_PIN, MOSI_PIN, MISO_PIN, SCK_PIN);
Adafruit_MAX31865 thermo2 = Adafruit_MAX31865(CS2_PIN, MOSI_PIN, MISO_PIN, SCK_PIN);

void readSensor(Adafruit_MAX31865 &thermo, int sensorNum) {
    uint16_t rtd = thermo.readRTD();
    
    Serial.print("RTD value: ");
    Serial.println(rtd);
    
    float ratio = rtd;
    ratio /= 32768;
    
    Serial.print("Ratio = ");
    Serial.println(ratio, 8);
    
    Serial.print("Resistance = ");
    Serial.println(RREF * ratio, 8);
    
    Serial.print("Temperature = ");
    Serial.println(thermo.temperature(RNOMINAL, RREF));
    
    // Check and print any faults
    uint8_t fault = thermo.readFault();
    if (fault) {
      Serial.print("Fault 0x");
      Serial.println(fault, HEX);
      
      if (fault & MAX31865_FAULT_HIGHTHRESH) {
        Serial.println("RTD High Threshold");
      }
      if (fault & MAX31865_FAULT_LOWTHRESH) {
        Serial.println("RTD Low Threshold");
      }
      if (fault & MAX31865_FAULT_REFINLOW) {
        Serial.println("REFIN- > 0.85 x Bias");
      }
      if (fault & MAX31865_FAULT_REFINHIGH) {
        Serial.println("REFIN- < 0.85 x Bias - FORCE- open");
      }
      if (fault & MAX31865_FAULT_RTDINLOW) {
        Serial.println("RTDIN- < 0.85 x Bias - FORCE- open");
      }
      if (fault & MAX31865_FAULT_OVUV) {
        Serial.println("Under/Over voltage");
      }
      
      thermo.clearFault();
    }
  }
  

void setup() {
  Serial.begin(115200);
  
  while (!Serial) delay(10);
  
  Serial.println("PT1000 Test with MAX31865!");
  
  // Initialize the MAX31865 modules
  thermo1.begin(MAX31865_3WIRE);  // Set to 2WIRE, 3WIRE, or 4WIRE as needed
  thermo2.begin(MAX31865_3WIRE);  // Set to 2WIRE, 3WIRE, or 4WIRE as needed
}

void loop() {
  Serial.println("=== Sensor 1 ===");
  readSensor(thermo1, 1);
  
  Serial.println("=== Sensor 2 ===");
  readSensor(thermo2, 2);
  
  Serial.println();
  delay(1000);
}


-------- [ Separator ] ------

File Name: test/rtc_test.cpp_
Size: 1.03 KB
Code:

#include "TimeManager.h"



#define I2C_SDA 21  // Default SDA, available
#define I2C_SCL 25  // Alternative SCL (GPIO 22 used by RS485)

TimeManager timeManager(I2C_SDA, I2C_SCL); // SDA=21, SCL=22

void setup() {
    Serial.begin(115200);
    
    // Initialize WiFi first
    WiFi.begin("your_ssid", "your_password");
    
    // Initialize time manager
    if (timeManager.begin()) {
        Serial.println("TimeManager initialized successfully");
        
        // Set timezone (GMT+3 for Moscow)
        timeManager.setTimezone(3, 0);
        
        // Sync with NTP when WiFi connects
        if (WiFi.status() == WL_CONNECTED) {
            timeManager.setTimeFromNTP();
        }
    }
}

void loop() {
    // Update time manager (handles automatic NTP sync)
    timeManager.update();
    
    // Get current time
    String currentTime = timeManager.getFormattedTime();
    Serial.println("Current time: " + currentTime);
    
    // Get JSON status for web interface
    String timeJSON = timeManager.getTimeJSON();
    
    delay(1000);
}

-------- [ Separator ] ------

File Name: test/tf_test.cpp_
Size: 2.25 KB
Code:
#include "FS.h"
#include "SD.h"
#include "SPI.h"

//SPI PINs
#define SCK_PIN  14
#define MISO_PIN  12
#define MOSI_PIN  13
#define CS5_PIN_TF_CARD  0

#define SD_CS 5  // Chip Select pin

void writeCSVHeader() {
    File file = SD.open("/data.csv", FILE_WRITE);
    if (file) {
        file.println("Date,Time,Temperature,Humidity");
        file.close();
        Serial.println("CSV header created");
    } else {
        Serial.println("Error creating CSV file");
    }
}

void writeCSVData(String date, String time, float temperature, float humidity) {
    File file = SD.open("/data.csv", FILE_APPEND);
    if (file) {
        file.print(date);
        file.print(",");
        file.print(time);
        file.print(",");
        file.print(temperature);
        file.print(",");
        file.println(humidity);
        file.close();
        Serial.println("Data appended to CSV");
    } else {
        Serial.println("Error opening CSV file for writing");
    }
}

void setup() {
    Serial.begin(115200);
    SPI.begin(SCK_PIN, MISO_PIN, MOSI_PIN);  // SCK, MISO, MOSI, SS
    
    // Initialize SD card
    if (!SD.begin(CS5_PIN_TF_CARD, SPI)) {
        Serial.println("Card Mount Failed");
        return;
    }
    
    uint8_t cardType = SD.cardType();
    if (cardType == CARD_NONE) {
        Serial.println("No SD card attached");
        return;
    }
    
    // Print card info
    Serial.print("SD Card Type: ");
    if (cardType == CARD_MMC) {
        Serial.println("MMC");
    } else if (cardType == CARD_SD) {
        Serial.println("SDSC");
    } else if (cardType == CARD_SDHC) {
        Serial.println("SDHC");
    } else {
        Serial.println("UNKNOWN");
    }
    
    uint64_t cardSize = SD.cardSize() / (1024 * 1024);
    Serial.printf("SD Card Size: %lluMB\n", cardSize);
    
    // Create CSV file with headers if it doesn't exist
    File file = SD.open("/data.csv");
    if (!file) {
        writeCSVHeader();
    }
    file.close();
    
    // Write some sample data
    writeCSVData("2025-06-14", "18:30:00", 25.6, 60.2);
    writeCSVData("2025-06-14", "18:31:00", 25.8, 59.8);
    
    Serial.println("CSV data written successfully!");
}



void loop() {
    // Your main code here
    // You can call writeCSVData() whenever you need to log data
    delay(1000);
}

-------- [ Separator ] ------

File Name: test/wifi_test.cpp_
Size: 601 B
Code:
#include "WiFi.h"

// Replace with your network credentials
const char* ssid = "Galaxy A5044BC";
const char* password = "bdov9428";

void setup() {
  Serial.begin(115200);
  
  // Connect to Wi-Fi
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi...");
  
  // Wait for connection
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  
  // Print connection details
  Serial.println("");
  Serial.println("WiFi connected!");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
}

void loop() {
  // Your code here
}

-------- [ Separator ] ------

File Name: unpacked_fs/dashboard.html
Size: 20.11 KB
Code:
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Temperature Monitoring System</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

.status-ok {
            color: #388e3c;
            font-weight: bold;
        }
        .status-error, .status-alarm, .status-unbound {
            color: #d32f2f;
            font-weight: bold;
        }
        .status-bound {
            color: #388e3c;
            font-weight: bold;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 10;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 8% auto;
            padding: 24px;
            border: 1px solid #888;
            width: 100%;
            max-width: 400px;
            border-radius: 6px;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover,
        .close:focus {
            color: #d32f2f;
            text-decoration: none;
            cursor: pointer;
        }
        .form-group {
            margin-bottom: 18px;
        }
        .form-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .form-group input[type="text"],
        .form-group input[type="number"] {
            width: 95%;
            padding: 6px;
            font-size: 1em;
        }
        .form-actions {
            text-align: right;
        }
        .form-actions button {
            margin-left: 10px;
            padding: 5px 15px;
        }
        
        /* Use styles from index.html */
        body {
            font-family: Arial, sans-serif;
            background: #f7f7f7;
            margin: 0;
            padding: 0;
        }
        header {
            background: #3f51b5;
            color: #fff;
            padding: 1em 2em;
            text-align: center;
            font-size: 1.5em;
            letter-spacing: 2px;
        }
        nav {
            background: #263238;
            padding: 0.5em 2em;
        }
        nav a {
            color: #fff;
            text-decoration: none;
            margin-right: 2em;
            font-weight: bold;
            transition: color 0.2s;
        }
        nav a:hover {
            color: #ffeb3b;
        }
        main {
            max-width: 1200px;
            margin: 2em auto;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            padding: 2em;
        }
        h2 {
            margin-top: 1em;
            color: #3f51b5;
            font-size: 1.2em;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.25em;
        }
        .actions {
            margin-bottom: 1.5em;
        }
        button {
            background: #3f51b5;
            color: #fff;
            border: none;
            padding: 0.5em 1.2em;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            margin-right: 0.5em;
            transition: background 0.2s;
        }
        button:hover {
            background: #283593;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 2em;
        }
        th, td {
            padding: 0.6em 0.8em;
            border-bottom: 1px solid #eee;
            text-align: left;
        }
        th {
            background: #f0f4ff;
            color: #3f51b5;
        }
        tr:last-child td {
            border-bottom: none;
        }
        .status-bound {
            color: #388e3c;
            font-weight: bold;
        }
        .status-unbound {
            color: #b71c1c;
            font-weight: bold;
        }
        .rom, .chip-select {
            font-family: monospace;
            font-size: 0.98em;
            color: #333;
        }
        @media (max-width: 800px) {
            main { padding: 1em; }
            th, td { font-size: 0.95em; }
        }
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            margin-top: 0;
        }
        .navbar {
            background-color: #333;
            overflow: hidden;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        .navbar a {
            float: left;
            display: block;
            color: white;
            text-align: center;
            padding: 14px 16px;
            text-decoration: none;
        }
        .navbar a:hover {
            background-color: #ddd;
            color: black;
        }
        .dashboard {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }
        .card {
            flex: 1;
            min-width: 300px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            background-color: #fff;
        }
        .card h2 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #f5f5f5;
        }
        .status-label {
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>Temperature Monitoring System</header>
        <nav>
            <a href="dashboard.html">Home</a>
            <a href="settings.html">Settings</a>
            <a href="sensors.html">Sensors</a>
            <a href="points.html">Points</a>
    
        </nav>
        

        
        <div class="dashboard">
            <div class="card">
                <h2>System Status</h2>
                <div id="system-status">
                    <p>Loading system status...</p>
                </div>
            </div>
            
            <div class="card">
                <h2>Sensor Overview</h2>
                <div id="sensor-overview">
                    <p>Loading sensor data...</p>
                </div>
            </div>
        </div>
    </div>


    <main>
    <h2>DS18B20 Points</h2>
    
        <table>
            <thead>
                <tr>
                    <th>Address</th>
                    <th>Name</th>
                    <th>Current Temp</th>
                    <th>Min Temp</th>
                    <th>Max Temp</th>
                    <th>Alarm Status</th>
                    <th>Error Status</th>

                </tr>
            </thead>
            <tbody id="dsPointsTbody">
                <tr><td colspan="11">Loading DS18B20 points...</td></tr>
            </tbody>
        </table>

        <h2>PT1000 Points</h2>
        <table>
            <thead>
                <tr>
                    <th>Address</th>
                    <th>Name</th>
                    <th>Current Temp</th>
                    <th>Min Temp</th>
                    <th>Max Temp</th>
                    <th>Alarm Status</th>
                    <th>Error Status</th>
                </tr>
            </thead>
            <tbody id="ptPointsTbody">
                <tr><td colspan="11">Loading PT1000 points...</td></tr>
            </tbody>
        </table>
    </main>

    <!-- Modal -->
    <div id="pointConfigModal" class="modal">
        <div class="modal-content">
            <span class="close" id="modalCloseBtn">&times;</span>
            <h2>Edit Point</h2>
            <form id="pointConfigForm">
                <input type="hidden" id="modalPointAddress">
                <div class="form-group">
                    <label for="modalPointName">Name</label>
                    <input type="text" id="modalPointName" required>
                </div>
                <div class="form-group">
                    <label for="modalLowAlarm">Low Alarm Threshold (°C)</label>
                    <input type="number" id="modalLowAlarm" step="0.1" required>
                </div>
                <div class="form-group">
                    <label for="modalHighAlarm">High Alarm Threshold (°C)</label>
                    <input type="number" id="modalHighAlarm" step="0.1" required>
                </div>
                <div class="form-actions">
                    <button type="submit" class="button">Save</button>
                    <button type="button" class="button" id="modalCancelBtn" style="background:#888;">Cancel</button>
                </div>
            </form>
        </div>
    </div>




    <script>

        // Auto-update interval (ms)
        const UPDATE_INTERVAL = 5000;
        // Fetch system status
        function fetchSystemStatus() {
            fetch('/api/status')
                .then(response => response.json())
                .then(data => {
                    displaySystemStatus(data);
                })
                .catch(error => {
                    console.error('Error fetching system status:', error);
                    document.getElementById('system-status').innerHTML = 
                        '<p>Error loading system status. Please try again.</p>';
                });
        }
        
        // Display system status
        function displaySystemStatus(data) {
            const container = document.getElementById('system-status');
            
            let html = '';
            html += `<div class="status-item"><span class="status-label">Device ID:</span> <span>${data.deviceId}</span></div>`;
            html += `<div class="status-item"><span class="status-label">Firmware Version:</span> <span>${(data.firmwareVersion >> 8)}.${data.firmwareVersion & 0xFF}</span></div>`;
            html += `<div class="status-item"><span class="status-label">Measurement Period:</span> <span>${data.measurementPeriod} seconds</span></div>`;
            html += `<div class="status-item"><span class="status-label">Uptime:</span> <span>${formatUptime(data.uptime)}</span></div>`;
            
            container.innerHTML = html;
        }
        
        // Format uptime in a human-readable way
        function formatUptime(seconds) {
            const days = Math.floor(seconds / 86400);
            seconds %= 86400;
            const hours = Math.floor(seconds / 3600);
            seconds %= 3600;
            const minutes = Math.floor(seconds / 60);
            seconds %= 60;
            
            let result = '';
            if (days > 0) result += `${days}d `;
            if (hours > 0 || days > 0) result += `${hours}h `;
            if (minutes > 0 || hours > 0 || days > 0) result += `${minutes}m `;
            result += `${seconds}s`;
            
            return result;
        }
        
        // Fetch sensor overview
        function fetchSensorOverview() {
            fetch('/api/sensors')
                .then(response => response.json())
                .then(data => {
                    displaySensorOverview(data);
                })
                .catch(error => {
                    console.error('Error fetching sensors:', error);
                    document.getElementById('sensor-overview').innerHTML = 
                        '<p>Error loading sensor data. Please try again.</p>';
                });
        }
        
        // Display sensor overview
        function displaySensorOverview(data) {
            const container = document.getElementById('sensor-overview');
            
            if (!data.sensors || data.sensors.length === 0) {
                container.innerHTML = '<p>No sensors found. Go to the Sensors page to discover and configure sensors.</p>';
                return;
            }
            
            let html = '';
            html += `<div class="status-item"><span class="status-label">Total Sensors:</span> <span>${data.sensors.length}</span></div>`;
            
            const ds18b20Count = data.sensors.filter(s => s.type === 'DS18B20').length;
            const pt1000Count = data.sensors.filter(s => s.type === 'PT1000').length;
            
            html += `<div class="status-item"><span class="status-label">DS18B20 Sensors:</span> <span>${ds18b20Count}</span></div>`;
            html += `<div class="status-item"><span class="status-label">PT1000 Sensors:</span> <span>${pt1000Count}</span></div>`;
            
            const alarmsCount = data.sensors.filter(s => s.alarmStatus > 0).length;
            const errorsCount = data.sensors.filter(s => s.errorStatus > 0).length;
            
            html += `<div class="status-item"><span class="status-label">Sensors in Alarm:</span> <span>${alarmsCount}</span></div>`;
            html += `<div class="status-item"><span class="status-label">Sensors with Errors:</span> <span>${errorsCount}</span></div>`;
            
            html += `<p><a href="/sensors.html">View all sensors</a></p>`;
            
            container.innerHTML = html;
        }
        
        // Load data when page loads
        document.addEventListener('DOMContentLoaded', () => {
            fetchSystemStatus();
            fetchSensorOverview();
        });
        
        // Refresh data every 5 seconds
        setInterval(() => {
            fetchSystemStatus();
            fetchSensorOverview();
        }, UPDATE_INTERVAL);



        // Helper functions for status rendering
        function getAlarmText(alarmStatus) {
            if (alarmStatus === 0) return '<span class="status-ok">OK</span>';
            const alarms = [];
            if (alarmStatus & 0x01) alarms.push('Low Temp');
            if (alarmStatus & 0x02) alarms.push('High Temp');
            return `<span class="status-alarm">${alarms.join(', ')}</span>`;
        }
        function getErrorText(errorStatus) {
            if (errorStatus === 0) return '<span class="status-ok">OK</span>';
            const errors = [];
            if (errorStatus & 0x01) errors.push('Comm');
            if (errorStatus & 0x02) errors.push('OutOfRange');
            if (errorStatus & 0x04) errors.push('Disconnected');
            return `<span class="status-error">${errors.join(', ')}</span>`;
        }
        function getSensorStatus(bound) {
            return bound
                ? '<span class="status-bound">Bound</span>'
                : '<span class="status-unbound">Unbound</span>';
        }

        // Modal logic
        const modal = document.getElementById('pointConfigModal');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        const modalCancelBtn = document.getElementById('modalCancelBtn');
        const pointConfigForm = document.getElementById('pointConfigForm');
        let currentEditPoint = null;

        function openModal(point) {
            currentEditPoint = point;
            document.getElementById('modalPointAddress').value = point.address;
            document.getElementById('modalPointName').value = point.name || '';
            document.getElementById('modalLowAlarm').value = point.lowAlarmThreshold;
            document.getElementById('modalHighAlarm').value = point.highAlarmThreshold;
            modal.style.display = "block";
        }
        function closeModal() {
            modal.style.display = "none";
            currentEditPoint = null;
        }
        modalCloseBtn.onclick = closeModal;
        modalCancelBtn.onclick = closeModal;
        window.onclick = function(event) {
            if (event.target === modal) closeModal();
        };

        // Fetch and render points
        function fetchAndRenderPoints() {
            fetch('/api/points')
                .then(res => res.json())
                .then(data => renderPointsTables(data.points))
                .catch(() => {
                    document.getElementById('dsPointsTbody').innerHTML = '<tr><td colspan="11">Failed to load points.</td></tr>';
                    document.getElementById('ptPointsTbody').innerHTML = '<tr><td colspan="11">Failed to load points.</td></tr>';
                });
        }

        function renderPointsTables(points) {
            const dsTbody = document.getElementById('dsPointsTbody');
            const ptTbody = document.getElementById('ptPointsTbody');
            dsTbody.innerHTML = '';
            ptTbody.innerHTML = '';

            const dsPoints = points.filter(p => p.type === "DS18B20");
            const ptPoints = points.filter(p => p.type === "PT1000");

            if (dsPoints.length === 0) {
                dsTbody.innerHTML = '<tr><td colspan="11">No DS18B20 points found.</td></tr>';
            } else {
                dsPoints.forEach(point => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${point.address}</td>
                        <td>${point.name || ''}</td>
                        <td>${point.currentTemp !== undefined ? point.currentTemp : ''}</td>
                        <td>${point.minTemp !== undefined ? point.minTemp : ''}</td>
                        <td>${point.maxTemp !== undefined ? point.maxTemp : ''}</td>
                        <td>${getAlarmText(point.alarmStatus)}</td>
                        <td>${getErrorText(point.errorStatus)}</td>
                       
                    `;
                    dsTbody.appendChild(row);
                });
            }

            if (ptPoints.length === 0) {
                ptTbody.innerHTML = '<tr><td colspan="11">No PT1000 points found.</td></tr>';
            } else {
                ptPoints.forEach(point => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${point.address}</td>
                        <td>${point.name || ''}</td>
                        <td>${point.currentTemp !== undefined ? point.currentTemp : ''}</td>
                        <td>${point.minTemp !== undefined ? point.minTemp : ''}</td>
                        <td>${point.maxTemp !== undefined ? point.maxTemp : ''}</td>
                        <td>${getAlarmText(point.alarmStatus)}</td>
                        <td>${getErrorText(point.errorStatus)}</td>
                      
                    `;
                    ptTbody.appendChild(row);
                });
            }
        }

        // Edit handler
        function onEditPoint(address) {
            fetch('/api/points')
                .then(res => res.json())
                .then(data => {
                    const point = data.points.find(p => p.address === address);
                    if (point) openModal(point);
                });
        }
        window.onEditPoint = onEditPoint;

        // Handle form submit
        pointConfigForm.onsubmit = function(e) {
            e.preventDefault();
            const address = parseInt(document.getElementById('modalPointAddress').value, 10);
            const name = document.getElementById('modalPointName').value;
            const lowAlarm = parseFloat(document.getElementById('modalLowAlarm').value);
            const highAlarm = parseFloat(document.getElementById('modalHighAlarm').value);

            fetch('/api/points', {
                method: 'PUT',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ address, name, lowAlarmThreshold: lowAlarm, highAlarmThreshold: highAlarm })
            })
            .then(res => {
                if (!res.ok) throw new Error('Failed to update point');
                closeModal();
                fetchAndRenderPoints();
            })
            .catch(() => alert('Failed to update point!'));
        };

        // Initial load
        setInterval(fetchAndRenderPoints, UPDATE_INTERVAL);
        window.onload = fetchAndRenderPoints();
        // Optionally, set up periodic refresh if needed
        // setInterval(fetchAndRenderPoints, 10000);
    </script>
</body>
</html>

-------- [ Separator ] ------

File Name: unpacked_fs/points.html
Size: 14.30 KB
Code:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Measurement Points</title>
    <style>
        .status-ok {
            color: #388e3c;
            font-weight: bold;
        }
        .status-error, .status-alarm, .status-unbound {
            color: #d32f2f;
            font-weight: bold;
        }
        .status-bound {
            color: #388e3c;
            font-weight: bold;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 10;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 8% auto;
            padding: 24px;
            border: 1px solid #888;
            width: 100%;
            max-width: 400px;
            border-radius: 6px;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover,
        .close:focus {
            color: #d32f2f;
            text-decoration: none;
            cursor: pointer;
        }
        .form-group {
            margin-bottom: 18px;
        }
        .form-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .form-group input[type="text"],
        .form-group input[type="number"] {
            width: 95%;
            padding: 6px;
            font-size: 1em;
        }
        .form-actions {
            text-align: right;
        }
        .form-actions button {
            margin-left: 10px;
            padding: 5px 15px;
        }
        
        /* Use styles from index.html */
        body {
            font-family: Arial, sans-serif;
            background: #f7f7f7;
            margin: 0;
            padding: 0;
        }
        header {
            background: #3f51b5;
            color: #fff;
            padding: 1em 2em;
            text-align: center;
            font-size: 1.5em;
            letter-spacing: 2px;
        }
        nav {
            background: #263238;
            padding: 0.5em 2em;
        }
        nav a {
            color: #fff;
            text-decoration: none;
            margin-right: 2em;
            font-weight: bold;
            transition: color 0.2s;
        }
        nav a:hover {
            color: #ffeb3b;
        }
        main {
            max-width: 1200px;
            margin: 2em auto;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            padding: 2em;
        }
        h2 {
            margin-top: 1em;
            color: #3f51b5;
            font-size: 1.2em;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.25em;
        }
        .actions {
            margin-bottom: 1.5em;
        }
        button {
            background: #3f51b5;
            color: #fff;
            border: none;
            padding: 0.5em 1.2em;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            margin-right: 0.5em;
            transition: background 0.2s;
        }
        button:hover {
            background: #283593;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 2em;
        }
        th, td {
            padding: 0.6em 0.8em;
            border-bottom: 1px solid #eee;
            text-align: left;
        }
        th {
            background: #f0f4ff;
            color: #3f51b5;
        }
        tr:last-child td {
            border-bottom: none;
        }
        .status-bound {
            color: #388e3c;
            font-weight: bold;
        }
        .status-unbound {
            color: #b71c1c;
            font-weight: bold;
        }
        .rom, .chip-select {
            font-family: monospace;
            font-size: 0.98em;
            color: #333;
        }
        @media (max-width: 800px) {
            main { padding: 1em; }
            th, td { font-size: 0.95em; }
        }
    
    </style>
</head>
<body>
    <header>Measurement Points</header>
    <nav>
        <a href="dashboard.html">Home</a>
        <a href="settings.html">Settings</a>
        <a href="sensors.html">Sensors</a>
        <a href="points.html">Points</a>

    </nav>
    <main>
    <h2>DS18B20 Points</h2>
    
        <table>
            <thead>
                <tr>
                    <th>Address</th>
                    <th>Name</th>
                    <th>Current Temp</th>
                    <th>Min Temp</th>
                    <th>Max Temp</th>
                    <th>Low Alarm</th>
                    <th>High Alarm</th>
                    <th>Alarm Status</th>
                    <th>Error Status</th>
                    <th>Sensor Status</th>
                    <th>Edit</th>
                </tr>
            </thead>
            <tbody id="dsPointsTbody">
                <tr><td colspan="11">Loading DS18B20 points...</td></tr>
            </tbody>
        </table>

        <h2>PT1000 Points</h2>
        <table>
            <thead>
                <tr>
                    <th>Address</th>
                    <th>Name</th>
                    <th>Current Temp</th>
                    <th>Min Temp</th>
                    <th>Max Temp</th>
                    <th>Low Alarm</th>
                    <th>High Alarm</th>
                    <th>Alarm Status</th>
                    <th>Error Status</th>
                    <th>Sensor Status</th>
                    <th>Edit</th>
                </tr>
            </thead>
            <tbody id="ptPointsTbody">
                <tr><td colspan="11">Loading PT1000 points...</td></tr>
            </tbody>
        </table>
    </main>

    <!-- Modal -->
    <div id="pointConfigModal" class="modal">
        <div class="modal-content">
            <span class="close" id="modalCloseBtn">&times;</span>
            <h2>Edit Point</h2>
            <form id="pointConfigForm">
                <input type="hidden" id="modalPointAddress">
                <div class="form-group">
                    <label for="modalPointName">Name</label>
                    <input type="text" id="modalPointName" required>
                </div>
                <div class="form-group">
                    <label for="modalLowAlarm">Low Alarm Threshold (°C)</label>
                    <input type="number" id="modalLowAlarm" step="0.1" required>
                </div>
                <div class="form-group">
                    <label for="modalHighAlarm">High Alarm Threshold (°C)</label>
                    <input type="number" id="modalHighAlarm" step="0.1" required>
                </div>
                <div class="form-actions">
                    <button type="submit" class="button">Save</button>
                    <button type="button" class="button" id="modalCancelBtn" style="background:#888;">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // Auto-update interval (ms)
        const UPDATE_INTERVAL = 5000;
        // Helper functions for status rendering
        function getAlarmText(alarmStatus) {
            if (alarmStatus === 0) return '<span class="status-ok">OK</span>';
            const alarms = [];
            if (alarmStatus & 0x01) alarms.push('Low Temp');
            if (alarmStatus & 0x02) alarms.push('High Temp');
            return `<span class="status-alarm">${alarms.join(', ')}</span>`;
        }
        function getErrorText(errorStatus) {
            if (errorStatus === 0) return '<span class="status-ok">OK</span>';
            const errors = [];
            if (errorStatus & 0x01) errors.push('Comm');
            if (errorStatus & 0x02) errors.push('OutOfRange');
            if (errorStatus & 0x04) errors.push('Disconnected');
            return `<span class="status-error">${errors.join(', ')}</span>`;
        }
        function getSensorStatus(bound) {
            return bound
                ? '<span class="status-bound">Bound</span>'
                : '<span class="status-unbound">Unbound</span>';
        }

        // Modal logic
        const modal = document.getElementById('pointConfigModal');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        const modalCancelBtn = document.getElementById('modalCancelBtn');
        const pointConfigForm = document.getElementById('pointConfigForm');
        let currentEditPoint = null;

        function openModal(point) {
            currentEditPoint = point;
            document.getElementById('modalPointAddress').value = point.address;
            document.getElementById('modalPointName').value = point.name || '';
            document.getElementById('modalLowAlarm').value = point.lowAlarmThreshold;
            document.getElementById('modalHighAlarm').value = point.highAlarmThreshold;
            modal.style.display = "block";
        }
        function closeModal() {
            modal.style.display = "none";
            currentEditPoint = null;
        }
        modalCloseBtn.onclick = closeModal;
        modalCancelBtn.onclick = closeModal;
        window.onclick = function(event) {
            if (event.target === modal) closeModal();
        };

        // Fetch and render points
        function fetchAndRenderPoints() {
            fetch('/api/points')
                .then(res => res.json())
                .then(data => renderPointsTables(data.points))
                .catch(() => {
                    document.getElementById('dsPointsTbody').innerHTML = '<tr><td colspan="11">Failed to load points.</td></tr>';
                    document.getElementById('ptPointsTbody').innerHTML = '<tr><td colspan="11">Failed to load points.</td></tr>';
                });
        }

        function renderPointsTables(points) {
            const dsTbody = document.getElementById('dsPointsTbody');
            const ptTbody = document.getElementById('ptPointsTbody');
            dsTbody.innerHTML = '';
            ptTbody.innerHTML = '';

            const dsPoints = points.filter(p => p.type === "DS18B20");
            const ptPoints = points.filter(p => p.type === "PT1000");

            if (dsPoints.length === 0) {
                dsTbody.innerHTML = '<tr><td colspan="11">No DS18B20 points found.</td></tr>';
            } else {
                dsPoints.forEach(point => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${point.address}</td>
                        <td>${point.name || ''}</td>
                        <td>${point.currentTemp !== undefined ? point.currentTemp : ''}</td>
                        <td>${point.minTemp !== undefined ? point.minTemp : ''}</td>
                        <td>${point.maxTemp !== undefined ? point.maxTemp : ''}</td>
                        <td>${point.lowAlarmThreshold !== undefined ? point.lowAlarmThreshold : ''}</td>
                        <td>${point.highAlarmThreshold !== undefined ? point.highAlarmThreshold : ''}</td>
                        <td>${getAlarmText(point.alarmStatus)}</td>
                        <td>${getErrorText(point.errorStatus)}</td>
                        <td>${getSensorStatus(!!point.sensorRomString)}</td>
                        <td><button class="button" onclick='onEditPoint(${point.address})'>Edit</button></td>
                    `;
                    dsTbody.appendChild(row);
                });
            }

            if (ptPoints.length === 0) {
                ptTbody.innerHTML = '<tr><td colspan="11">No PT1000 points found.</td></tr>';
            } else {
                ptPoints.forEach(point => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${point.address}</td>
                        <td>${point.name || ''}</td>
                        <td>${point.currentTemp !== undefined ? point.currentTemp : ''}</td>
                        <td>${point.minTemp !== undefined ? point.minTemp : ''}</td>
                        <td>${point.maxTemp !== undefined ? point.maxTemp : ''}</td>
                        <td>${point.lowAlarmThreshold !== undefined ? point.lowAlarmThreshold : ''}</td>
                        <td>${point.highAlarmThreshold !== undefined ? point.highAlarmThreshold : ''}</td>
                        <td>${getAlarmText(point.alarmStatus)}</td>
                        <td>${getErrorText(point.errorStatus)}</td>
                        <td>${getSensorStatus(!!point.chipSelectPin)}</td>
                        <td><button class="button" onclick='onEditPoint(${point.address})'>Edit</button></td>
                    `;
                    ptTbody.appendChild(row);
                });
            }
        }

        // Edit handler
        function onEditPoint(address) {
            fetch('/api/points')
                .then(res => res.json())
                .then(data => {
                    const point = data.points.find(p => p.address === address);
                    if (point) openModal(point);
                });
        }
        window.onEditPoint = onEditPoint;

        // Handle form submit
        pointConfigForm.onsubmit = function(e) {
            e.preventDefault();
            const address = parseInt(document.getElementById('modalPointAddress').value, 10);
            const name = document.getElementById('modalPointName').value;
            const lowAlarm = parseFloat(document.getElementById('modalLowAlarm').value);
            const highAlarm = parseFloat(document.getElementById('modalHighAlarm').value);

            fetch('/api/points', {
                method: 'PUT',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ address, name, lowAlarmThreshold: lowAlarm, highAlarmThreshold: highAlarm })
            })
            .then(res => {
                if (!res.ok) throw new Error('Failed to update point');
                closeModal();
                fetchAndRenderPoints();
            })
            .catch(() => alert('Failed to update point!'));
        };

        // Initial load
        setInterval(fetchAndRenderPoints, UPDATE_INTERVAL);
        window.onload = fetchAndRenderPoints();
        // Optionally, set up periodic refresh if needed
        // setInterval(fetchAndRenderPoints, 10000);
    </script>
</body>
</html>

-------- [ Separator ] ------

File Name: unpacked_fs/sensors.html
Size: 15.65 KB
Code:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sensors Management</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        /* Use styles from index.html */
        body {
            font-family: Arial, sans-serif;
            background: #f7f7f7;
            margin: 0;
            padding: 0;
        }
        header {
            background: #3f51b5;
            color: #fff;
            padding: 1em 2em;
            text-align: center;
            font-size: 1.5em;
            letter-spacing: 2px;
        }
        nav {
            background: #263238;
            padding: 0.5em 2em;
        }
        nav a {
            color: #fff;
            text-decoration: none;
            margin-right: 2em;
            font-weight: bold;
            transition: color 0.2s;
        }
        nav a:hover {
            color: #ffeb3b;
        }
        main {
            max-width: 1200px;
            margin: 2em auto;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            padding: 2em;
        }
        h2 {
            margin-top: 1em;
            color: #3f51b5;
            font-size: 1.2em;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.25em;
        }
        .actions {
            margin-bottom: 1.5em;
        }
        button {
            background: #3f51b5;
            color: #fff;
            border: none;
            padding: 0.5em 1.2em;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            margin-right: 0.5em;
            transition: background 0.2s;
        }
        button:hover {
            background: #283593;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 2em;
        }
        th, td {
            padding: 0.6em 0.8em;
            border-bottom: 1px solid #eee;
            text-align: left;
        }
        th {
            background: #f0f4ff;
            color: #3f51b5;
        }
        tr:last-child td {
            border-bottom: none;
        }
        .status-bound {
            color: #388e3c;
            font-weight: bold;
        }
        .status-unbound {
            color: #b71c1c;
            font-weight: bold;
        }
        .rom, .chip-select {
            font-family: monospace;
            font-size: 0.98em;
            color: #333;
        }
        @media (max-width: 800px) {
            main { padding: 1em; }
            th, td { font-size: 0.95em; }
        }
    </style>
</head>
<body>
    <header>Temperature Monitoring System</header>
    <nav>
        <a href="dashboard.html">Home</a>
        <a href="settings.html">Settings</a>
        <a href="sensors.html">Sensors</a>
        <a href="points.html">Points</a>

    </nav>
    <main>
        <div class="actions">
            <button id="discoverBtn">Discover</button>
            <button id="resetMinMaxBtn">Reset Min/Max</button>
        </div>

        <h2>DS18B20 Sensors</h2>
        <table id="dsTable">
            <thead>
                <tr>
                    <th>#</th>
                    <th>Name</th>
                    <th>ROM Address</th>
                    <th>Bus</th>
                    <th>Current Temp (°C)</th>
                    <th>Min Temp (°C)</th>
                    <th>Max Temp (°C)</th>
                    <th>Measurement Point</th>
                    <th>Errors</th>
                    <th>Alarms</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="dsTbody">
                <tr><td colspan="8">Loading DS18B20 sensors...</td></tr>
            </tbody>
        </table>

        <h2>PT1000 Sensors</h2>
        <table id="ptTable">
            <thead>
                <tr>
                    <th>#</th>
                    <th>Name</th>
                    <th>Chip Select Pin</th>
                    <th>Current Temp (°C)</th>
                    <th>Min Temp (°C)</th>
                    <th>Max Temp (°C)</th>
                    <th>Measurement Point</th>
                    <th>Errors</th>
                    <th>Alarms</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody id="ptTbody">
                <tr><td colspan="8">Loading PT1000 sensors...</td></tr>
            </tbody>
        </table>
    </main>
    <script>
        // Auto-update interval (ms)
        const UPDATE_INTERVAL = 5000;

        function fetchSensors() {
            fetch('/api/sensors')
                .then(res => res.json())
                .then(data => {
                    renderSensorTables(data.sensors || []);
                });
        }

        // function renderSensorTables(sensors) {
        //     // Separate DS and PT
        //     const dsSensors = sensors.filter(s => s.type === "DS18B20");
        //     const ptSensors = sensors.filter(s => s.type === "PT1000");

        //     // DS Table
        //     const dsTbody = document.getElementById('dsTbody');
        //     dsTbody.innerHTML = '';
        //     if (dsSensors.length === 0) {
        //         dsTbody.innerHTML = '<tr><td colspan="8">No DS18B20 sensors found.</td></tr>';
        //     } else {
        //         dsSensors.forEach((sensor, idx) => {
        //             const row = document.createElement('tr');
        //             row.innerHTML = `
        //                 <td>${idx+1}</td>
        //                 <td>${sensor.name || ''}</td>
        //                 <td class="rom">${sensor.romString || ''}</td>
        //                 <td>${sensor.currentTemp !== undefined ? sensor.currentTemp : ''}</td>
        //                 <td>${sensor.minTemp !== undefined ? sensor.minTemp : ''}</td>
        //                 <td>${sensor.maxTemp !== undefined ? sensor.maxTemp : ''}</td>
        //                 <td>
        //                     ${sensor.boundPoint !== null && sensor.boundPoint !== undefined
        //                         ? `<span class="status-bound">#${sensor.boundPoint}</span>`
        //                         : `<span class="status-unbound">Unbound</span>`}
        //                 </td>
        //                 <td>
        //                     ${sensor.boundPoint === null || sensor.boundPoint === undefined
        //                         ? `<button onclick="bindPrompt('DS18B20','${sensor.romString}')">Bind</button>`
        //                         : `<button onclick="unbindSensor('DS18B20','${sensor.romString}')">Unbind</button>`}
        //                 </td>
        //             `;
        //             dsTbody.appendChild(row);
        //         });
        //     }

        //     // PT Table
        //     const ptTbody = document.getElementById('ptTbody');
        //     ptTbody.innerHTML = '';
        //     if (ptSensors.length === 0) {
        //         ptTbody.innerHTML = '<tr><td colspan="8">No PT1000 sensors found.</td></tr>';
        //     } else {
        //         ptSensors.forEach((sensor, idx) => {
        //             const row = document.createElement('tr');
        //             row.innerHTML = `
        //                 <td>${idx+1}</td>
        //                 <td>${sensor.name || ''}</td>
        //                 <td class="chip-select">${sensor.chipSelectPin !== undefined ? sensor.chipSelectPin : ''}</td>
        //                 <td>${sensor.currentTemp !== undefined ? sensor.currentTemp : ''}</td>
        //                 <td>${sensor.minTemp !== undefined ? sensor.minTemp : ''}</td>
        //                 <td>${sensor.maxTemp !== undefined ? sensor.maxTemp : ''}</td>
        //                 <td>
        //                     ${sensor.boundPoint !== null && sensor.boundPoint !== undefined
        //                         ? `<span class="status-bound">#${sensor.boundPoint}</span>`
        //                         : `<span class="status-unbound">Unbound</span>`}
        //                 </td>
        //                 <td>
        //                     ${sensor.boundPoint === null || sensor.boundPoint === undefined
        //                         ? `<button onclick="bindPrompt('PT1000','${sensor.chipSelectPin}')">Bind</button>`
        //                         : `<button onclick="unbindSensor('PT1000','${sensor.chipSelectPin}')">Unbind</button>`}
        //                 </td>
        //             `;
        //             ptTbody.appendChild(row);
        //         });
        //     }
        // }

        function renderSensorTables(sensors) {
    // Separate DS and PT
    const dsSensors = sensors.filter(s => s.type === "DS18B20");
    const ptSensors = sensors.filter(s => s.type === "PT1000");

    // Helper functions to interpret status bitmasks
    function getErrorText(errorStatus) {
        if (errorStatus === 0) return '';
        
        const errors = [];
        if (errorStatus & 0x01) errors.push('Communication Error');
        if (errorStatus & 0x02) errors.push('Out of Range');
        if (errorStatus & 0x04) errors.push('Disconnected');
        
        return errors.join(', ');
    }
    
    function getAlarmText(alarmStatus) {
        if (alarmStatus === 0) return '';
        
        const alarms = [];
        if (alarmStatus & 0x01) alarms.push('Low Temperature');
        if (alarmStatus & 0x02) alarms.push('High Temperature');
        
        return alarms.join(', ');
    }
    
    function getStatusClass(errorStatus, alarmStatus) {
        if (errorStatus > 0) return 'status-error';
        if (alarmStatus > 0) return 'status-alarm';
        return 'status-normal';
    }

    // DS Table
    const dsTbody = document.getElementById('dsTbody');
    dsTbody.innerHTML = '';
    if (dsSensors.length === 0) {
        dsTbody.innerHTML = '<tr><td colspan="10">No DS18B20 sensors found.</td></tr>';
    } else {
        dsSensors.forEach((sensor, idx) => {
            const errorText = getErrorText(sensor.errorStatus);
            const alarmText = getAlarmText(sensor.alarmStatus);
            const statusClass = getStatusClass(sensor.errorStatus, sensor.alarmStatus);
            
            const row = document.createElement('tr');
            row.className = statusClass;
            row.innerHTML = `
                <td>${idx+1}</td>
                <td>${sensor.name || ''}</td>
                <td class="rom">${sensor.romString || ''}</td>
                <td>${sensor.bus || ''}</td>
                <td>${sensor.currentTemp !== undefined ? sensor.currentTemp : ''}</td>
                <td>${sensor.minTemp !== undefined ? sensor.minTemp : ''}</td>
                <td>${sensor.maxTemp !== undefined ? sensor.maxTemp : ''}</td>
                <td>
                    ${sensor.boundPoint !== null && sensor.boundPoint !== undefined
                        ? `<span class="status-bound">#${sensor.boundPoint}</span>`
                        : `<span class="status-unbound">Unbound</span>`}
                </td>
                <td class="${errorText ? 'error-cell' : ''}">${errorText}</td>
                <td class="${alarmText ? 'alarm-cell' : ''}">${alarmText}</td>
                <td>
                    ${sensor.boundPoint === null || sensor.boundPoint === undefined
                        ? `<button onclick="bindPrompt('DS18B20','${sensor.romString}')">Bind</button>`
                        : `<button onclick="unbindSensor('DS18B20','${sensor.romString}')">Unbind</button>`}
                </td>
            `;
            dsTbody.appendChild(row);
        });
    }

    // PT Table
    const ptTbody = document.getElementById('ptTbody');
    ptTbody.innerHTML = '';
    if (ptSensors.length === 0) {
        ptTbody.innerHTML = '<tr><td colspan="10">No PT1000 sensors found.</td></tr>';
    } else {
        ptSensors.forEach((sensor, idx) => {
            const errorText = getErrorText(sensor.errorStatus);
            const alarmText = getAlarmText(sensor.alarmStatus);
            const statusClass = getStatusClass(sensor.errorStatus, sensor.alarmStatus);
            
            const row = document.createElement('tr');
            row.className = statusClass;
            row.innerHTML = `
                <td>${idx+1}</td>
                <td>${sensor.name || ''}</td>
                <td class="chip-select">${sensor.chipSelectPin !== undefined ? sensor.chipSelectPin : ''}</td>
                <td>${sensor.currentTemp !== undefined ? sensor.currentTemp : ''}</td>
                <td>${sensor.minTemp !== undefined ? sensor.minTemp : ''}</td>
                <td>${sensor.maxTemp !== undefined ? sensor.maxTemp : ''}</td>
                <td>
                    ${sensor.boundPoint !== null && sensor.boundPoint !== undefined
                        ? `<span class="status-bound">#${sensor.boundPoint}</span>`
                        : `<span class="status-unbound">Unbound</span>`}
                </td>
                <td class="${errorText ? 'error-cell' : ''}">${errorText}</td>
                <td class="${alarmText ? 'alarm-cell' : ''}">${alarmText}</td>
                <td>
                    ${sensor.boundPoint === null || sensor.boundPoint === undefined
                        ? `<button onclick="bindPrompt('PT1000','${sensor.chipSelectPin}')">Bind</button>`
                        : `<button onclick="unbindSensor('PT1000','${sensor.chipSelectPin}')">Unbind</button>`}
                </td>
            `;
            ptTbody.appendChild(row);
        });
    }
}


        // Prompt user for measurement point to bind
        function bindPrompt(type, id) {
            let point = prompt("Enter Measurement Point address to bind:");
            if (point === null || point.trim() === "") return;
            point = parseInt(point, 10);
            if (isNaN(point)) {
                alert("Invalid address!");
                return;
            }
            bindSensor(type, id, point);
        }

        // Bind sensor to point
        function bindSensor(type, id, pointAddress) {
            let payload = { pointAddress };
            if (type === "DS18B20") payload.romString = id;
            else if (type === "PT1000") payload.chipSelect = parseInt(id, 10);
            fetch('/api/sensor-bind', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            }).then(res => {
                if (res.ok) fetchSensors();
                else alert("Failed to bind sensor");
            });
        }

        // Unbind sensor
        function unbindSensor(type, id) {
            let payload = {};
            if (type === "DS18B20") payload.romString = id;
            else if (type === "PT1000") payload.chipSelect = parseInt(id, 10);
            fetch('/api/sensor-unbind', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            }).then(res => {
                if (res.ok) fetchSensors();
                else alert("Failed to unbind sensor");
            });
        }

        // Discover sensors
        document.getElementById('discoverBtn').onclick = function() {
            fetch('/api/discover', { method: 'POST' })
                .then(res => {
                    if (res.ok) fetchSensors();
                    else alert("Discovery failed");
                });
        };

        // Reset min/max
        document.getElementById('resetMinMaxBtn').onclick = function() {
            fetch('/api/reset-minmax', { method: 'POST' })
                .then(res => {
                    if (res.ok) fetchSensors();
                    else alert("Reset failed");
                });
        };

        // Auto-update
        setInterval(fetchSensors, UPDATE_INTERVAL);
        window.onload = fetchSensors;
    </script>
</body>
</html>

-------- [ Separator ] ------
